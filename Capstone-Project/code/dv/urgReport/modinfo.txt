===============================================================================
Module : $unit::/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/macros/uvm_callback_defines.svh::/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/macros/uvm_deprecated_defines.svh...@2851332342
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  0.00   0.00 --       0.00 --     --     

Source File(s) : 

/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/uvm_pkg.sv

Module self-instances :

SCORE LINE COND TOGGLE BRANCH ASSERT NAME 



-------------------------------------------------------------------------------
Line Coverage for Module : \$unit::/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/macros/uvm_callback_defines.svh::/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/macros/uvm_deprecated_defines.svh...@2851332342 

             Line No.   Total   Covered  Percent
TOTAL                       23        0     0.00
ROUTINE            19        1        0     0.00
ROUTINE            50        9        0     0.00
ROUTINE            67        9        0     0.00
ROUTINE            74        4        0     0.00

FILE: /usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/vcs/uvm_custom_install_vcs_recorder.sv
18                      
19         0/1     ==>   import "DPI-C" function string getenv(input string env_name);

  FILE: /usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/verdi/uvm_verdi_tr_database.svh
50         0/1     ==>      if (!plusargs_tested) begin
51         0/1     ==>          if (verdi_clp.is_verdi_trace_tlm()) begin
52         0/1     ==>              enable_port_recording = 1;
53         0/1     ==>              if (verdi_clp.is_verdi_trace_imp())
54         0/1     ==>                  enable_imp_port_recording = 1 ;
                   ==>  MISSING_ELSE
55                              end
                   ==>  MISSING_ELSE
56         0/1     ==>          if (clp.get_arg_matches("+verdi_recorder_debug",trace_args))
57         0/1     ==>              enable_verdi_debug = 1;
                   ==>  MISSING_ELSE
58         0/1     ==>          plusargs_tested = 1;
59                          end
                   ==>  MISSING_ELSE
60         0/1     ==>      return plusargs_tested;
61                      endfunction
62                      
63                      function bit test_tlm2_port_plusargs ();
64                          static verdi_cmdline_processor verdi_clp = verdi_cmdline_processor::get_inst();
65                          static uvm_cmdline_processor clp = uvm_cmdline_processor::get_inst();
66                          string trace_args[$];
67         0/1     ==>      if (!plusargs_tested) begin
68         0/1     ==>          if (verdi_clp.is_verdi_trace_tlm2()) begin
69         0/1     ==>              enable_tlm2_port_recording = 1;
70         0/1     ==>              if (verdi_clp.is_verdi_trace_imp())
71         0/1     ==>                  enable_imp_port_recording = 1 ;
                   ==>  MISSING_ELSE
72                              end
                   ==>  MISSING_ELSE
73         0/1     ==>          if (clp.get_arg_matches("+verdi_recorder_debug",trace_args))
74         0/1     ==>              enable_verdi_debug = 1;
                   ==>  MISSING_ELSE
75         0/1     ==>          plusargs_tested = 1;
76                          end
                   ==>  MISSING_ELSE
77         0/1     ==>      return plusargs_tested;

  FILE: /usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/verdi/./dpi/uvm_verdi_dpi.svh
74         0/1     ==>       $sformat(attr_name,"+name+%s",attrName);
75         0/1     ==>       $sformat(val_name,"%s",valName);
76         0/1     ==>       st_handle = handle;
77         0/1     ==>       pli_inst.add_attribute_string(st_handle,val_name,attr_name,"+numbit+0");

-------------------------------------------------------------------------------
Toggle Coverage for Module : \$unit::/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/macros/uvm_callback_defines.svh::/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/macros/uvm_deprecated_defines.svh...@2851332342 
                Total Covered Percent 
Totals          6     0       0.00    
Total Bits      12    0       0.00    
Total Bits 0->1 6     0       0.00    
Total Bits 1->0 6     0       0.00    

                             
Signals          6  0 0.00   
Signal Bits      12 0 0.00   
Signal Bits 0->1 6  0 0.00   
Signal Bits 1->0 6  0 0.00   

Signal Details
                           Toggle Toggle 1->0 Toggle 0->1 
hooks_version_flag         No     No          No          
plusargs_tested            No     No          No          
enable_verdi_debug         No     No          No          
enable_port_recording      No     No          No          
enable_tlm2_port_recording No     No          No          
enable_imp_port_recording  No     No          No          


===============================================================================
Module : uvm_pkg
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  0.00 --     --     --     --       0.00 

Source File(s) : 

/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/uvm_pkg.sv

Module self-instances :

SCORE LINE COND TOGGLE BRANCH ASSERT NAME 



-------------------------------------------------------------------------------
Assert Coverage for Module : uvm_pkg
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       2     0         0.00    0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            2     0         0.00    0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                                            Attempts Real Successes Failures Incomplete 
\uvm_reg_map::do_read .unnamed$$_0.unnamed$$_1  0        0              0        0          
\uvm_reg_map::do_write .unnamed$$_0.unnamed$$_1 0        0              0        0          


===============================================================================
Module : ibex_top_tracing
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  0.12 --     --       0.12 --     --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_top_tracing.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
  0.12 --     --       0.12 --     --     tb_top.DUT 



-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_top_tracing
                Total Covered Percent 
Totals          62    1       1.61    
Total Bits      1646  2       0.12    
Total Bits 0->1 823   1       0.12    
Total Bits 1->0 823   1       0.12    

                            
Ports          39  1 2.56   
Port Bits      806 2 0.25   
Port Bits 0->1 403 1 0.25   
Port Bits 1->0 403 1 0.25   

                              
Signals          23  0 0.00   
Signal Bits      840 0 0.00   
Signal Bits 0->1 420 0 0.00   
Signal Bits 1->0 420 0 0.00   

Port Details
                                  Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                             Yes    Yes         Yes         INPUT     
rst_ni                            No     No          No          INPUT     
test_en_i                         No     No          No          INPUT     
scan_rst_ni                       No     No          No          INPUT     
ram_cfg_i.rf_cfg.cfg[3:0]         No     No          No          INPUT     
ram_cfg_i.rf_cfg.cfg_en           No     No          No          INPUT     
ram_cfg_i.ram_cfg.cfg[3:0]        No     No          No          INPUT     
ram_cfg_i.ram_cfg.cfg_en          No     No          No          INPUT     
hart_id_i[31:0]                   No     No          No          INPUT     
boot_addr_i[31:0]                 No     No          No          INPUT     
instr_req_o                       No     No          No          OUTPUT    
instr_gnt_i                       No     No          No          INPUT     
instr_rvalid_i                    No     No          No          INPUT     
instr_addr_o[31:0]                No     No          No          OUTPUT    
instr_rdata_i[31:0]               No     No          No          INPUT     
instr_err_i                       No     No          No          INPUT     
data_req_o                        No     No          No          OUTPUT    
data_gnt_i                        No     No          No          INPUT     
data_rvalid_i                     No     No          No          INPUT     
data_we_o                         No     No          No          OUTPUT    
data_be_o[3:0]                    No     No          No          OUTPUT    
data_addr_o[31:0]                 No     No          No          OUTPUT    
data_wdata_o[31:0]                No     No          No          OUTPUT    
data_rdata_i[31:0]                No     No          No          INPUT     
data_err_i                        No     No          No          INPUT     
irq_software_i                    No     No          No          INPUT     
irq_timer_i                       No     No          No          INPUT     
irq_external_i                    No     No          No          INPUT     
irq_fast_i[14:0]                  No     No          No          INPUT     
irq_nm_i                          No     No          No          INPUT     
debug_req_i                       No     No          No          INPUT     
crash_dump_o.exception_addr[31:0] No     No          No          OUTPUT    
crash_dump_o.last_data_addr[31:0] No     No          No          OUTPUT    
crash_dump_o.next_pc[31:0]        No     No          No          OUTPUT    
crash_dump_o.current_pc[31:0]     No     No          No          OUTPUT    
fetch_enable_i                    No     No          No          INPUT     
alert_minor_o                     No     No          No          OUTPUT    
alert_major_o                     No     No          No          OUTPUT    
core_sleep_o                      No     No          No          OUTPUT    

Signal Details
                     Toggle Toggle 1->0 Toggle 0->1 
rvfi_valid           No     No          No          
rvfi_order[63:0]     No     No          No          
rvfi_insn[31:0]      No     No          No          
rvfi_trap            No     No          No          
rvfi_halt            No     No          No          
rvfi_intr            No     No          No          
rvfi_mode[1:0]       No     No          No          
rvfi_ixl[1:0]        No     No          No          
rvfi_rs1_addr[4:0]   No     No          No          
rvfi_rs2_addr[4:0]   No     No          No          
rvfi_rs3_addr[4:0]   No     No          No          
rvfi_rs1_rdata[31:0] No     No          No          
rvfi_rs2_rdata[31:0] No     No          No          
rvfi_rs3_rdata[31:0] No     No          No          
rvfi_rd_addr[4:0]    No     No          No          
rvfi_rd_wdata[31:0]  No     No          No          
rvfi_pc_rdata[31:0]  No     No          No          
rvfi_pc_wdata[31:0]  No     No          No          
rvfi_mem_addr[31:0]  No     No          No          
rvfi_mem_rmask[3:0]  No     No          No          
rvfi_mem_wmask[3:0]  No     No          No          
rvfi_mem_rdata[31:0] No     No          No          
rvfi_mem_wdata[31:0] No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  0.12 --     --       0.12 --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 11.95  23.48  19.08   0.03  16.16   0.99 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME             
  0.12 --     --       0.12 --     --     ibex_top_tracing 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME   
 75.00 100.00 --      50.00 --     --     tb_top 


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME          
 13.77  30.08  19.12   0.02  18.63   0.99 u_ibex_top    
  5.50   2.61  16.67   0.19   2.55 --     u_ibex_tracer 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : data_mem_intf
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  0.93 --     --       0.93 --     --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/verif/data_mem_intf.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME             
  0.93 --     --       0.93 --     --     tb_top.data_intf 



-------------------------------------------------------------------------------
Toggle Coverage for Module : data_mem_intf
                Total Covered Percent 
Totals          11    1       9.09    
Total Bits      214   2       0.93    
Total Bits 0->1 107   1       0.93    
Total Bits 1->0 107   1       0.93    

                          
Ports          2 1 50.00  
Port Bits      4 2 50.00  
Port Bits 0->1 2 1 50.00  
Port Bits 1->0 2 1 50.00  

                              
Signals          9   0 0.00   
Signal Bits      210 0 0.00   
Signal Bits 0->1 105 0 0.00   
Signal Bits 1->0 105 0 0.00   

Port Details
      Toggle Toggle 1->0 Toggle 0->1 Direction 
clk   Yes    Yes         Yes         INPUT     
rst_n No     No          No          INPUT     

Signal Details
                   Toggle Toggle 1->0 Toggle 0->1 
data_req_o         No     No          No          
data_addr_o[31:0]  No     No          No          
data_we_o          No     No          No          
data_be_o[3:0]     No     No          No          
data_wdata_o[31:0] No     No          No          
data_gnt_i         No     No          No          
data_rvalid_i      No     No          No          
data_err_i         No     No          No          
data_rdata_i[31:0] No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.data_intf
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  0.93 --     --       0.93 --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  0.93 --     --       0.93 --     --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME          
  0.93 --     --       0.93 --     --     data_mem_intf 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME   
 75.00 100.00 --      50.00 --     --     tb_top 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : instr_mem_intf
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  1.43 --     --       1.43 --     --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/verif/instr_mem_intf.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME              
  1.43 --     --       1.43 --     --     tb_top.instr_intf 



-------------------------------------------------------------------------------
Toggle Coverage for Module : instr_mem_intf
                Total Covered Percent 
Totals          8     1       12.50   
Total Bits      140   2       1.43    
Total Bits 0->1 70    1       1.43    
Total Bits 1->0 70    1       1.43    

                          
Ports          2 1 50.00  
Port Bits      4 2 50.00  
Port Bits 0->1 2 1 50.00  
Port Bits 1->0 2 1 50.00  

                              
Signals          6   0 0.00   
Signal Bits      136 0 0.00   
Signal Bits 0->1 68  0 0.00   
Signal Bits 1->0 68  0 0.00   

Port Details
      Toggle Toggle 1->0 Toggle 0->1 Direction 
clk   Yes    Yes         Yes         INPUT     
rst_n No     No          No          INPUT     

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
instr_req_o         No     No          No          
instr_addr_o[31:0]  No     No          No          
instr_gnt_i         No     No          No          
instr_rvalid_i      No     No          No          
instr_rdata_i[31:0] No     No          No          
instr_err_i         No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.instr_intf
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  1.43 --     --       1.43 --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  1.43 --     --       1.43 --     --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
  1.43 --     --       1.43 --     --     instr_mem_intf 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME   
 75.00 100.00 --      50.00 --     --     tb_top 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_compressed_decoder
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  2.35   6.90 --       0.00   2.50   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_compressed_decoder.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                              
  2.35   6.90 --       0.00   2.50   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.if_stage_i.compressed_decoder_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_compressed_decoder

             Line No.   Total   Covered  Percent
TOTAL                       58        4     6.90
ALWAYS             38       58        4     6.90

37                          // By default, forward incoming instruction, mark it as legal.
38         1/1              instr_o         = instr_i;
39         1/1              illegal_instr_o = 1'b0;
40                      
41                          // Check if incoming instruction is compressed.
42         1/1              unique case (instr_i[1:0])
43                            // C0
44                            2'b00: begin
45         0/1     ==>          unique case (instr_i[15:13])
46                                3'b000: begin
47                                  // c.addi4spn -> addi rd', x2, imm
48         0/1     ==>              instr_o = {2'b0, instr_i[10:7], instr_i[12:11], instr_i[5],
49                                             instr_i[6], 2'b00, 5'h02, 3'b000, 2'b01, instr_i[4:2], {OPCODE_OP_IMM}};
50         0/2     ==>              if (instr_i[12:5] == 8'b0)  illegal_instr_o = 1'b1;
                   ==>  MISSING_ELSE
51                                end
52                      
53                                3'b010: begin
54                                  // c.lw -> lw rd', imm(rs1')
55         0/1     ==>              instr_o = {5'b0, instr_i[5], instr_i[12:10], instr_i[6],
56                                             2'b00, 2'b01, instr_i[9:7], 3'b010, 2'b01, instr_i[4:2], {OPCODE_LOAD}};
57                                end
58                      
59                                3'b110: begin
60                                  // c.sw -> sw rs2', imm(rs1')
61         0/1     ==>              instr_o = {5'b0, instr_i[5], instr_i[12], 2'b01, instr_i[4:2],
62                                             2'b01, instr_i[9:7], 3'b010, instr_i[11:10], instr_i[6],
63                                             2'b00, {OPCODE_STORE}};
64                                end
65                      
66                                3'b001,
67                                3'b011,
68                                3'b100,
69                                3'b101,
70                                3'b111: begin
71         0/1     ==>              illegal_instr_o = 1'b1;
72                                end
73                      
74                                default: begin
75         0/1     ==>              illegal_instr_o = 1'b1;
76                                end
77                              endcase
78                            end
79                      
80                            // C1
81                            //
82                            // Register address checks for RV32E are performed in the regular instruction decoder.
83                            // If this check fails, an illegal instruction exception is triggered and the controller
84                            // writes the actual faulting instruction to mtval.
85                            2'b01: begin
86         0/1     ==>          unique case (instr_i[15:13])
87                                3'b000: begin
88                                  // c.addi -> addi rd, rd, nzimm
89                                  // c.nop
90         0/1     ==>              instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2],
91                                             instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
92                                end
93                      
94                                3'b001, 3'b101: begin
95                                  // 001: c.jal -> jal x1, imm
96                                  // 101: c.j   -> jal x0, imm
97         0/1     ==>              instr_o = {instr_i[12], instr_i[8], instr_i[10:9], instr_i[6],
98                                             instr_i[7], instr_i[2], instr_i[11], instr_i[5:3],
99                                             {9 {instr_i[12]}}, 4'b0, ~instr_i[15], {OPCODE_JAL}};
100                               end
101                     
102                               3'b010: begin
103                                 // c.li -> addi rd, x0, nzimm
104                                 // (c.li hints are translated into an addi hint)
105        0/1     ==>              instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0,
106                                            3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
107                               end
108                     
109                               3'b011: begin
110                                 // c.lui -> lui rd, imm
111                                 // (c.lui hints are translated into a lui hint)
112        0/1     ==>              instr_o = {{15 {instr_i[12]}}, instr_i[6:2], instr_i[11:7], {OPCODE_LUI}};
113                     
114        0/1     ==>              if (instr_i[11:7] == 5'h02) begin
115                                   // c.addi16sp -> addi x2, x2, nzimm
116        0/1     ==>                instr_o = {{3 {instr_i[12]}}, instr_i[4:3], instr_i[5], instr_i[2],
117                                              instr_i[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};
118                                 end
                   ==>  MISSING_ELSE
119                     
120        0/2     ==>              if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;
                   ==>  MISSING_ELSE
121                               end
122                     
123                               3'b100: begin
124        0/1     ==>              unique case (instr_i[11:10])
125                                   2'b00,
126                                   2'b01: begin
127                                     // 00: c.srli -> srli rd, rd, shamt
128                                     // 01: c.srai -> srai rd, rd, shamt
129                                     // (c.srli/c.srai hints are translated into a srli/srai hint)
130        0/1     ==>                  instr_o = {1'b0, instr_i[10], 5'b0, instr_i[6:2], 2'b01, instr_i[9:7],
131                                                3'b101, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
132        0/2     ==>                  if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1;
                   ==>  MISSING_ELSE
133                                   end
134                     
135                                   2'b10: begin
136                                     // c.andi -> andi rd, rd, imm
137        0/1     ==>                  instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 2'b01, instr_i[9:7],
138                                                3'b111, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
139                                   end
140                     
141                                   2'b11: begin
142        0/1     ==>                  unique case ({instr_i[12], instr_i[6:5]})
143                                       3'b000: begin
144                                         // c.sub -> sub rd', rd', rs2'
145        0/1     ==>                      instr_o = {2'b01, 5'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7],
146                                                    3'b000, 2'b01, instr_i[9:7], {OPCODE_OP}};
147                                       end
148                     
149                                       3'b001: begin
150                                         // c.xor -> xor rd', rd', rs2'
151        0/1     ==>                      instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b100,
152                                                    2'b01, instr_i[9:7], {OPCODE_OP}};
153                                       end
154                     
155                                       3'b010: begin
156                                         // c.or  -> or  rd', rd', rs2'
157        0/1     ==>                      instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b110,
158                                                    2'b01, instr_i[9:7], {OPCODE_OP}};
159                                       end
160                     
161                                       3'b011: begin
162                                         // c.and -> and rd', rd', rs2'
163        0/1     ==>                      instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b111,
164                                                    2'b01, instr_i[9:7], {OPCODE_OP}};
165                                       end
166                     
167                                       3'b100,
168                                       3'b101,
169                                       3'b110,
170                                       3'b111: begin
171                                         // 100: c.subw
172                                         // 101: c.addw
173        0/1     ==>                      illegal_instr_o = 1'b1;
174                                       end
175                     
176                                       default: begin
177        0/1     ==>                      illegal_instr_o = 1'b1;
178                                       end
179                                     endcase
180                                   end
181                     
182                                   default: begin
183        0/1     ==>                  illegal_instr_o = 1'b1;
184                                   end
185                                 endcase
186                               end
187                     
188                               3'b110, 3'b111: begin
189                                 // 0: c.beqz -> beq rs1', x0, imm
190                                 // 1: c.bnez -> bne rs1', x0, imm
191        0/1     ==>              instr_o = {{4 {instr_i[12]}}, instr_i[6:5], instr_i[2], 5'b0, 2'b01,
192                                            instr_i[9:7], 2'b00, instr_i[13], instr_i[11:10], instr_i[4:3],
193                                            instr_i[12], {OPCODE_BRANCH}};
194                               end
195                     
196                               default: begin
197        0/1     ==>              illegal_instr_o = 1'b1;
198                               end
199                             endcase
200                           end
201                     
202                           // C2
203                           //
204                           // Register address checks for RV32E are performed in the regular instruction decoder.
205                           // If this check fails, an illegal instruction exception is triggered and the controller
206                           // writes the actual faulting instruction to mtval.
207                           2'b10: begin
208        0/1     ==>          unique case (instr_i[15:13])
209                               3'b000: begin
210                                 // c.slli -> slli rd, rd, shamt
211                                 // (c.ssli hints are translated into a slli hint)
212        0/1     ==>              instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], {OPCODE_OP_IMM}};
213        0/2     ==>              if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1; // reserved for custom extensions
                   ==>  MISSING_ELSE
214                               end
215                     
216                               3'b010: begin
217                                 // c.lwsp -> lw rd, imm(x2)
218        0/1     ==>              instr_o = {4'b0, instr_i[3:2], instr_i[12], instr_i[6:4], 2'b00, 5'h02,
219                                            3'b010, instr_i[11:7], OPCODE_LOAD};
220        0/2     ==>              if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
                   ==>  MISSING_ELSE
221                               end
222                     
223                               3'b100: begin
224        0/1     ==>              if (instr_i[12] == 1'b0) begin
225        0/1     ==>                if (instr_i[6:2] != 5'b0) begin
226                                     // c.mv -> add rd/rs1, x0, rs2
227                                     // (c.mv hints are translated into an add hint)
228        0/1     ==>                  instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], {OPCODE_OP}};
229                                   end else begin
230                                     // c.jr -> jalr x0, rd/rs1, 0
231        0/1     ==>                  instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, {OPCODE_JALR}};
232        0/2     ==>                  if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
                   ==>  MISSING_ELSE
233                                   end
234                                 end else begin
235        0/1     ==>                if (instr_i[6:2] != 5'b0) begin
236                                     // c.add -> add rd, rd, rs2
237                                     // (c.add hints are translated into an add hint)
238        0/1     ==>                  instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP}};
239                                   end else begin
240        0/1     ==>                  if (instr_i[11:7] == 5'b0) begin
241                                       // c.ebreak -> ebreak
242        0/1     ==>                    instr_o = {32'h00_10_00_73};
243                                     end else begin
244                                       // c.jalr -> jalr x1, rs1, 0
245        0/1     ==>                    instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};
246                                     end
247                                   end
248                                 end
249                               end
250                     
251                               3'b110: begin
252                                 // c.swsp -> sw rs2, imm(x2)
253        0/1     ==>              instr_o = {4'b0, instr_i[8:7], instr_i[12], instr_i[6:2], 5'h02, 3'b010,
254                                            instr_i[11:9], 2'b00, {OPCODE_STORE}};
255                               end
256                     
257                               3'b001,
258                               3'b011,
259                               3'b101,
260                               3'b111: begin
261        0/1     ==>              illegal_instr_o = 1'b1;
262                               end
263                     
264                               default: begin
265        0/1     ==>              illegal_instr_o = 1'b1;
266                               end
267                             endcase
268                           end
269                     
270                           // Incoming instruction is not compressed.
271        0/1     ==>        2'b11:;
272                     
273                           default: begin
274        1/1                  illegal_instr_o = 1'b1;

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_compressed_decoder
                Total Covered Percent 
Totals          8     0       0.00    
Total Bits      140   0       0.00    
Total Bits 0->1 70    0       0.00    
Total Bits 1->0 70    0       0.00    

                            
Ports          7   0 0.00   
Port Bits      138 0 0.00   
Port Bits 0->1 69  0 0.00   
Port Bits 1->0 69  0 0.00   

                            
Signals          1 0 0.00   
Signal Bits      2 0 0.00   
Signal Bits 0->1 1 0 0.00   
Signal Bits 1->0 1 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
valid_i         No     No          No          INPUT     
instr_i[31:0]   No     No          No          INPUT     
instr_o[31:0]   No     No          No          OUTPUT    
is_compressed_o No     No          No          OUTPUT    
illegal_instr_o No     No          No          OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
unused_valid No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_compressed_decoder
         Line No. Total Covered Percent 
Branches          40    1       2.50    
CASE     42       40    1       2.50    


42             unique case (instr_i[1:0])
                      -1-  
43               // C0
44               2'b00: begin
45                 unique case (instr_i[15:13])
                          -2-  
46                   3'b000: begin
47                     // c.addi4spn -> addi rd', x2, imm
48                     instr_o = {2'b0, instr_i[10:7], instr_i[12:11], instr_i[5],
49                                instr_i[6], 2'b00, 5'h02, 3'b000, 2'b01, instr_i[4:2], {OPCODE_OP_IMM}};
50                     if (instr_i[12:5] == 8'b0)  illegal_instr_o = 1'b1;
                       -3-  
                       ==>
                       MISSING_ELSE
                       ==>
51                   end
52         
53                   3'b010: begin
54                     // c.lw -> lw rd', imm(rs1')
55                     instr_o = {5'b0, instr_i[5], instr_i[12:10], instr_i[6],
                       ==>
56                                2'b00, 2'b01, instr_i[9:7], 3'b010, 2'b01, instr_i[4:2], {OPCODE_LOAD}};
57                   end
58         
59                   3'b110: begin
60                     // c.sw -> sw rs2', imm(rs1')
61                     instr_o = {5'b0, instr_i[5], instr_i[12], 2'b01, instr_i[4:2],
                       ==>
62                                2'b01, instr_i[9:7], 3'b010, instr_i[11:10], instr_i[6],
63                                2'b00, {OPCODE_STORE}};
64                   end
65         
66                   3'b001,
67                   3'b011,
68                   3'b100,
69                   3'b101,
70                   3'b111: begin
71                     illegal_instr_o = 1'b1;
                       ==>
72                   end
73         
74                   default: begin
75                     illegal_instr_o = 1'b1;
                       ==>
76                   end
77                 endcase
78               end
79         
80               // C1
81               //
82               // Register address checks for RV32E are performed in the regular instruction decoder.
83               // If this check fails, an illegal instruction exception is triggered and the controller
84               // writes the actual faulting instruction to mtval.
85               2'b01: begin
86                 unique case (instr_i[15:13])
                          -4-  
87                   3'b000: begin
88                     // c.addi -> addi rd, rd, nzimm
89                     // c.nop
90                     instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2],
                       ==>
91                                instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
92                   end
93         
94                   3'b001, 3'b101: begin
95                     // 001: c.jal -> jal x1, imm
96                     // 101: c.j   -> jal x0, imm
97                     instr_o = {instr_i[12], instr_i[8], instr_i[10:9], instr_i[6],
                       ==>
98                                instr_i[7], instr_i[2], instr_i[11], instr_i[5:3],
99                                {9 {instr_i[12]}}, 4'b0, ~instr_i[15], {OPCODE_JAL}};
100                  end
101        
102                  3'b010: begin
103                    // c.li -> addi rd, x0, nzimm
104                    // (c.li hints are translated into an addi hint)
105                    instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0,
                       ==>
106                               3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
107                  end
108        
109                  3'b011: begin
110                    // c.lui -> lui rd, imm
111                    // (c.lui hints are translated into a lui hint)
112                    instr_o = {{15 {instr_i[12]}}, instr_i[6:2], instr_i[11:7], {OPCODE_LUI}};
113        
114                    if (instr_i[11:7] == 5'h02) begin
                       -5-  
115                      // c.addi16sp -> addi x2, x2, nzimm
116                      instr_o = {{3 {instr_i[12]}}, instr_i[4:3], instr_i[5], instr_i[2],
                         ==>
117                                 instr_i[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};
118                    end
                       MISSING_ELSE
                       ==>
119        
120                    if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;
                       -6-  
                       ==>
                       MISSING_ELSE
                       ==>
121                  end
122        
123                  3'b100: begin
124                    unique case (instr_i[11:10])
                              -7-  
125                      2'b00,
126                      2'b01: begin
127                        // 00: c.srli -> srli rd, rd, shamt
128                        // 01: c.srai -> srai rd, rd, shamt
129                        // (c.srli/c.srai hints are translated into a srli/srai hint)
130                        instr_o = {1'b0, instr_i[10], 5'b0, instr_i[6:2], 2'b01, instr_i[9:7],
131                                   3'b101, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
132                        if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1;
                           -8-  
                           ==>
                           MISSING_ELSE
                           ==>
133                      end
134        
135                      2'b10: begin
136                        // c.andi -> andi rd, rd, imm
137                        instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 2'b01, instr_i[9:7],
                           ==>
138                                   3'b111, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
139                      end
140        
141                      2'b11: begin
142                        unique case ({instr_i[12], instr_i[6:5]})
                                  -9-  
143                          3'b000: begin
144                            // c.sub -> sub rd', rd', rs2'
145                            instr_o = {2'b01, 5'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7],
                               ==>
146                                       3'b000, 2'b01, instr_i[9:7], {OPCODE_OP}};
147                          end
148        
149                          3'b001: begin
150                            // c.xor -> xor rd', rd', rs2'
151                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b100,
                               ==>
152                                       2'b01, instr_i[9:7], {OPCODE_OP}};
153                          end
154        
155                          3'b010: begin
156                            // c.or  -> or  rd', rd', rs2'
157                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b110,
                               ==>
158                                       2'b01, instr_i[9:7], {OPCODE_OP}};
159                          end
160        
161                          3'b011: begin
162                            // c.and -> and rd', rd', rs2'
163                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b111,
                               ==>
164                                       2'b01, instr_i[9:7], {OPCODE_OP}};
165                          end
166        
167                          3'b100,
168                          3'b101,
169                          3'b110,
170                          3'b111: begin
171                            // 100: c.subw
172                            // 101: c.addw
173                            illegal_instr_o = 1'b1;
                               ==>
174                          end
175        
176                          default: begin
177                            illegal_instr_o = 1'b1;
                               ==>
178                          end
179                        endcase
180                      end
181        
182                      default: begin
183                        illegal_instr_o = 1'b1;
                           ==>
184                      end
185                    endcase
186                  end
187        
188                  3'b110, 3'b111: begin
189                    // 0: c.beqz -> beq rs1', x0, imm
190                    // 1: c.bnez -> bne rs1', x0, imm
191                    instr_o = {{4 {instr_i[12]}}, instr_i[6:5], instr_i[2], 5'b0, 2'b01,
                       ==>
192                               instr_i[9:7], 2'b00, instr_i[13], instr_i[11:10], instr_i[4:3],
193                               instr_i[12], {OPCODE_BRANCH}};
194                  end
195        
196                  default: begin
197                    illegal_instr_o = 1'b1;
                       ==>
198                  end
199                endcase
200              end
201        
202              // C2
203              //
204              // Register address checks for RV32E are performed in the regular instruction decoder.
205              // If this check fails, an illegal instruction exception is triggered and the controller
206              // writes the actual faulting instruction to mtval.
207              2'b10: begin
208                unique case (instr_i[15:13])
                          -10-  
209                  3'b000: begin
210                    // c.slli -> slli rd, rd, shamt
211                    // (c.ssli hints are translated into a slli hint)
212                    instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], {OPCODE_OP_IMM}};
213                    if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1; // reserved for custom extensions
                       -11-  
                       ==>
                       MISSING_ELSE
                       ==>
214                  end
215        
216                  3'b010: begin
217                    // c.lwsp -> lw rd, imm(x2)
218                    instr_o = {4'b0, instr_i[3:2], instr_i[12], instr_i[6:4], 2'b00, 5'h02,
219                               3'b010, instr_i[11:7], OPCODE_LOAD};
220                    if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
                       -12-  
                       ==>
                       MISSING_ELSE
                       ==>
221                  end
222        
223                  3'b100: begin
224                    if (instr_i[12] == 1'b0) begin
                       -13-  
225                      if (instr_i[6:2] != 5'b0) begin
                         -14-  
226                        // c.mv -> add rd/rs1, x0, rs2
227                        // (c.mv hints are translated into an add hint)
228                        instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], {OPCODE_OP}};
                           ==>
229                      end else begin
230                        // c.jr -> jalr x0, rd/rs1, 0
231                        instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, {OPCODE_JALR}};
232                        if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
                           -15-  
                           ==>
                           MISSING_ELSE
                           ==>
233                      end
234                    end else begin
235                      if (instr_i[6:2] != 5'b0) begin
                         -16-  
236                        // c.add -> add rd, rd, rs2
237                        // (c.add hints are translated into an add hint)
238                        instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP}};
                           ==>
239                      end else begin
240                        if (instr_i[11:7] == 5'b0) begin
                           -17-  
241                          // c.ebreak -> ebreak
242                          instr_o = {32'h00_10_00_73};
                             ==>
243                        end else begin
244                          // c.jalr -> jalr x1, rs1, 0
245                          instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};
                             ==>
246                        end
247                      end
248                    end
249                  end
250        
251                  3'b110: begin
252                    // c.swsp -> sw rs2, imm(x2)
253                    instr_o = {4'b0, instr_i[8:7], instr_i[12], instr_i[6:2], 5'h02, 3'b010,
                       ==>
254                               instr_i[11:9], 2'b00, {OPCODE_STORE}};
255                  end
256        
257                  3'b001,
258                  3'b011,
259                  3'b101,
260                  3'b111: begin
261                    illegal_instr_o = 1'b1;
                       ==>
262                  end
263        
264                  default: begin
265                    illegal_instr_o = 1'b1;
                       ==>
266                  end
267                endcase
268              end
269        
270              // Incoming instruction is not compressed.
271              2'b11:;
                 ==>
272        
273              default: begin
274                illegal_instr_o = 1'b1;
                   ==>

Branches:

-1-     -2-                               -3- -4-            -5- -6- -7-        -8- -9-                          -10-                       -11- -12- -13- -14- -15- -16- -17- Status      
2'b00   3'b000                            1   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b00   3'b000                            0   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b00   3'b010                            -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b00   3'b110                            -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b00   3'b1 3'b011 3'b100 3'b101 3'b111  -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b00   default                           -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b000         -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b1 3'b101    -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b010         -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b011         1   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b011         0   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b011         -   1   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b011         -   0   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b0 2'b1  1   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b0 2'b1  0   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b10      -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b11      -   3'b000                       -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b11      -   3'b001                       -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b11      -   3'b010                       -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b11      -   3'b011                       -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b11      -   3'b100 3'b101 3'b110 3'b111  -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   2'b11      -   default                      -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b100         -   -   default    -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   3'b110 3'b111  -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -                                 -   default        -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b000                     1    -    -    -    -    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b000                     0    -    -    -    -    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b010                     -    1    -    -    -    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b010                     -    0    -    -    -    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b100                     -    -    1    1    -    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b100                     -    -    1    0    1    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b100                     -    -    1    0    0    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    1    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    0    1    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    0    0    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b110                     -    -    -    -    -    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            3'b1 3'b011 3'b101 3'b111  -    -    -    -    -    -    -    Not Covered 
2'b10   -                                 -   -              -   -   -          -   -                            default                    -    -    -    -    -    -    -    Not Covered 
2'b11   -                                 -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
default -                                 -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_compressed_decoder
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       7     7         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            7     7         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                Attempts Real Successes Failures Incomplete 
IbexC0Known1        3        0              0        0          
IbexC1Known1        3        0              0        0          
IbexC1Known2        3        0              0        0          
IbexC1Known3        3        0              0        0          
IbexC2Known1        3        0              0        0          
IbexInstrLSBsKnown  3        0              0        0          
IbexInstrValidKnown 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.if_stage_i.compressed_decoder_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  2.35   6.90 --       0.00   2.50   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  2.35   6.90 --       0.00   2.50   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                    
  2.35   6.90 --       0.00   2.50   0.00 ibex_compressed_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 13.39  28.57 --       0.00  25.00   0.00 if_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : dut_probe_intf
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  2.63 --     --       2.63 --     --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/verif/dut_probe_intf.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME            
  2.63 --     --       2.63 --     --     tb_top.dut_intf 



-------------------------------------------------------------------------------
Toggle Coverage for Module : dut_probe_intf
                Total Covered Percent 
Totals          7     1       14.29   
Total Bits      76    2       2.63    
Total Bits 0->1 38    1       2.63    
Total Bits 1->0 38    1       2.63    

                          
Ports          2 1 50.00  
Port Bits      4 2 50.00  
Port Bits 0->1 2 1 50.00  
Port Bits 1->0 2 1 50.00  

                             
Signals          5  0 0.00   
Signal Bits      72 0 0.00   
Signal Bits 0->1 36 0 0.00   
Signal Bits 1->0 36 0 0.00   

Port Details
      Toggle Toggle 1->0 Toggle 0->1 Direction 
clk   Yes    Yes         Yes         INPUT     
rst_n No     No          No          INPUT     

Signal Details
                  Toggle Toggle 1->0 Toggle 0->1 
fetch_enable_i    No     No          No          
alert_minor_o     No     No          No          
alert_major_o     No     No          No          
core_sleep_o      No     No          No          
boot_addr_i[31:0] No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.dut_intf
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  2.63 --     --       2.63 --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  2.63 --     --       2.63 --     --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
  2.63 --     --       2.63 --     --     dut_probe_intf 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME   
 75.00 100.00 --      50.00 --     --     tb_top 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_tracer
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  5.50   2.61  16.67   0.19   2.55 --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_tracer.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                     
  5.50   2.61  16.67   0.19   2.55 --     tb_top.DUT.u_ibex_tracer 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_tracer

             Line No.   Total   Covered  Percent
TOTAL                      613       16     2.61
INITIAL           103        4        2    50.00
ROUTINE           115       26        0     0.00
ROUTINE           166        3        0     0.00
ROUTINE           175      240        0     0.00
ROUTINE           419        1        1   100.00
ROUTINE           423        2        0     0.00
ROUTINE           429        2        0     0.00
ROUTINE           434        2        0     0.00
ROUTINE           440        2        0     0.00
ROUTINE           446        2        0     0.00
ROUTINE           454        3        0     0.00
ROUTINE           462        3        0     0.00
ROUTINE           470        2        0     0.00
ROUTINE           476        2        0     0.00
ROUTINE           482        2        0     0.00
ROUTINE           491        4        0     0.00
ROUTINE           503        7        0     0.00
ROUTINE           519        7        0     0.00
ROUTINE           536        3        0     0.00
ROUTINE           543        3        0     0.00
ROUTINE           550        3        0     0.00
ROUTINE           557        3        0     0.00
ROUTINE           564        3        0     0.00
ROUTINE           572        3        0     0.00
ROUTINE           579        3        0     0.00
ROUTINE           587       12        0     0.00
ROUTINE           607        2        0     0.00
ROUTINE           612        3        0     0.00
ROUTINE           622        5        0     0.00
ROUTINE           635        5        0     0.00
ROUTINE           667       15        0     0.00
ROUTINE           692       10        0     0.00
ROUTINE           716       10        0     0.00
ROUTINE           735        3        0     0.00
ALWAYS            742        3        2    66.67
INITIAL           751        2        1    50.00
ALWAYS            758        2        1    50.00
ALWAYS            764      206        9     4.37

102                       initial begin
103        1/1              if ($value$plusargs("ibex_tracer_enable=%b", trace_log_enable)) begin
104        0/1     ==>        if (trace_log_enable == 1'b0) begin
105        0/1     ==>          $display("%m: Instruction trace disabled.");
106                           end
                   ==>  MISSING_ELSE
107                         end else begin
108        1/1                trace_log_enable = 1'b1;
109                         end
110                       end
111                     
112                       function automatic void printbuffer_dumpline();
113                         string rvfi_insn_str;
114                     
115        0/1     ==>      if (file_handle == 32'h0) begin
116        0/1     ==>        string file_name_base = "trace_core";
117        0/1     ==>        $value$plusargs("ibex_tracer_file_base=%s", file_name_base);
118        0/1     ==>        $sformat(file_name, "%s_%h.log", file_name_base, hart_id_i);
119                     
120        0/1     ==>        $display("%m: Writing execution trace to %s", file_name);
121        0/1     ==>        file_handle = $fopen(file_name, "w");
122        0/1     ==>        $fwrite(file_handle,
123                                   "Time\tCycle\tPC\tInsn\tDecoded instruction\tRegister and memory contents\n");
124                         end
                   ==>  MISSING_ELSE
125                     
126                         // Write compressed instructions as four hex digits (16 bit word), and
127                         // uncompressed ones as 8 hex digits (32 bit words).
128        0/1     ==>      if (insn_is_compressed) begin
129        0/1     ==>        rvfi_insn_str = $sformatf("%h", rvfi_insn[15:0]);
130                         end else begin
131        0/1     ==>        rvfi_insn_str = $sformatf("%h", rvfi_insn);
132                         end
133                     
134        0/1     ==>      $fwrite(file_handle, "%15t\t%d\t%h\t%s\t%s\t",
135                                 $time, cycle, rvfi_pc_rdata, rvfi_insn_str, decoded_str);
136                     
137        0/1     ==>      if ((data_accessed & RS1) != 0) begin
138        0/1     ==>        $fwrite(file_handle, " %s:0x%08x", reg_addr_to_str(rvfi_rs1_addr), rvfi_rs1_rdata);
139                         end
                   ==>  MISSING_ELSE
140        0/1     ==>      if ((data_accessed & RS2) != 0) begin
141        0/1     ==>        $fwrite(file_handle, " %s:0x%08x", reg_addr_to_str(rvfi_rs2_addr), rvfi_rs2_rdata);
142                         end
                   ==>  MISSING_ELSE
143        0/1     ==>      if ((data_accessed & RS3) != 0) begin
144        0/1     ==>        $fwrite(file_handle, " %s:0x%08x", reg_addr_to_str(rvfi_rs3_addr), rvfi_rs3_rdata);
145                         end
                   ==>  MISSING_ELSE
146        0/1     ==>      if ((data_accessed & RD) != 0) begin
147        0/1     ==>        $fwrite(file_handle, " %s=0x%08x", reg_addr_to_str(rvfi_rd_addr), rvfi_rd_wdata);
148                         end
                   ==>  MISSING_ELSE
149        0/1     ==>      if ((data_accessed & MEM) != 0) begin
150        0/1     ==>        $fwrite(file_handle, " PA:0x%08x", rvfi_mem_addr);
151                     
152        0/1     ==>        if (rvfi_mem_rmask != 4'b0000) begin
153        0/1     ==>          $fwrite(file_handle, " store:0x%08x", rvfi_mem_wdata);
154                           end
                   ==>  MISSING_ELSE
155        0/1     ==>        if (rvfi_mem_wmask != 4'b0000) begin
156        0/1     ==>          $fwrite(file_handle, " load:0x%08x", rvfi_mem_rdata);
157                           end
                   ==>  MISSING_ELSE
158                         end
                   ==>  MISSING_ELSE
159                     
160        0/1     ==>      $fwrite(file_handle, "\n");
161                       endfunction
162                     
163                     
164                       // Format register address with "x" prefix, left-aligned to a fixed width of 3 characters.
165                       function automatic string reg_addr_to_str(input logic [4:0] addr);
166        0/1     ==>      if (addr < 10) begin
167        0/1     ==>        return $sformatf(" x%0d", addr);
168                         end else begin
169        0/1     ==>        return $sformatf("x%0d", addr);
170                         end
171                       endfunction
172                     
173                       // Get a CSR name for a CSR address.
174                       function automatic string get_csr_name(input logic [11:0] csr_addr);
175        0/1     ==>      unique case (csr_addr)
176        0/1     ==>        12'd0: return "ustatus";
177        0/1     ==>        12'd4: return "uie";
178        0/1     ==>        12'd5: return "utvec";
179        0/1     ==>        12'd64: return "uscratch";
180        0/1     ==>        12'd65: return "uepc";
181        0/1     ==>        12'd66: return "ucause";
182        0/1     ==>        12'd67: return "utval";
183        0/1     ==>        12'd68: return "uip";
184        0/1     ==>        12'd1: return "fflags";
185        0/1     ==>        12'd2: return "frm";
186        0/1     ==>        12'd3: return "fcsr";
187        0/1     ==>        12'd3072: return "cycle";
188        0/1     ==>        12'd3073: return "time";
189        0/1     ==>        12'd3074: return "instret";
190        0/1     ==>        12'd3075: return "hpmcounter3";
191        0/1     ==>        12'd3076: return "hpmcounter4";
192        0/1     ==>        12'd3077: return "hpmcounter5";
193        0/1     ==>        12'd3078: return "hpmcounter6";
194        0/1     ==>        12'd3079: return "hpmcounter7";
195        0/1     ==>        12'd3080: return "hpmcounter8";
196        0/1     ==>        12'd3081: return "hpmcounter9";
197        0/1     ==>        12'd3082: return "hpmcounter10";
198        0/1     ==>        12'd3083: return "hpmcounter11";
199        0/1     ==>        12'd3084: return "hpmcounter12";
200        0/1     ==>        12'd3085: return "hpmcounter13";
201        0/1     ==>        12'd3086: return "hpmcounter14";
202        0/1     ==>        12'd3087: return "hpmcounter15";
203        0/1     ==>        12'd3088: return "hpmcounter16";
204        0/1     ==>        12'd3089: return "hpmcounter17";
205        0/1     ==>        12'd3090: return "hpmcounter18";
206        0/1     ==>        12'd3091: return "hpmcounter19";
207        0/1     ==>        12'd3092: return "hpmcounter20";
208        0/1     ==>        12'd3093: return "hpmcounter21";
209        0/1     ==>        12'd3094: return "hpmcounter22";
210        0/1     ==>        12'd3095: return "hpmcounter23";
211        0/1     ==>        12'd3096: return "hpmcounter24";
212        0/1     ==>        12'd3097: return "hpmcounter25";
213        0/1     ==>        12'd3098: return "hpmcounter26";
214        0/1     ==>        12'd3099: return "hpmcounter27";
215        0/1     ==>        12'd3100: return "hpmcounter28";
216        0/1     ==>        12'd3101: return "hpmcounter29";
217        0/1     ==>        12'd3102: return "hpmcounter30";
218        0/1     ==>        12'd3103: return "hpmcounter31";
219        0/1     ==>        12'd3200: return "cycleh";
220        0/1     ==>        12'd3201: return "timeh";
221        0/1     ==>        12'd3202: return "instreth";
222        0/1     ==>        12'd3203: return "hpmcounter3h";
223        0/1     ==>        12'd3204: return "hpmcounter4h";
224        0/1     ==>        12'd3205: return "hpmcounter5h";
225        0/1     ==>        12'd3206: return "hpmcounter6h";
226        0/1     ==>        12'd3207: return "hpmcounter7h";
227        0/1     ==>        12'd3208: return "hpmcounter8h";
228        0/1     ==>        12'd3209: return "hpmcounter9h";
229        0/1     ==>        12'd3210: return "hpmcounter10h";
230        0/1     ==>        12'd3211: return "hpmcounter11h";
231        0/1     ==>        12'd3212: return "hpmcounter12h";
232        0/1     ==>        12'd3213: return "hpmcounter13h";
233        0/1     ==>        12'd3214: return "hpmcounter14h";
234        0/1     ==>        12'd3215: return "hpmcounter15h";
235        0/1     ==>        12'd3216: return "hpmcounter16h";
236        0/1     ==>        12'd3217: return "hpmcounter17h";
237        0/1     ==>        12'd3218: return "hpmcounter18h";
238        0/1     ==>        12'd3219: return "hpmcounter19h";
239        0/1     ==>        12'd3220: return "hpmcounter20h";
240        0/1     ==>        12'd3221: return "hpmcounter21h";
241        0/1     ==>        12'd3222: return "hpmcounter22h";
242        0/1     ==>        12'd3223: return "hpmcounter23h";
243        0/1     ==>        12'd3224: return "hpmcounter24h";
244        0/1     ==>        12'd3225: return "hpmcounter25h";
245        0/1     ==>        12'd3226: return "hpmcounter26h";
246        0/1     ==>        12'd3227: return "hpmcounter27h";
247        0/1     ==>        12'd3228: return "hpmcounter28h";
248        0/1     ==>        12'd3229: return "hpmcounter29h";
249        0/1     ==>        12'd3230: return "hpmcounter30h";
250        0/1     ==>        12'd3231: return "hpmcounter31h";
251        0/1     ==>        12'd256: return "sstatus";
252        0/1     ==>        12'd258: return "sedeleg";
253        0/1     ==>        12'd259: return "sideleg";
254        0/1     ==>        12'd260: return "sie";
255        0/1     ==>        12'd261: return "stvec";
256        0/1     ==>        12'd262: return "scounteren";
257        0/1     ==>        12'd320: return "sscratch";
258        0/1     ==>        12'd321: return "sepc";
259        0/1     ==>        12'd322: return "scause";
260        0/1     ==>        12'd323: return "stval";
261        0/1     ==>        12'd324: return "sip";
262        0/1     ==>        12'd384: return "satp";
263        0/1     ==>        12'd3857: return "mvendorid";
264        0/1     ==>        12'd3858: return "marchid";
265        0/1     ==>        12'd3859: return "mimpid";
266        0/1     ==>        12'd3860: return "mhartid";
267        0/1     ==>        12'd768: return "mstatus";
268        0/1     ==>        12'd769: return "misa";
269        0/1     ==>        12'd770: return "medeleg";
270        0/1     ==>        12'd771: return "mideleg";
271        0/1     ==>        12'd772: return "mie";
272        0/1     ==>        12'd773: return "mtvec";
273        0/1     ==>        12'd774: return "mcounteren";
274        0/1     ==>        12'd832: return "mscratch";
275        0/1     ==>        12'd833: return "mepc";
276        0/1     ==>        12'd834: return "mcause";
277        0/1     ==>        12'd835: return "mtval";
278        0/1     ==>        12'd836: return "mip";
279        0/1     ==>        12'd928: return "pmpcfg0";
280        0/1     ==>        12'd929: return "pmpcfg1";
281        0/1     ==>        12'd930: return "pmpcfg2";
282        0/1     ==>        12'd931: return "pmpcfg3";
283        0/1     ==>        12'd944: return "pmpaddr0";
284        0/1     ==>        12'd945: return "pmpaddr1";
285        0/1     ==>        12'd946: return "pmpaddr2";
286        0/1     ==>        12'd947: return "pmpaddr3";
287        0/1     ==>        12'd948: return "pmpaddr4";
288        0/1     ==>        12'd949: return "pmpaddr5";
289        0/1     ==>        12'd950: return "pmpaddr6";
290        0/1     ==>        12'd951: return "pmpaddr7";
291        0/1     ==>        12'd952: return "pmpaddr8";
292        0/1     ==>        12'd953: return "pmpaddr9";
293        0/1     ==>        12'd954: return "pmpaddr10";
294        0/1     ==>        12'd955: return "pmpaddr11";
295        0/1     ==>        12'd956: return "pmpaddr12";
296        0/1     ==>        12'd957: return "pmpaddr13";
297        0/1     ==>        12'd958: return "pmpaddr14";
298        0/1     ==>        12'd959: return "pmpaddr15";
299        0/1     ==>        12'd2816: return "mcycle";
300        0/1     ==>        12'd2818: return "minstret";
301        0/1     ==>        12'd2819: return "mhpmcounter3";
302        0/1     ==>        12'd2820: return "mhpmcounter4";
303        0/1     ==>        12'd2821: return "mhpmcounter5";
304        0/1     ==>        12'd2822: return "mhpmcounter6";
305        0/1     ==>        12'd2823: return "mhpmcounter7";
306        0/1     ==>        12'd2824: return "mhpmcounter8";
307        0/1     ==>        12'd2825: return "mhpmcounter9";
308        0/1     ==>        12'd2826: return "mhpmcounter10";
309        0/1     ==>        12'd2827: return "mhpmcounter11";
310        0/1     ==>        12'd2828: return "mhpmcounter12";
311        0/1     ==>        12'd2829: return "mhpmcounter13";
312        0/1     ==>        12'd2830: return "mhpmcounter14";
313        0/1     ==>        12'd2831: return "mhpmcounter15";
314        0/1     ==>        12'd2832: return "mhpmcounter16";
315        0/1     ==>        12'd2833: return "mhpmcounter17";
316        0/1     ==>        12'd2834: return "mhpmcounter18";
317        0/1     ==>        12'd2835: return "mhpmcounter19";
318        0/1     ==>        12'd2836: return "mhpmcounter20";
319        0/1     ==>        12'd2837: return "mhpmcounter21";
320        0/1     ==>        12'd2838: return "mhpmcounter22";
321        0/1     ==>        12'd2839: return "mhpmcounter23";
322        0/1     ==>        12'd2840: return "mhpmcounter24";
323        0/1     ==>        12'd2841: return "mhpmcounter25";
324        0/1     ==>        12'd2842: return "mhpmcounter26";
325        0/1     ==>        12'd2843: return "mhpmcounter27";
326        0/1     ==>        12'd2844: return "mhpmcounter28";
327        0/1     ==>        12'd2845: return "mhpmcounter29";
328        0/1     ==>        12'd2846: return "mhpmcounter30";
329        0/1     ==>        12'd2847: return "mhpmcounter31";
330        0/1     ==>        12'd2944: return "mcycleh";
331        0/1     ==>        12'd2946: return "minstreth";
332        0/1     ==>        12'd2947: return "mhpmcounter3h";
333        0/1     ==>        12'd2948: return "mhpmcounter4h";
334        0/1     ==>        12'd2949: return "mhpmcounter5h";
335        0/1     ==>        12'd2950: return "mhpmcounter6h";
336        0/1     ==>        12'd2951: return "mhpmcounter7h";
337        0/1     ==>        12'd2952: return "mhpmcounter8h";
338        0/1     ==>        12'd2953: return "mhpmcounter9h";
339        0/1     ==>        12'd2954: return "mhpmcounter10h";
340        0/1     ==>        12'd2955: return "mhpmcounter11h";
341        0/1     ==>        12'd2956: return "mhpmcounter12h";
342        0/1     ==>        12'd2957: return "mhpmcounter13h";
343        0/1     ==>        12'd2958: return "mhpmcounter14h";
344        0/1     ==>        12'd2959: return "mhpmcounter15h";
345        0/1     ==>        12'd2960: return "mhpmcounter16h";
346        0/1     ==>        12'd2961: return "mhpmcounter17h";
347        0/1     ==>        12'd2962: return "mhpmcounter18h";
348        0/1     ==>        12'd2963: return "mhpmcounter19h";
349        0/1     ==>        12'd2964: return "mhpmcounter20h";
350        0/1     ==>        12'd2965: return "mhpmcounter21h";
351        0/1     ==>        12'd2966: return "mhpmcounter22h";
352        0/1     ==>        12'd2967: return "mhpmcounter23h";
353        0/1     ==>        12'd2968: return "mhpmcounter24h";
354        0/1     ==>        12'd2969: return "mhpmcounter25h";
355        0/1     ==>        12'd2970: return "mhpmcounter26h";
356        0/1     ==>        12'd2971: return "mhpmcounter27h";
357        0/1     ==>        12'd2972: return "mhpmcounter28h";
358        0/1     ==>        12'd2973: return "mhpmcounter29h";
359        0/1     ==>        12'd2974: return "mhpmcounter30h";
360        0/1     ==>        12'd2975: return "mhpmcounter31h";
361        0/1     ==>        12'd803: return "mhpmevent3";
362        0/1     ==>        12'd804: return "mhpmevent4";
363        0/1     ==>        12'd805: return "mhpmevent5";
364        0/1     ==>        12'd806: return "mhpmevent6";
365        0/1     ==>        12'd807: return "mhpmevent7";
366        0/1     ==>        12'd808: return "mhpmevent8";
367        0/1     ==>        12'd809: return "mhpmevent9";
368        0/1     ==>        12'd810: return "mhpmevent10";
369        0/1     ==>        12'd811: return "mhpmevent11";
370        0/1     ==>        12'd812: return "mhpmevent12";
371        0/1     ==>        12'd813: return "mhpmevent13";
372        0/1     ==>        12'd814: return "mhpmevent14";
373        0/1     ==>        12'd815: return "mhpmevent15";
374        0/1     ==>        12'd816: return "mhpmevent16";
375        0/1     ==>        12'd817: return "mhpmevent17";
376        0/1     ==>        12'd818: return "mhpmevent18";
377        0/1     ==>        12'd819: return "mhpmevent19";
378        0/1     ==>        12'd820: return "mhpmevent20";
379        0/1     ==>        12'd821: return "mhpmevent21";
380        0/1     ==>        12'd822: return "mhpmevent22";
381        0/1     ==>        12'd823: return "mhpmevent23";
382        0/1     ==>        12'd824: return "mhpmevent24";
383        0/1     ==>        12'd825: return "mhpmevent25";
384        0/1     ==>        12'd826: return "mhpmevent26";
385        0/1     ==>        12'd827: return "mhpmevent27";
386        0/1     ==>        12'd828: return "mhpmevent28";
387        0/1     ==>        12'd829: return "mhpmevent29";
388        0/1     ==>        12'd830: return "mhpmevent30";
389        0/1     ==>        12'd831: return "mhpmevent31";
390        0/1     ==>        12'd1952: return "tselect";
391        0/1     ==>        12'd1953: return "tdata1";
392        0/1     ==>        12'd1954: return "tdata2";
393        0/1     ==>        12'd1955: return "tdata3";
394        0/1     ==>        12'd1968: return "dcsr";
395        0/1     ==>        12'd1969: return "dpc";
396        0/1     ==>        12'd1970: return "dscratch";
397        0/1     ==>        12'd512: return "hstatus";
398        0/1     ==>        12'd514: return "hedeleg";
399        0/1     ==>        12'd515: return "hideleg";
400        0/1     ==>        12'd516: return "hie";
401        0/1     ==>        12'd517: return "htvec";
402        0/1     ==>        12'd576: return "hscratch";
403        0/1     ==>        12'd577: return "hepc";
404        0/1     ==>        12'd578: return "hcause";
405        0/1     ==>        12'd579: return "hbadaddr";
406        0/1     ==>        12'd580: return "hip";
407        0/1     ==>        12'd896: return "mbase";
408        0/1     ==>        12'd897: return "mbound";
409        0/1     ==>        12'd898: return "mibase";
410        0/1     ==>        12'd899: return "mibound";
411        0/1     ==>        12'd900: return "mdbase";
412        0/1     ==>        12'd901: return "mdbound";
413        0/1     ==>        12'd800: return "mcountinhibit";
414        0/1     ==>        default: return $sformatf("0x%x", csr_addr);
415                         endcase
416                       endfunction
417                     
418                       function automatic void decode_mnemonic(input string mnemonic);
419        1/1              decoded_str = mnemonic;
420                       endfunction
421                     
422                       function automatic void decode_r_insn(input string mnemonic);
423        0/1     ==>      data_accessed = RS1 | RS2 | RD;
424        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,
425                             rvfi_rs2_addr);
426                       endfunction
427                     
428                       function automatic void decode_r1_insn(input string mnemonic);
429        0/1     ==>      data_accessed = RS1 | RD;
430        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs1_addr);
431                       endfunction
432                     
433                       function automatic void decode_r_cmixcmov_insn(input string mnemonic);
434        0/1     ==>      data_accessed = RS1 | RS2 | RS3 | RD;
435        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d,x%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs2_addr,
436                             rvfi_rs1_addr, rvfi_rs3_addr);
437                       endfunction
438                     
439                       function automatic void decode_r_funnelshift_insn(input string mnemonic);
440        0/1     ==>      data_accessed = RS1 | RS2 | RS3 | RD;
441        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d,x%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,
442                             rvfi_rs3_addr, rvfi_rs2_addr);
443                       endfunction
444                     
445                       function automatic void decode_i_insn(input string mnemonic);
446        0/1     ==>      data_accessed = RS1 | RD;
447        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d,%0d", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,
448                                         $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}));
449                       endfunction
450                     
451                       function automatic void decode_i_shift_insn(input string mnemonic);
452                         // SLLI, SRLI, SRAI, SROI, SLOI, RORI
453                         logic [4:0] shamt;
454        0/1     ==>      shamt = {rvfi_insn[24:20]};
455        0/1     ==>      data_accessed = RS1 | RD;
456        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d,0x%0x", mnemonic, rvfi_rd_addr, rvfi_rs1_addr, shamt);
457                       endfunction
458                     
459                       function automatic void decode_i_funnelshift_insn( input string mnemonic);
460                         // fsri
461                         logic [5:0] shamt;
462        0/1     ==>      shamt = {rvfi_insn[25:20]};
463        0/1     ==>      data_accessed = RS1 | RS3 | RD;
464        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d,x%0d,0x%0x", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,
465                             rvfi_rs3_addr, shamt);
466                       endfunction
467                     
468                       function automatic void decode_i_jalr_insn(input string mnemonic);
469                         // JALR
470        0/1     ==>      data_accessed = RS1 | RD;
471        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rd_addr,
472                             $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}), rvfi_rs1_addr);
473                       endfunction
474                     
475                       function automatic void decode_u_insn(input string mnemonic);
476        0/1     ==>      data_accessed = RD;
477        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rd_addr, {rvfi_insn[31:12]});
478                       endfunction
479                     
480                       function automatic void decode_j_insn(input string mnemonic);
481                         // JAL
482        0/1     ==>      data_accessed = RD;
483        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,%0x", mnemonic, rvfi_rd_addr, rvfi_pc_wdata);
484                       endfunction
485                     
486                       function automatic void decode_b_insn(input string mnemonic);
487                         logic [31:0] branch_target;
488                         logic [31:0] imm;
489                     
490                         // We cannot use rvfi_pc_wdata for conditional jumps.
491        0/1     ==>      imm = $signed({ {19 {rvfi_insn[31]}}, rvfi_insn[31], rvfi_insn[7],
492                                  rvfi_insn[30:25], rvfi_insn[11:8], 1'b0 });
493        0/1     ==>      branch_target = rvfi_pc_rdata + imm;
494                     
495        0/1     ==>      data_accessed = RS1 | RS2 | RD;
496        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d,%0x",
497                                                 mnemonic, rvfi_rs1_addr, rvfi_rs2_addr, branch_target);
498                       endfunction
499                     
500                       function automatic void decode_csr_insn(input string mnemonic);
501                         logic [11:0] csr;
502                         string csr_name;
503        0/1     ==>      csr = rvfi_insn[31:20];
504        0/1     ==>      csr_name = get_csr_name(csr);
505                     
506        0/1     ==>      data_accessed = RD;
507                     
508        0/1     ==>      if (!rvfi_insn[14]) begin
509        0/1     ==>        data_accessed |= RS1;
510        0/1     ==>        decoded_str = $sformatf("%s\tx%0d,%s,x%0d",
511                                                   mnemonic, rvfi_rd_addr, csr_name, rvfi_rs1_addr);
512                         end else begin
513        0/1     ==>        decoded_str = $sformatf("%s\tx%0d,%s,%0d",
514                                                   mnemonic, rvfi_rd_addr, csr_name, {27'b0, rvfi_insn[19:15]});
515                         end
516                       endfunction
517                     
518                       function automatic void decode_cr_insn(input string mnemonic);
519        0/1     ==>      if (rvfi_rs2_addr == 5'b0) begin
520        0/1     ==>        if (rvfi_insn[12] == 1'b1) begin
521                             // C.JALR
522        0/1     ==>          data_accessed = RS1 | RD;
523                           end else begin
524                             // C.JR
525        0/1     ==>          data_accessed = RS1;
526                           end
527        0/1     ==>        decoded_str = $sformatf("%s\tx%0d", mnemonic, rvfi_rs1_addr);
528                         end else begin
529        0/1     ==>        data_accessed = RS1 | RS2 | RD; // RS1 == RD
530        0/1     ==>        decoded_str = $sformatf("%s\tx%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs2_addr);
531                         end
532                       endfunction
533                     
534                       function automatic void decode_ci_cli_insn(input string mnemonic);
535                         logic [5:0] imm;
536        0/1     ==>      imm = {rvfi_insn[12], rvfi_insn[6:2]};
537        0/1     ==>      data_accessed = RD;
538        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,%0d", mnemonic, rvfi_rd_addr, $signed(imm));
539                       endfunction
540                     
541                       function automatic void decode_ci_caddi_insn(input string mnemonic);
542                         logic [5:0] nzimm;
543        0/1     ==>      nzimm = {rvfi_insn[12], rvfi_insn[6:2]};
544        0/1     ==>      data_accessed = RS1 | RD;
545        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,%0d", mnemonic, rvfi_rd_addr, $signed(nzimm));
546                       endfunction
547                     
548                       function automatic void decode_ci_caddi16sp_insn(input string mnemonic);
549                         logic [9:0] nzimm;
550        0/1     ==>      nzimm = {rvfi_insn[12], rvfi_insn[4:3], rvfi_insn[5], rvfi_insn[2], rvfi_insn[6], 4'b0};
551        0/1     ==>      data_accessed = RS1 | RD;
552        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,%0d", mnemonic, rvfi_rd_addr, $signed(nzimm));
553                       endfunction
554                     
555                       function automatic void decode_ci_clui_insn(input string mnemonic);
556                         logic [5:0] nzimm;
557        0/1     ==>      nzimm = {rvfi_insn[12], rvfi_insn[6:2]};
558        0/1     ==>      data_accessed = RD;
559        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rd_addr, 20'($signed(nzimm)));
560                       endfunction
561                     
562                       function automatic void decode_ci_cslli_insn(input string mnemonic);
563                         logic [5:0] shamt;
564        0/1     ==>      shamt = {rvfi_insn[12], rvfi_insn[6:2]};
565        0/1     ==>      data_accessed = RS1 | RD;
566        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rd_addr, shamt);
567                       endfunction
568                     
569                       function automatic void decode_ciw_insn(input string mnemonic);
570                         // C.ADDI4SPN
571                         logic [9:0] nzuimm;
572        0/1     ==>      nzuimm = {rvfi_insn[10:7], rvfi_insn[12:11], rvfi_insn[5], rvfi_insn[6], 2'b00};
573        0/1     ==>      data_accessed = RD;
574        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x2,%0d", mnemonic, rvfi_rd_addr, nzuimm);
575                       endfunction
576                     
577                       function automatic void decode_cb_sr_insn(input string mnemonic);
578                         logic [5:0] shamt;
579        0/1     ==>      shamt = {rvfi_insn[12], rvfi_insn[6:2]};
580        0/1     ==>      data_accessed = RS1 | RD;
581        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rs1_addr, shamt);
582                       endfunction
583                     
584                       function automatic void decode_cb_insn(input string mnemonic);
585                         logic [7:0] imm;
586                         logic [31:0] jump_target;
587        0/1     ==>      if (rvfi_insn[15:13] == 3'b110 || rvfi_insn[15:13] == 3'b111) begin
588                           // C.BNEZ and C.BEQZ
589                           // We cannot use rvfi_pc_wdata for conditional jumps.
590        0/1     ==>        imm = {rvfi_insn[12], rvfi_insn[6:5], rvfi_insn[2], rvfi_insn[11:10], rvfi_insn[4:3]};
591        0/1     ==>        jump_target = rvfi_pc_rdata + 32'($signed({imm, 1'b0}));
592        0/1     ==>        data_accessed = RS1;
593        0/1     ==>        decoded_str = $sformatf("%s\tx%0d,%0x", mnemonic, rvfi_rs1_addr, jump_target);
594        0/1     ==>      end else if (rvfi_insn[15:13] == 3'b100) begin
595                           // C.ANDI
596        0/1     ==>        imm = {{2{rvfi_insn[12]}}, rvfi_insn[12], rvfi_insn[6:2]};
597        0/1     ==>        data_accessed = RS1 | RD; // RS1 == RD
598        0/1     ==>        decoded_str = $sformatf("%s\tx%0d,%0d", mnemonic, rvfi_rd_addr, $signed(imm));
599                         end else begin
600        0/1     ==>        imm = {rvfi_insn[12], rvfi_insn[6:2], 2'b00};
601        0/1     ==>        data_accessed = RS1;
602        0/1     ==>        decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rs1_addr, imm);
603                         end
604                       endfunction
605                     
606                       function automatic void decode_cs_insn(input string mnemonic);
607        0/1     ==>      data_accessed = RS1 | RS2 | RD; // RS1 == RD
608        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs2_addr);
609                       endfunction
610                     
611                       function automatic void decode_cj_insn(input string mnemonic);
612        0/1     ==>      if (rvfi_insn[15:13] == 3'b001) begin
613                           // C.JAL
614        0/1     ==>        data_accessed = RD;
615                         end
                   ==>  MISSING_ELSE
616        0/1     ==>      decoded_str = $sformatf("%s\t%0x", mnemonic, rvfi_pc_wdata);
617                       endfunction
618                     
619                       function automatic void decode_compressed_load_insn(input string mnemonic);
620                         logic [7:0] imm;
621                     
622        0/1     ==>      if (rvfi_insn[1:0] == OPCODE_C0) begin
623                           // C.LW
624        0/1     ==>        imm = {1'b0, rvfi_insn[5], rvfi_insn[12:10], rvfi_insn[6], 2'b00};
625                         end else begin
626                           // C.LWSP
627        0/1     ==>        imm = {rvfi_insn[3:2], rvfi_insn[12], rvfi_insn[6:4], 2'b00};
628                         end
629        0/1     ==>      data_accessed = RS1 | RD | MEM;
630        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rd_addr, imm, rvfi_rs1_addr);
631                       endfunction
632                     
633                       function automatic void decode_compressed_store_insn(input string mnemonic);
634                         logic [7:0] imm;
635        0/1     ==>      if (rvfi_insn[1:0] == OPCODE_C0) begin
636                           // C.SW
637        0/1     ==>        imm = {1'b0, rvfi_insn[5], rvfi_insn[12:10], rvfi_insn[6], 2'b00};
638                         end else begin
639                           // C.SWSP
640        0/1     ==>        imm = {rvfi_insn[8:7], rvfi_insn[12:9], 2'b00};
641                         end
642        0/1     ==>      data_accessed = RS1 | RS2 | MEM;
643        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rs2_addr, imm, rvfi_rs1_addr);
644                       endfunction
645                     
646                       function automatic void decode_load_insn();
647                         string      mnemonic;
648                     
649                         /*
650                         Gives wrong results in Verilator < 4.020.
651                         See https://github.com/lowRISC/ibex/issues/372 and
652                         https://www.veripool.org/issues/1536-Verilator-Misoptimization-in-if-and-case-with-default-statement-inside-a-function
653                     
654                         unique case (rvfi_insn[14:12])
655                           3'b000: mnemonic = "lb";
656                           3'b001: mnemonic = "lh";
657                           3'b010: mnemonic = "lw";
658                           3'b100: mnemonic = "lbu";
659                           3'b101: mnemonic = "lhu";
660                           default: begin
661                             decode_mnemonic("INVALID");
662                             return;
663                           end
664                         endcase
665                         */
666                         logic [2:0] size;
667        0/1     ==>      size = rvfi_insn[14:12];
668        0/1     ==>      if (size == 3'b000) begin
669        0/1     ==>        mnemonic = "lb";
670        0/1     ==>      end else if (size == 3'b001) begin
671        0/1     ==>        mnemonic = "lh";
672        0/1     ==>      end else if (size == 3'b010) begin
673        0/1     ==>        mnemonic = "lw";
674        0/1     ==>      end else if (size == 3'b100) begin
675        0/1     ==>        mnemonic = "lbu";
676        0/1     ==>      end else if (size == 3'b101) begin
677        0/1     ==>        mnemonic = "lhu";
678                         end else begin
679        0/1     ==>        decode_mnemonic("INVALID");
680        0/1     ==>        return;
681                         end
682                     
683                     
684        0/1     ==>      data_accessed = RD | RS1 | MEM;
685        0/1     ==>      decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rd_addr,
686                                         $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}), rvfi_rs1_addr);
687                       endfunction
688                     
689                       function automatic void decode_store_insn();
690                         string    mnemonic;
691                     
692        0/1     ==>      unique case (rvfi_insn[13:12])
693        0/1     ==>        2'b00:  mnemonic = "sb";
694        0/1     ==>        2'b01:  mnemonic = "sh";
695        0/1     ==>        2'b10:  mnemonic = "sw";
696                           default: begin
697        0/1     ==>          decode_mnemonic("INVALID");
698        0/1     ==>          return;
699                           end
700                         endcase
701                     
702        0/1     ==>      if (!rvfi_insn[14]) begin
703                           // regular store
704        0/1     ==>        data_accessed = RS1 | RS2 | MEM;
705        0/1     ==>        decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)",
706                                                   mnemonic,
707                                                   rvfi_rs2_addr,
708                                                   $signed({{20{rvfi_insn[31]}}, rvfi_insn[31:25], rvfi_insn[11:7]}),
709                                                   rvfi_rs1_addr);
710                         end else begin
711        0/1     ==>        decode_mnemonic("INVALID");
712                         end
713                       endfunction
714                     
715                       function automatic string get_fence_description(logic [3:0] bits);
716        0/1     ==>      string desc = "";
717        0/1     ==>      if (bits[3]) begin
718        0/1     ==>        desc = {desc, "i"};
719                         end
                   ==>  MISSING_ELSE
720        0/1     ==>      if (bits[2]) begin
721        0/1     ==>        desc = {desc, "o"};
722                         end
                   ==>  MISSING_ELSE
723        0/1     ==>      if (bits[1]) begin
724        0/1     ==>        desc = {desc, "r"};
725                         end
                   ==>  MISSING_ELSE
726        0/1     ==>      if (bits[0]) begin
727        0/1     ==>        desc = {desc, "w"};
728                         end
                   ==>  MISSING_ELSE
729        0/1     ==>      return desc;
730                       endfunction
731                     
732                       function automatic void decode_fence();
733                         string predecessor;
734                         string successor;
735        0/1     ==>      predecessor = get_fence_description(rvfi_insn[27:24]);
736        0/1     ==>      successor = get_fence_description(rvfi_insn[23:20]);
737        0/1     ==>      decoded_str = $sformatf("fence\t%s,%s", predecessor, successor);
738                       endfunction
739                     
740                       // cycle counter
741                       always_ff @(posedge clk_i or negedge rst_ni) begin
742        1/1              if (!rst_ni) begin
743        1/1                cycle <= 0;
744                         end else begin
745        0/1     ==>        cycle <= cycle + 1;
746                         end
747                       end
748                     
749                       // close output file for writing
750                       final begin
751        1/1              if (file_handle != 32'h0) begin
752        0/1     ==>        $fclose(file_handle);
753                         end
                        MISSING_ELSE
754                       end
755                     
756                       // log execution
757                       always_ff @(posedge clk_i) begin
758        1/1              if (rvfi_valid && trace_log_enable) begin
759        0/1     ==>        printbuffer_dumpline();
760                         end
                        MISSING_ELSE
761                       end
762                     
763                       always_comb begin
764        1/1              decoded_str = "";
765        1/1              data_accessed = 5'h0;
766        1/1              insn_is_compressed = 0;
767                     
768                         // Check for compressed instructions
769        1/1              if (rvfi_insn[1:0] != 2'b11) begin
770        1/1                insn_is_compressed = 1;
771                           // Separate case to avoid overlapping decoding
772        1/1                if (rvfi_insn[15:13] == INSN_CMV[15:13] && rvfi_insn[1:0] == OPCODE_C2) begin
773        0/1     ==>          if (rvfi_insn[12] == INSN_CADD[12]) begin
774        0/1     ==>            if (rvfi_insn[11:2] == INSN_CEBREAK[11:2]) begin
775        0/1     ==>              decode_mnemonic("c.ebreak");
776        0/1     ==>            end else if (rvfi_insn[6:2] == INSN_CJALR[6:2]) begin
777        0/1     ==>              decode_cr_insn("c.jalr");
778                               end else begin
779        0/1     ==>              decode_cr_insn("c.add");
780                               end
781                             end else begin
782        0/1     ==>            if (rvfi_insn[6:2] == INSN_CJR[6:2]) begin
783        0/1     ==>              decode_cr_insn("c.jr");
784                               end else begin
785        0/1     ==>              decode_cr_insn("c.mv");
786                               end
787                             end
788                           end else begin
789        1/1                  unique casez (rvfi_insn[15:0])
790                               // C0 Opcodes
791                               INSN_CADDI4SPN: begin
792        1/1                      if (rvfi_insn[12:2] == 11'h0) begin
793                                   // Align with pseudo-mnemonic used by GNU binutils and LLVM's MC layer
794        1/1                        decode_mnemonic("c.unimp");
795                                 end else begin
796        0/1     ==>                decode_ciw_insn("c.addi4spn");
797                                 end
798                               end
799        0/1     ==>            INSN_CLW:        decode_compressed_load_insn("c.lw");
800        0/1     ==>            INSN_CSW:        decode_compressed_store_insn("c.sw");
801                               // C1 Opcodes
802        0/1     ==>            INSN_CADDI:      decode_ci_caddi_insn("c.addi");
803        0/1     ==>            INSN_CJAL:       decode_cj_insn("c.jal");
804        0/1     ==>            INSN_CJ:         decode_cj_insn("c.j");
805        0/1     ==>            INSN_CLI:        decode_ci_cli_insn("c.li");
806                               INSN_CLUI: begin
807                                 // These two instructions share opcode
808        0/1     ==>              if (rvfi_insn[11:7] == 5'd2) begin
809        0/1     ==>                decode_ci_caddi16sp_insn("c.addi16sp");
810                                 end else begin
811        0/1     ==>                decode_ci_clui_insn("c.lui");
812                                 end
813                               end
814        0/1     ==>            INSN_CSRLI:      decode_cb_sr_insn("c.srli");
815        0/1     ==>            INSN_CSRAI:      decode_cb_sr_insn("c.srai");
816        0/1     ==>            INSN_CANDI:      decode_cb_insn("c.andi");
817        0/1     ==>            INSN_CSUB:       decode_cs_insn("c.sub");
818        0/1     ==>            INSN_CXOR:       decode_cs_insn("c.xor");
819        0/1     ==>            INSN_COR:        decode_cs_insn("c.or");
820        0/1     ==>            INSN_CAND:       decode_cs_insn("c.and");
821        0/1     ==>            INSN_CBEQZ:      decode_cb_insn("c.beqz");
822        0/1     ==>            INSN_CBNEZ:      decode_cb_insn("c.bnez");
823                               // C2 Opcodes
824        0/1     ==>            INSN_CSLLI:      decode_ci_cslli_insn("c.slli");
825        0/1     ==>            INSN_CLWSP:      decode_compressed_load_insn("c.lwsp");
826        0/1     ==>            INSN_SWSP:       decode_compressed_store_insn("c.swsp");
827        0/1     ==>            default:         decode_mnemonic("INVALID");
828                             endcase
829                           end
830                         end else begin
831        0/1     ==>        unique casez (rvfi_insn)
832                             // Regular opcodes
833        0/1     ==>          INSN_LUI:        decode_u_insn("lui");
834        0/1     ==>          INSN_AUIPC:      decode_u_insn("auipc");
835        0/1     ==>          INSN_JAL:        decode_j_insn("jal");
836        0/1     ==>          INSN_JALR:       decode_i_jalr_insn("jalr");
837                             // BRANCH
838        0/1     ==>          INSN_BEQ:        decode_b_insn("beq");
839        0/1     ==>          INSN_BNE:        decode_b_insn("bne");
840        0/1     ==>          INSN_BLT:        decode_b_insn("blt");
841        0/1     ==>          INSN_BGE:        decode_b_insn("bge");
842        0/1     ==>          INSN_BLTU:       decode_b_insn("bltu");
843        0/1     ==>          INSN_BGEU:       decode_b_insn("bgeu");
844                             // OPIMM
845                             INSN_ADDI: begin
846        0/1     ==>            if (rvfi_insn == 32'h00_00_00_13) begin
847                                 // TODO: objdump doesn't decode this as nop currently, even though it would be helpful
848                                 // Decide what to do here: diverge from objdump, or make the trace less readable to
849                                 // users.
850                                 //decode_mnemonic("nop");
851        0/1     ==>              decode_i_insn("addi");
852                               end else begin
853        0/1     ==>              decode_i_insn("addi");
854                               end
855                             end
856        0/1     ==>          INSN_SLTI:       decode_i_insn("slti");
857        0/1     ==>          INSN_SLTIU:      decode_i_insn("sltiu");
858        0/1     ==>          INSN_XORI:       decode_i_insn("xori");
859        0/1     ==>          INSN_ORI:        decode_i_insn("ori");
860                             // Version 0.92 of the Bitmanip Extension defines the pseudo-instruction
861                             // zext.b rd rs = andi rd, rs, 255.
862                             // Currently instruction set simulators don't output this pseudo-instruction.
863        0/1     ==>          INSN_ANDI:       decode_i_insn("andi");
864                             // INSN_ANDI:begin
865                               // casez (rvfi_insn)
866                                 // INSN_ZEXTB:  decode_r1_insn("zext.b");
867                                 // default:     decode_i_insn("andi");
868                               // endcase
869                             // end
870        0/1     ==>          INSN_SLLI:       decode_i_shift_insn("slli");
871        0/1     ==>          INSN_SRLI:       decode_i_shift_insn("srli");
872        0/1     ==>          INSN_SRAI:       decode_i_shift_insn("srai");
873                             // OP
874        0/1     ==>          INSN_ADD:        decode_r_insn("add");
875        0/1     ==>          INSN_SUB:        decode_r_insn("sub");
876        0/1     ==>          INSN_SLL:        decode_r_insn("sll");
877        0/1     ==>          INSN_SLT:        decode_r_insn("slt");
878        0/1     ==>          INSN_SLTU:       decode_r_insn("sltu");
879        0/1     ==>          INSN_XOR:        decode_r_insn("xor");
880        0/1     ==>          INSN_SRL:        decode_r_insn("srl");
881        0/1     ==>          INSN_SRA:        decode_r_insn("sra");
882        0/1     ==>          INSN_OR:         decode_r_insn("or");
883        0/1     ==>          INSN_AND:        decode_r_insn("and");
884                             // SYSTEM (CSR manipulation)
885        0/1     ==>          INSN_CSRRW:      decode_csr_insn("csrrw");
886        0/1     ==>          INSN_CSRRS:      decode_csr_insn("csrrs");
887        0/1     ==>          INSN_CSRRC:      decode_csr_insn("csrrc");
888        0/1     ==>          INSN_CSRRWI:     decode_csr_insn("csrrwi");
889        0/1     ==>          INSN_CSRRSI:     decode_csr_insn("csrrsi");
890        0/1     ==>          INSN_CSRRCI:     decode_csr_insn("csrrci");
891                             // SYSTEM (others)
892        0/1     ==>          INSN_ECALL:      decode_mnemonic("ecall");
893        0/1     ==>          INSN_EBREAK:     decode_mnemonic("ebreak");
894        0/1     ==>          INSN_MRET:       decode_mnemonic("mret");
895        0/1     ==>          INSN_DRET:       decode_mnemonic("dret");
896        0/1     ==>          INSN_WFI:        decode_mnemonic("wfi");
897                             // RV32M
898        0/1     ==>          INSN_PMUL:       decode_r_insn("mul");
899        0/1     ==>          INSN_PMUH:       decode_r_insn("mulh");
900        0/1     ==>          INSN_PMULHSU:    decode_r_insn("mulhsu");
901        0/1     ==>          INSN_PMULHU:     decode_r_insn("mulhu");
902        0/1     ==>          INSN_DIV:        decode_r_insn("div");
903        0/1     ==>          INSN_DIVU:       decode_r_insn("divu");
904        0/1     ==>          INSN_REM:        decode_r_insn("rem");
905        0/1     ==>          INSN_REMU:       decode_r_insn("remu");
906                             // LOAD & STORE
907        0/1     ==>          INSN_LOAD:       decode_load_insn();
908        0/1     ==>          INSN_STORE:      decode_store_insn();
909                             // MISC-MEM
910        0/1     ==>          INSN_FENCE:      decode_fence();
911        0/1     ==>          INSN_FENCEI:     decode_mnemonic("fence.i");
912                             // RV32B - ZBB
913        0/1     ==>          INSN_SLOI:       decode_i_shift_insn("sloi");
914        0/1     ==>          INSN_SROI:       decode_i_shift_insn("sroi");
915        0/1     ==>          INSN_RORI:       decode_i_shift_insn("rori");
916        0/1     ==>          INSN_SLO:        decode_r_insn("slo");
917        0/1     ==>          INSN_SRO:        decode_r_insn("sro");
918        0/1     ==>          INSN_ROL:        decode_r_insn("rol");
919        0/1     ==>          INSN_ROR:        decode_r_insn("ror");
920        0/1     ==>          INSN_MIN:        decode_r_insn("min");
921        0/1     ==>          INSN_MAX:        decode_r_insn("max");
922        0/1     ==>          INSN_MINU:       decode_r_insn("minu");
923        0/1     ==>          INSN_MAXU:       decode_r_insn("maxu");
924        0/1     ==>          INSN_XNOR:       decode_r_insn("xnor");
925        0/1     ==>          INSN_ORN:        decode_r_insn("orn");
926        0/1     ==>          INSN_ANDN:       decode_r_insn("andn");
927                             // Version 0.92 of the Bitmanip Extension defines the pseudo-instruction
928                             // zext.h rd rs = pack rd, rs, zero.
929                             // Currently instruction set simulators don't output this pseudo-instruction.
930        0/1     ==>          INSN_PACK:       decode_r_insn("pack");
931                             // INSN_PACK: begin
932                               // casez (rvfi_insn)
933                                 // INSN_ZEXTH:  decode_r1_insn("zext.h");
934                                 // default:     decode_r_insn("pack");
935                               // endcase
936                             // end
937        0/1     ==>          INSN_PACKH:      decode_r_insn("packh");
938        0/1     ==>          INSN_PACKU:      decode_r_insn("packu");
939        0/1     ==>          INSN_CLZ:        decode_r1_insn("clz");
940        0/1     ==>          INSN_CTZ:        decode_r1_insn("ctz");
941        0/1     ==>          INSN_PCNT:       decode_r1_insn("pcnt");
942        0/1     ==>          INSN_SEXTB:      decode_r1_insn("sext.b");
943        0/1     ==>          INSN_SEXTH:      decode_r1_insn("sext.h");
944                             // RV32B - ZBS
945        0/1     ==>          INSN_SBCLRI:     decode_i_insn("sbclri");
946        0/1     ==>          INSN_SBSETI:     decode_i_insn("sbseti");
947        0/1     ==>          INSN_SBINVI:     decode_i_insn("sbinvi");
948        0/1     ==>          INSN_SBEXTI:     decode_i_insn("sbexti");
949        0/1     ==>          INSN_SBCLR:      decode_r_insn("sbclr");
950        0/1     ==>          INSN_SBSET:      decode_r_insn("sbset");
951        0/1     ==>          INSN_SBINV:      decode_r_insn("sbinv");
952        0/1     ==>          INSN_SBEXT:      decode_r_insn("sbext");
953                             // RV32B - ZBE
954        0/1     ==>          INSN_BDEP:       decode_r_insn("bdep");
955        0/1     ==>          INSN_BEXT:       decode_r_insn("bext");
956                             // RV32B - ZBP
957        0/1     ==>          INSN_GREV:       decode_r_insn("grev");
958                             INSN_GREVI: begin
959        0/1     ==>            unique casez (rvfi_insn)
960        0/1     ==>              INSN_REV_P:  decode_r1_insn("rev.p");
961        0/1     ==>              INSN_REV2_N: decode_r1_insn("rev2.n");
962        0/1     ==>              INSN_REV_N:  decode_r1_insn("rev.n");
963        0/1     ==>              INSN_REV4_B: decode_r1_insn("rev4.b");
964        0/1     ==>              INSN_REV2_B: decode_r1_insn("rev2.b");
965        0/1     ==>              INSN_REV_B:  decode_r1_insn("rev.b");
966        0/1     ==>              INSN_REV8_H: decode_r1_insn("rev8.h");
967        0/1     ==>              INSN_REV4_H: decode_r1_insn("rev4.h");
968        0/1     ==>              INSN_REV2_H: decode_r1_insn("rev2.h");
969        0/1     ==>              INSN_REV_H:  decode_r1_insn("rev.h");
970        0/1     ==>              INSN_REV16:  decode_r1_insn("rev16");
971        0/1     ==>              INSN_REV8:   decode_r1_insn("rev8");
972        0/1     ==>              INSN_REV4:   decode_r1_insn("rev4");
973        0/1     ==>              INSN_REV2:   decode_r1_insn("rev2");
974        0/1     ==>              INSN_REV:    decode_r1_insn("rev");
975        0/1     ==>              default:     decode_i_insn("grevi");
976                               endcase
977                             end
978        0/1     ==>          INSN_GORC:       decode_r_insn("gorc");
979                             INSN_GORCI: begin
980        0/1     ==>            unique casez (rvfi_insn)
981        0/1     ==>              INSN_ORC_P:  decode_r1_insn("orc.p");
982        0/1     ==>              INSN_ORC2_N: decode_r1_insn("orc2.n");
983        0/1     ==>              INSN_ORC_N:  decode_r1_insn("orc.n");
984        0/1     ==>              INSN_ORC4_B: decode_r1_insn("orc4.b");
985        0/1     ==>              INSN_ORC2_B: decode_r1_insn("orc2.b");
986        0/1     ==>              INSN_ORC_B:  decode_r1_insn("orc.b");
987        0/1     ==>              INSN_ORC8_H: decode_r1_insn("orc8.h");
988        0/1     ==>              INSN_ORC4_H: decode_r1_insn("orc4.h");
989        0/1     ==>              INSN_ORC2_H: decode_r1_insn("orc2.h");
990        0/1     ==>              INSN_ORC_H:  decode_r1_insn("orc.h");
991        0/1     ==>              INSN_ORC16:  decode_r1_insn("orc16");
992        0/1     ==>              INSN_ORC8:   decode_r1_insn("orc8");
993        0/1     ==>              INSN_ORC4:   decode_r1_insn("orc4");
994        0/1     ==>              INSN_ORC2:   decode_r1_insn("orc2");
995        0/1     ==>              INSN_ORC:    decode_r1_insn("orc");
996        0/1     ==>              default:     decode_i_insn("gorci");
997                               endcase
998                             end
999        0/1     ==>          INSN_SHFL:       decode_r_insn("shfl");
1000                            INSN_SHFLI: begin
1001       0/1     ==>            unique casez (rvfi_insn)
1002       0/1     ==>              INSN_ZIP_N:  decode_r1_insn("zip.n");
1003       0/1     ==>              INSN_ZIP2_B: decode_r1_insn("zip2.b");
1004       0/1     ==>              INSN_ZIP_B:  decode_r1_insn("zip.b");
1005       0/1     ==>              INSN_ZIP4_H: decode_r1_insn("zip4.h");
1006       0/1     ==>              INSN_ZIP2_H: decode_r1_insn("zip2.h");
1007       0/1     ==>              INSN_ZIP_H:  decode_r1_insn("zip.h");
1008       0/1     ==>              INSN_ZIP8:   decode_r1_insn("zip8");
1009       0/1     ==>              INSN_ZIP4:   decode_r1_insn("zip4");
1010       0/1     ==>              INSN_ZIP2:   decode_r1_insn("zip2");
1011       0/1     ==>              INSN_ZIP:    decode_r1_insn("zip");
1012       0/1     ==>              default:     decode_i_insn("shfli");
1013                              endcase
1014                            end
1015       0/1     ==>          INSN_UNSHFL:       decode_r_insn("unshfl");
1016                            INSN_UNSHFLI: begin
1017       0/1     ==>            unique casez (rvfi_insn)
1018       0/1     ==>              INSN_UNZIP_N:  decode_r1_insn("unzip.n");
1019       0/1     ==>              INSN_UNZIP2_B: decode_r1_insn("unzip2.b");
1020       0/1     ==>              INSN_UNZIP_B:  decode_r1_insn("unzip.b");
1021       0/1     ==>              INSN_UNZIP4_H: decode_r1_insn("unzip4.h");
1022       0/1     ==>              INSN_UNZIP2_H: decode_r1_insn("unzip2.h");
1023       0/1     ==>              INSN_UNZIP_H:  decode_r1_insn("unzip.h");
1024       0/1     ==>              INSN_UNZIP8:   decode_r1_insn("unzip8");
1025       0/1     ==>              INSN_UNZIP4:   decode_r1_insn("unzip4");
1026       0/1     ==>              INSN_UNZIP2:   decode_r1_insn("unzip2");
1027       0/1     ==>              INSN_UNZIP:    decode_r1_insn("unzip");
1028       0/1     ==>              default:       decode_i_insn("unshfli");
1029                              endcase
1030                            end
1031                    
1032                            // RV32B - ZBT
1033       0/1     ==>          INSN_CMIX:       decode_r_cmixcmov_insn("cmix");
1034       0/1     ==>          INSN_CMOV:       decode_r_cmixcmov_insn("cmov");
1035       0/1     ==>          INSN_FSR:        decode_r_funnelshift_insn("fsr");
1036       0/1     ==>          INSN_FSL:        decode_r_funnelshift_insn("fsl");
1037       0/1     ==>          INSN_FSRI:       decode_i_funnelshift_insn("fsri");
1038                    
1039                            // RV32B - ZBF
1040       0/1     ==>          INSN_BFP:        decode_r_insn("bfp");
1041                    
1042                            // RV32B - ZBC
1043       0/1     ==>          INSN_CLMUL:      decode_r_insn("clmul");
1044       0/1     ==>          INSN_CLMULR:     decode_r_insn("clmulr");
1045       0/1     ==>          INSN_CLMULH:     decode_r_insn("clmulh");
1046                    
1047                            // RV32B - ZBR
1048       0/1     ==>          INSN_CRC32_B:    decode_r1_insn("crc32.b");
1049       0/1     ==>          INSN_CRC32_H:    decode_r1_insn("crc32.h");
1050       0/1     ==>          INSN_CRC32_W:    decode_r1_insn("crc32.w");
1051       0/1     ==>          INSN_CRC32C_B:   decode_r1_insn("crc32c.b");
1052       0/1     ==>          INSN_CRC32C_H:   decode_r1_insn("crc32c.h");
1053       0/1     ==>          INSN_CRC32C_W:   decode_r1_insn("crc32c.w");
1054                    
1055       0/1     ==>          default:         decode_mnemonic("INVALID");

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_tracer

               Total   Covered  Percent
Conditions          6        1    16.67
Logical             6        1    16.67
Non-Logical         0        0
Event               0        0

 LINE       758
 EXPRESSION (rvfi_valid && trace_log_enable)
             -----1----    --------2-------

-1- -2- Status
 0   1  Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       772
 EXPRESSION ((rvfi_insn[15:13] == ibex_tracer_pkg::INSN_CMV[15:13]) && (rvfi_insn[1:0] == ibex_tracer_pkg::OPCODE_C2))
             ---------------------------1--------------------------    -----------------------2----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_tracer
                Total Covered Percent 
Totals          35    1       2.86    
Total Bits      1064  2       0.19    
Total Bits 0->1 532   1       0.19    
Total Bits 1->0 532   1       0.19    

                            
Ports          26  1 3.85   
Port Bits      908 2 0.22   
Port Bits 0->1 454 1 0.22   
Port Bits 1->0 454 1 0.22   

                              
Signals          9   0 0.00   
Signal Bits      156 0 0.00   
Signal Bits 0->1 78  0 0.00   
Signal Bits 1->0 78  0 0.00   

Port Details
                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                Yes    Yes         Yes         INPUT     
rst_ni               No     No          No          INPUT     
hart_id_i[31:0]      No     No          No          INPUT     
rvfi_valid           No     No          No          INPUT     
rvfi_order[63:0]     No     No          No          INPUT     
rvfi_insn[31:0]      No     No          No          INPUT     
rvfi_trap            No     No          No          INPUT     
rvfi_halt            No     No          No          INPUT     
rvfi_intr            No     No          No          INPUT     
rvfi_mode[1:0]       No     No          No          INPUT     
rvfi_ixl[1:0]        No     No          No          INPUT     
rvfi_rs1_addr[4:0]   No     No          No          INPUT     
rvfi_rs2_addr[4:0]   No     No          No          INPUT     
rvfi_rs3_addr[4:0]   No     No          No          INPUT     
rvfi_rs1_rdata[31:0] No     No          No          INPUT     
rvfi_rs2_rdata[31:0] No     No          No          INPUT     
rvfi_rs3_rdata[31:0] No     No          No          INPUT     
rvfi_rd_addr[4:0]    No     No          No          INPUT     
rvfi_rd_wdata[31:0]  No     No          No          INPUT     
rvfi_pc_rdata[31:0]  No     No          No          INPUT     
rvfi_pc_wdata[31:0]  No     No          No          INPUT     
rvfi_mem_addr[31:0]  No     No          No          INPUT     
rvfi_mem_rmask[3:0]  No     No          No          INPUT     
rvfi_mem_wmask[3:0]  No     No          No          INPUT     
rvfi_mem_rdata[31:0] No     No          No          INPUT     
rvfi_mem_wdata[31:0] No     No          No          INPUT     

Signal Details
                        Toggle Toggle 1->0 Toggle 0->1 
unused_rvfi_order[63:0] No     No          No          
unused_rvfi_trap        No     No          No          
unused_rvfi_halt        No     No          No          
unused_rvfi_intr        No     No          No          
unused_rvfi_mode[1:0]   No     No          No          
unused_rvfi_ixl[1:0]    No     No          No          
insn_is_compressed      No     No          No          
data_accessed[4:0]      No     No          No          
trace_log_enable        No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_tracer
         Line No. Total Covered Percent 
Branches          196   5       2.55    
IF       103      3     1       33.33   
IF       742      2     1       50.00   
IF       751      2     1       50.00   
IF       758      2     1       50.00   
IF       769      187   1       0.53    


103            if ($value$plusargs("ibex_tracer_enable=%b", trace_log_enable)) begin
               -1-  
104              if (trace_log_enable == 1'b0) begin
                 -2-  
105                $display("%m: Instruction trace disabled.");
                   ==>
106              end
                 MISSING_ELSE
                 ==>
107            end else begin
108              trace_log_enable = 1'b1;
                 ==>

Branches:

-1- -2- Status      
1   1   Not Covered 
1   0   Not Covered 
0   -   Covered     


742            if (!rst_ni) begin
               -1-  
743              cycle <= 0;
                 ==>
744            end else begin
745              cycle <= cycle + 1;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


751            if (file_handle != 32'h0) begin
               -1-  
752              $fclose(file_handle);
                 ==>
753            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


758            if (rvfi_valid && trace_log_enable) begin
               -1-  
759              printbuffer_dumpline();
                 ==>
760            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


769            if (rvfi_insn[1:0] != 2'b11) begin
               -1-  
770              insn_is_compressed = 1;
771              // Separate case to avoid overlapping decoding
772              if (rvfi_insn[15:13] == INSN_CMV[15:13] && rvfi_insn[1:0] == OPCODE_C2) begin
                 -2-  
773                if (rvfi_insn[12] == INSN_CADD[12]) begin
                   -3-  
774                  if (rvfi_insn[11:2] == INSN_CEBREAK[11:2]) begin
                     -4-  
775                    decode_mnemonic("c.ebreak");
                       ==>
776                  end else if (rvfi_insn[6:2] == INSN_CJALR[6:2]) begin
                              -5-  
777                    decode_cr_insn("c.jalr");
                       ==>
778                  end else begin
779                    decode_cr_insn("c.add");
                       ==>
780                  end
781                end else begin
782                  if (rvfi_insn[6:2] == INSN_CJR[6:2]) begin
                     -6-  
783                    decode_cr_insn("c.jr");
                       ==>
784                  end else begin
785                    decode_cr_insn("c.mv");
                       ==>
786                  end
787                end
788              end else begin
789                unique casez (rvfi_insn[15:0])
                          -7-  
790                  // C0 Opcodes
791                  INSN_CADDI4SPN: begin
792                    if (rvfi_insn[12:2] == 11'h0) begin
                       -8-  
793                      // Align with pseudo-mnemonic used by GNU binutils and LLVM's MC layer
794                      decode_mnemonic("c.unimp");
                         ==>
795                    end else begin
796                      decode_ciw_insn("c.addi4spn");
                         ==>
797                    end
798                  end
799                  INSN_CLW:        decode_compressed_load_insn("c.lw");
                     ==>
800                  INSN_CSW:        decode_compressed_store_insn("c.sw");
                     ==>
801                  // C1 Opcodes
802                  INSN_CADDI:      decode_ci_caddi_insn("c.addi");
                     ==>
803                  INSN_CJAL:       decode_cj_insn("c.jal");
                     ==>
804                  INSN_CJ:         decode_cj_insn("c.j");
                     ==>
805                  INSN_CLI:        decode_ci_cli_insn("c.li");
                     ==>
806                  INSN_CLUI: begin
807                    // These two instructions share opcode
808                    if (rvfi_insn[11:7] == 5'd2) begin
                       -9-  
809                      decode_ci_caddi16sp_insn("c.addi16sp");
                         ==>
810                    end else begin
811                      decode_ci_clui_insn("c.lui");
                         ==>
812                    end
813                  end
814                  INSN_CSRLI:      decode_cb_sr_insn("c.srli");
                     ==>
815                  INSN_CSRAI:      decode_cb_sr_insn("c.srai");
                     ==>
816                  INSN_CANDI:      decode_cb_insn("c.andi");
                     ==>
817                  INSN_CSUB:       decode_cs_insn("c.sub");
                     ==>
818                  INSN_CXOR:       decode_cs_insn("c.xor");
                     ==>
819                  INSN_COR:        decode_cs_insn("c.or");
                     ==>
820                  INSN_CAND:       decode_cs_insn("c.and");
                     ==>
821                  INSN_CBEQZ:      decode_cb_insn("c.beqz");
                     ==>
822                  INSN_CBNEZ:      decode_cb_insn("c.bnez");
                     ==>
823                  // C2 Opcodes
824                  INSN_CSLLI:      decode_ci_cslli_insn("c.slli");
                     ==>
825                  INSN_CLWSP:      decode_compressed_load_insn("c.lwsp");
                     ==>
826                  INSN_SWSP:       decode_compressed_store_insn("c.swsp");
                     ==>
827                  default:         decode_mnemonic("INVALID");
                     ==>
828                endcase
829              end
830            end else begin
831              unique casez (rvfi_insn)
                        -10-  
832                // Regular opcodes
833                INSN_LUI:        decode_u_insn("lui");
                   ==>
834                INSN_AUIPC:      decode_u_insn("auipc");
                   ==>
835                INSN_JAL:        decode_j_insn("jal");
                   ==>
836                INSN_JALR:       decode_i_jalr_insn("jalr");
                   ==>
837                // BRANCH
838                INSN_BEQ:        decode_b_insn("beq");
                   ==>
839                INSN_BNE:        decode_b_insn("bne");
                   ==>
840                INSN_BLT:        decode_b_insn("blt");
                   ==>
841                INSN_BGE:        decode_b_insn("bge");
                   ==>
842                INSN_BLTU:       decode_b_insn("bltu");
                   ==>
843                INSN_BGEU:       decode_b_insn("bgeu");
                   ==>
844                // OPIMM
845                INSN_ADDI: begin
846                  if (rvfi_insn == 32'h00_00_00_13) begin
                     -11-  
847                    // TODO: objdump doesn't decode this as nop currently, even though it would be helpful
848                    // Decide what to do here: diverge from objdump, or make the trace less readable to
849                    // users.
850                    //decode_mnemonic("nop");
851                    decode_i_insn("addi");
                       ==>
852                  end else begin
853                    decode_i_insn("addi");
                       ==>
854                  end
855                end
856                INSN_SLTI:       decode_i_insn("slti");
                   ==>
857                INSN_SLTIU:      decode_i_insn("sltiu");
                   ==>
858                INSN_XORI:       decode_i_insn("xori");
                   ==>
859                INSN_ORI:        decode_i_insn("ori");
                   ==>
860                // Version 0.92 of the Bitmanip Extension defines the pseudo-instruction
861                // zext.b rd rs = andi rd, rs, 255.
862                // Currently instruction set simulators don't output this pseudo-instruction.
863                INSN_ANDI:       decode_i_insn("andi");
                   ==>
864                // INSN_ANDI:begin
865                  // casez (rvfi_insn)
866                    // INSN_ZEXTB:  decode_r1_insn("zext.b");
867                    // default:     decode_i_insn("andi");
868                  // endcase
869                // end
870                INSN_SLLI:       decode_i_shift_insn("slli");
                   ==>
871                INSN_SRLI:       decode_i_shift_insn("srli");
                   ==>
872                INSN_SRAI:       decode_i_shift_insn("srai");
                   ==>
873                // OP
874                INSN_ADD:        decode_r_insn("add");
                   ==>
875                INSN_SUB:        decode_r_insn("sub");
                   ==>
876                INSN_SLL:        decode_r_insn("sll");
                   ==>
877                INSN_SLT:        decode_r_insn("slt");
                   ==>
878                INSN_SLTU:       decode_r_insn("sltu");
                   ==>
879                INSN_XOR:        decode_r_insn("xor");
                   ==>
880                INSN_SRL:        decode_r_insn("srl");
                   ==>
881                INSN_SRA:        decode_r_insn("sra");
                   ==>
882                INSN_OR:         decode_r_insn("or");
                   ==>
883                INSN_AND:        decode_r_insn("and");
                   ==>
884                // SYSTEM (CSR manipulation)
885                INSN_CSRRW:      decode_csr_insn("csrrw");
                   ==>
886                INSN_CSRRS:      decode_csr_insn("csrrs");
                   ==>
887                INSN_CSRRC:      decode_csr_insn("csrrc");
                   ==>
888                INSN_CSRRWI:     decode_csr_insn("csrrwi");
                   ==>
889                INSN_CSRRSI:     decode_csr_insn("csrrsi");
                   ==>
890                INSN_CSRRCI:     decode_csr_insn("csrrci");
                   ==>
891                // SYSTEM (others)
892                INSN_ECALL:      decode_mnemonic("ecall");
                   ==>
893                INSN_EBREAK:     decode_mnemonic("ebreak");
                   ==>
894                INSN_MRET:       decode_mnemonic("mret");
                   ==>
895                INSN_DRET:       decode_mnemonic("dret");
                   ==>
896                INSN_WFI:        decode_mnemonic("wfi");
                   ==>
897                // RV32M
898                INSN_PMUL:       decode_r_insn("mul");
                   ==>
899                INSN_PMUH:       decode_r_insn("mulh");
                   ==>
900                INSN_PMULHSU:    decode_r_insn("mulhsu");
                   ==>
901                INSN_PMULHU:     decode_r_insn("mulhu");
                   ==>
902                INSN_DIV:        decode_r_insn("div");
                   ==>
903                INSN_DIVU:       decode_r_insn("divu");
                   ==>
904                INSN_REM:        decode_r_insn("rem");
                   ==>
905                INSN_REMU:       decode_r_insn("remu");
                   ==>
906                // LOAD & STORE
907                INSN_LOAD:       decode_load_insn();
                   ==>
908                INSN_STORE:      decode_store_insn();
                   ==>
909                // MISC-MEM
910                INSN_FENCE:      decode_fence();
                   ==>
911                INSN_FENCEI:     decode_mnemonic("fence.i");
                   ==>
912                // RV32B - ZBB
913                INSN_SLOI:       decode_i_shift_insn("sloi");
                   ==>
914                INSN_SROI:       decode_i_shift_insn("sroi");
                   ==>
915                INSN_RORI:       decode_i_shift_insn("rori");
                   ==>
916                INSN_SLO:        decode_r_insn("slo");
                   ==>
917                INSN_SRO:        decode_r_insn("sro");
                   ==>
918                INSN_ROL:        decode_r_insn("rol");
                   ==>
919                INSN_ROR:        decode_r_insn("ror");
                   ==>
920                INSN_MIN:        decode_r_insn("min");
                   ==>
921                INSN_MAX:        decode_r_insn("max");
                   ==>
922                INSN_MINU:       decode_r_insn("minu");
                   ==>
923                INSN_MAXU:       decode_r_insn("maxu");
                   ==>
924                INSN_XNOR:       decode_r_insn("xnor");
                   ==>
925                INSN_ORN:        decode_r_insn("orn");
                   ==>
926                INSN_ANDN:       decode_r_insn("andn");
                   ==>
927                // Version 0.92 of the Bitmanip Extension defines the pseudo-instruction
928                // zext.h rd rs = pack rd, rs, zero.
929                // Currently instruction set simulators don't output this pseudo-instruction.
930                INSN_PACK:       decode_r_insn("pack");
                   ==>
931                // INSN_PACK: begin
932                  // casez (rvfi_insn)
933                    // INSN_ZEXTH:  decode_r1_insn("zext.h");
934                    // default:     decode_r_insn("pack");
935                  // endcase
936                // end
937                INSN_PACKH:      decode_r_insn("packh");
                   ==>
938                INSN_PACKU:      decode_r_insn("packu");
                   ==>
939                INSN_CLZ:        decode_r1_insn("clz");
                   ==>
940                INSN_CTZ:        decode_r1_insn("ctz");
                   ==>
941                INSN_PCNT:       decode_r1_insn("pcnt");
                   ==>
942                INSN_SEXTB:      decode_r1_insn("sext.b");
                   ==>
943                INSN_SEXTH:      decode_r1_insn("sext.h");
                   ==>
944                // RV32B - ZBS
945                INSN_SBCLRI:     decode_i_insn("sbclri");
                   ==>
946                INSN_SBSETI:     decode_i_insn("sbseti");
                   ==>
947                INSN_SBINVI:     decode_i_insn("sbinvi");
                   ==>
948                INSN_SBEXTI:     decode_i_insn("sbexti");
                   ==>
949                INSN_SBCLR:      decode_r_insn("sbclr");
                   ==>
950                INSN_SBSET:      decode_r_insn("sbset");
                   ==>
951                INSN_SBINV:      decode_r_insn("sbinv");
                   ==>
952                INSN_SBEXT:      decode_r_insn("sbext");
                   ==>
953                // RV32B - ZBE
954                INSN_BDEP:       decode_r_insn("bdep");
                   ==>
955                INSN_BEXT:       decode_r_insn("bext");
                   ==>
956                // RV32B - ZBP
957                INSN_GREV:       decode_r_insn("grev");
                   ==>
958                INSN_GREVI: begin
959                  unique casez (rvfi_insn)
                            -12-  
960                    INSN_REV_P:  decode_r1_insn("rev.p");
                       ==>
961                    INSN_REV2_N: decode_r1_insn("rev2.n");
                       ==>
962                    INSN_REV_N:  decode_r1_insn("rev.n");
                       ==>
963                    INSN_REV4_B: decode_r1_insn("rev4.b");
                       ==>
964                    INSN_REV2_B: decode_r1_insn("rev2.b");
                       ==>
965                    INSN_REV_B:  decode_r1_insn("rev.b");
                       ==>
966                    INSN_REV8_H: decode_r1_insn("rev8.h");
                       ==>
967                    INSN_REV4_H: decode_r1_insn("rev4.h");
                       ==>
968                    INSN_REV2_H: decode_r1_insn("rev2.h");
                       ==>
969                    INSN_REV_H:  decode_r1_insn("rev.h");
                       ==>
970                    INSN_REV16:  decode_r1_insn("rev16");
                       ==>
971                    INSN_REV8:   decode_r1_insn("rev8");
                       ==>
972                    INSN_REV4:   decode_r1_insn("rev4");
                       ==>
973                    INSN_REV2:   decode_r1_insn("rev2");
                       ==>
974                    INSN_REV:    decode_r1_insn("rev");
                       ==>
975                    default:     decode_i_insn("grevi");
                       ==>
976                  endcase
977                end
978                INSN_GORC:       decode_r_insn("gorc");
                   ==>
979                INSN_GORCI: begin
980                  unique casez (rvfi_insn)
                            -13-  
981                    INSN_ORC_P:  decode_r1_insn("orc.p");
                       ==>
982                    INSN_ORC2_N: decode_r1_insn("orc2.n");
                       ==>
983                    INSN_ORC_N:  decode_r1_insn("orc.n");
                       ==>
984                    INSN_ORC4_B: decode_r1_insn("orc4.b");
                       ==>
985                    INSN_ORC2_B: decode_r1_insn("orc2.b");
                       ==>
986                    INSN_ORC_B:  decode_r1_insn("orc.b");
                       ==>
987                    INSN_ORC8_H: decode_r1_insn("orc8.h");
                       ==>
988                    INSN_ORC4_H: decode_r1_insn("orc4.h");
                       ==>
989                    INSN_ORC2_H: decode_r1_insn("orc2.h");
                       ==>
990                    INSN_ORC_H:  decode_r1_insn("orc.h");
                       ==>
991                    INSN_ORC16:  decode_r1_insn("orc16");
                       ==>
992                    INSN_ORC8:   decode_r1_insn("orc8");
                       ==>
993                    INSN_ORC4:   decode_r1_insn("orc4");
                       ==>
994                    INSN_ORC2:   decode_r1_insn("orc2");
                       ==>
995                    INSN_ORC:    decode_r1_insn("orc");
                       ==>
996                    default:     decode_i_insn("gorci");
                       ==>
997                  endcase
998                end
999                INSN_SHFL:       decode_r_insn("shfl");
                   ==>
1000               INSN_SHFLI: begin
1001                 unique casez (rvfi_insn)
                            -14-  
1002                   INSN_ZIP_N:  decode_r1_insn("zip.n");
                       ==>
1003                   INSN_ZIP2_B: decode_r1_insn("zip2.b");
                       ==>
1004                   INSN_ZIP_B:  decode_r1_insn("zip.b");
                       ==>
1005                   INSN_ZIP4_H: decode_r1_insn("zip4.h");
                       ==>
1006                   INSN_ZIP2_H: decode_r1_insn("zip2.h");
                       ==>
1007                   INSN_ZIP_H:  decode_r1_insn("zip.h");
                       ==>
1008                   INSN_ZIP8:   decode_r1_insn("zip8");
                       ==>
1009                   INSN_ZIP4:   decode_r1_insn("zip4");
                       ==>
1010                   INSN_ZIP2:   decode_r1_insn("zip2");
                       ==>
1011                   INSN_ZIP:    decode_r1_insn("zip");
                       ==>
1012                   default:     decode_i_insn("shfli");
                       ==>
1013                 endcase
1014               end
1015               INSN_UNSHFL:       decode_r_insn("unshfl");
                   ==>
1016               INSN_UNSHFLI: begin
1017                 unique casez (rvfi_insn)
                            -15-  
1018                   INSN_UNZIP_N:  decode_r1_insn("unzip.n");
                       ==>
1019                   INSN_UNZIP2_B: decode_r1_insn("unzip2.b");
                       ==>
1020                   INSN_UNZIP_B:  decode_r1_insn("unzip.b");
                       ==>
1021                   INSN_UNZIP4_H: decode_r1_insn("unzip4.h");
                       ==>
1022                   INSN_UNZIP2_H: decode_r1_insn("unzip2.h");
                       ==>
1023                   INSN_UNZIP_H:  decode_r1_insn("unzip.h");
                       ==>
1024                   INSN_UNZIP8:   decode_r1_insn("unzip8");
                       ==>
1025                   INSN_UNZIP4:   decode_r1_insn("unzip4");
                       ==>
1026                   INSN_UNZIP2:   decode_r1_insn("unzip2");
                       ==>
1027                   INSN_UNZIP:    decode_r1_insn("unzip");
                       ==>
1028                   default:       decode_i_insn("unshfli");
                       ==>
1029                 endcase
1030               end
1031       
1032               // RV32B - ZBT
1033               INSN_CMIX:       decode_r_cmixcmov_insn("cmix");
                   ==>
1034               INSN_CMOV:       decode_r_cmixcmov_insn("cmov");
                   ==>
1035               INSN_FSR:        decode_r_funnelshift_insn("fsr");
                   ==>
1036               INSN_FSL:        decode_r_funnelshift_insn("fsl");
                   ==>
1037               INSN_FSRI:       decode_i_funnelshift_insn("fsri");
                   ==>
1038       
1039               // RV32B - ZBF
1040               INSN_BFP:        decode_r_insn("bfp");
                   ==>
1041       
1042               // RV32B - ZBC
1043               INSN_CLMUL:      decode_r_insn("clmul");
                   ==>
1044               INSN_CLMULR:     decode_r_insn("clmulr");
                   ==>
1045               INSN_CLMULH:     decode_r_insn("clmulh");
                   ==>
1046       
1047               // RV32B - ZBR
1048               INSN_CRC32_B:    decode_r1_insn("crc32.b");
                   ==>
1049               INSN_CRC32_H:    decode_r1_insn("crc32.h");
                   ==>
1050               INSN_CRC32_W:    decode_r1_insn("crc32.w");
                   ==>
1051               INSN_CRC32C_B:   decode_r1_insn("crc32c.b");
                   ==>
1052               INSN_CRC32C_H:   decode_r1_insn("crc32c.h");
                   ==>
1053               INSN_CRC32C_W:   decode_r1_insn("crc32c.w");
                   ==>
1054       
1055               default:         decode_mnemonic("INVALID");
                   ==>

Branches:

-1- -2- -3- -4- -5- -6- -7-                              -8- -9- -10-                            -11- -12-                          -13-                          -14-                          -15-                            Status      
1   1   1   1   -   -   -                                -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   1   1   0   1   -   -                                -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   1   1   0   0   -   -                                -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   1   0   -   -   1   -                                -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   1   0   -   -   0   -                                -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CADDI4SPN  1   -   -                               -    -                             -                             -                             -                               Covered     
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CADDI4SPN  0   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLW        -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSW        -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CADDI      -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CJAL       -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CJ         -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLI        -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLUI       -   1   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLUI       -   0   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSRLI      -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSRAI      -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CANDI      -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSUB       -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CXOR       -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_COR        -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CAND       -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CBEQZ      -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CBNEZ      -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSLLI      -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLWSP      -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_SWSP       -   -   -                               -    -                             -                             -                             -                               Not Covered 
1   0   -   -   -   -   default                          -   -   -                               -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_LUI       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_AUIPC     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_JAL       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_JALR      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BEQ       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BNE       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BLT       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BGE       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BLTU      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BGEU      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ADDI      1    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ADDI      0    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLTI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLTIU     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_XORI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ORI       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ANDI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLLI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRLI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRAI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ADD       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SUB       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLL       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLT       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLTU      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_XOR       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRL       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRA       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_OR        -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_AND       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRW     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRS     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRC     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRWI    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRSI    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRCI    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ECALL     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_EBREAK    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_MRET      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_DRET      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_WFI       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PMUL      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PMUH      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PMULHSU   -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PMULHU    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_DIV       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_DIVU      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_REM       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_REMU      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_LOAD      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_STORE     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_FENCE     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_FENCEI    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLOI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SROI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_RORI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLO       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRO       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ROL       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ROR       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_MIN       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_MAX       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_MINU      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_MAXU      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_XNOR      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ORN       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ANDN      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PACK      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PACKH     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PACKU     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CLZ       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CTZ       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PCNT      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SEXTB     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SEXTH     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SBCLRI    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SBSETI    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SBINVI    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SBEXTI    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SBCLR     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SBSET     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SBINV     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SBEXT     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BDEP      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BEXT      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREV      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV_P   -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV2_N  -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV_N   -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV4_B  -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV2_B  -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV_B   -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV8_H  -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV4_H  -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV2_H  -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV_H   -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV16   -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV8    -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV4    -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV2    -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    ibex_tracer_pkg::INSN_REV     -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GREVI     -    default                       -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORC      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC_P   -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC2_N  -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC_N   -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC4_B  -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC2_B  -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC_B   -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC8_H  -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC4_H  -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC2_H  -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC_H   -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC16   -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC8    -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC4    -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC2    -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             ibex_tracer_pkg::INSN_ORC     -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_GORCI     -    -                             default                       -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFL      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP_N   -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP2_B  -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP_B   -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP4_H  -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP2_H  -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP_H   -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP8    -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP4    -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP2    -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             ibex_tracer_pkg::INSN_ZIP     -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SHFLI     -    -                             -                             default                       -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFL    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP_N   Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP2_B  Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP_B   Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP4_H  Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP2_H  Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP_H   Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP8    Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP4    Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP2    Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             ibex_tracer_pkg::INSN_UNZIP     Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_UNSHFLI   -    -                             -                             -                             default                         Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CMIX      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CMOV      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_FSR       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_FSL       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_FSRI      -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BFP       -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CLMUL     -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CLMULR    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CLMULH    -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CRC32_B   -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CRC32_H   -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CRC32_W   -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CRC32C_B  -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CRC32C_H  -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CRC32C_W  -    -                             -                             -                             -                               Not Covered 
0   -   -   -   -   -   -                                -   -   default                         -    -                             -                             -                             -                               Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_tracer
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  5.50   2.61  16.67   0.19   2.55 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  5.50   2.61  16.67   0.19   2.55 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME        
  5.50   2.61  16.67   0.19   2.55 --     ibex_tracer 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME 
  0.12 --     --       0.12 --     --     DUT  


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_decoder
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  5.80  11.06  14.81   0.00   3.10   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_decoder.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                   
  5.80  11.06  14.81   0.00   3.10   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.id_stage_i.decoder_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_decoder

             Line No.   Total   Covered  Percent
TOTAL                      461       51    11.06
ALWAYS            191        3        2    66.67
ALWAYS            206      177       35    19.77
ALWAYS            659      281       14     4.98

190                       always_comb begin : csr_operand_check
191        1/1              csr_op_o = csr_op;
192                     
193                         // CSRRSI/CSRRCI must not write 0 to CSRs (uimm[4:0]=='0)
194                         // CSRRS/CSRRC must not write from x0 to CSRs (rs1=='0)
195        1/1              if ((csr_op == CSR_OP_SET || csr_op == CSR_OP_CLEAR) &&
196                             instr_rs1 == '0) begin
197        0/1     ==>        csr_op_o = CSR_OP_READ;
198                         end
                        MISSING_ELSE
199                       end
200                     
201                       /////////////
202                       // Decoder //
203                       /////////////
204                     
205                       always_comb begin
206        1/1              jump_in_dec_o         = 1'b0;
207        1/1              jump_set_o            = 1'b0;
208        1/1              branch_in_dec_o       = 1'b0;
209        1/1              icache_inval_o        = 1'b0;
210                     
211        1/1              multdiv_operator_o    = MD_OP_MULL;
212        1/1              multdiv_signed_mode_o = 2'b00;
213                     
214        1/1              rf_wdata_sel_o        = RF_WD_EX;
215        1/1              rf_we                 = 1'b0;
216        1/1              rf_ren_a_o            = 1'b0;
217        1/1              rf_ren_b_o            = 1'b0;
218                     
219        1/1              csr_access_o          = 1'b0;
220        1/1              csr_illegal           = 1'b0;
221        1/1              csr_op                = CSR_OP_READ;
222                     
223        1/1              data_we_o             = 1'b0;
224        1/1              data_type_o           = 2'b00;
225        1/1              data_sign_extension_o = 1'b0;
226        1/1              data_req_o            = 1'b0;
227                     
228        1/1              illegal_insn          = 1'b0;
229        1/1              ebrk_insn_o           = 1'b0;
230        1/1              mret_insn_o           = 1'b0;
231        1/1              dret_insn_o           = 1'b0;
232        1/1              ecall_insn_o          = 1'b0;
233        1/1              wfi_insn_o            = 1'b0;
234                     
235        1/1              opcode                = opcode_e'(instr[6:0]);
236                     
237        1/1              unique case (opcode)
238                     
239                           ///////////
240                           // Jumps //
241                           ///////////
242                     
243                           OPCODE_JAL: begin   // Jump and Link
244        0/1     ==>          jump_in_dec_o      = 1'b1;
245                     
246        0/1     ==>          if (instr_first_cycle_i) begin
247                               // Calculate jump target (and store PC + 4 if BranchTargetALU is configured)
248        0/1     ==>            rf_we            = BranchTargetALU;
249        0/1     ==>            jump_set_o       = 1'b1;
250                             end else begin
251                               // Calculate and store PC+4
252        0/1     ==>            rf_we            = 1'b1;
253                             end
254                           end
255                     
256                           OPCODE_JALR: begin  // Jump and Link Register
257        0/1     ==>          jump_in_dec_o      = 1'b1;
258                     
259        0/1     ==>          if (instr_first_cycle_i) begin
260                               // Calculate jump target (and store PC + 4 if BranchTargetALU is configured)
261        0/1     ==>            rf_we            = BranchTargetALU;
262        0/1     ==>            jump_set_o       = 1'b1;
263                             end else begin
264                               // Calculate and store PC+4
265        0/1     ==>            rf_we            = 1'b1;
266                             end
267        0/1     ==>          if (instr[14:12] != 3'b0) begin
268        0/1     ==>            illegal_insn = 1'b1;
269                             end
                   ==>  MISSING_ELSE
270                     
271        0/1     ==>          rf_ren_a_o = 1'b1;
272                           end
273                     
274                           OPCODE_BRANCH: begin // Branch
275        0/1     ==>          branch_in_dec_o       = 1'b1;
276                             // Check branch condition selection
277        0/1     ==>          unique case (instr[14:12])
278                               3'b000,
279                               3'b001,
280                               3'b100,
281                               3'b101,
282                               3'b110,
283        0/1     ==>            3'b111:  illegal_insn = 1'b0;
284        0/1     ==>            default: illegal_insn = 1'b1;
285                             endcase
286                     
287        0/1     ==>          rf_ren_a_o = 1'b1;
288        0/1     ==>          rf_ren_b_o = 1'b1;
289                           end
290                     
291                           ////////////////
292                           // Load/store //
293                           ////////////////
294                     
295                           OPCODE_STORE: begin
296        0/1     ==>          rf_ren_a_o         = 1'b1;
297        0/1     ==>          rf_ren_b_o         = 1'b1;
298        0/1     ==>          data_req_o         = 1'b1;
299        0/1     ==>          data_we_o          = 1'b1;
300                     
301        0/1     ==>          if (instr[14]) begin
302        0/1     ==>            illegal_insn = 1'b1;
303                             end
                   ==>  MISSING_ELSE
304                     
305                             // store size
306        0/1     ==>          unique case (instr[13:12])
307        0/1     ==>            2'b00:   data_type_o  = 2'b10; // sb
308        0/1     ==>            2'b01:   data_type_o  = 2'b01; // sh
309        0/1     ==>            2'b10:   data_type_o  = 2'b00; // sw
310        0/1     ==>            default: illegal_insn = 1'b1;
311                             endcase
312                           end
313                     
314                           OPCODE_LOAD: begin
315        0/1     ==>          rf_ren_a_o          = 1'b1;
316        0/1     ==>          data_req_o          = 1'b1;
317        0/1     ==>          data_type_o         = 2'b00;
318                     
319                             // sign/zero extension
320        0/1     ==>          data_sign_extension_o = ~instr[14];
321                     
322                             // load size
323        0/1     ==>          unique case (instr[13:12])
324        0/1     ==>            2'b00: data_type_o = 2'b10; // lb(u)
325        0/1     ==>            2'b01: data_type_o = 2'b01; // lh(u)
326                               2'b10: begin
327        0/1     ==>              data_type_o = 2'b00;      // lw
328        0/1     ==>              if (instr[14]) begin
329        0/1     ==>                illegal_insn = 1'b1;    // lwu does not exist
330                                 end
                   ==>  MISSING_ELSE
331                               end
332                               default: begin
333        0/1     ==>              illegal_insn = 1'b1;
334                               end
335                             endcase
336                           end
337                     
338                           /////////
339                           // ALU //
340                           /////////
341                     
342                           OPCODE_LUI: begin  // Load Upper Immediate
343        0/1     ==>          rf_we            = 1'b1;
344                           end
345                     
346                           OPCODE_AUIPC: begin  // Add Upper Immediate to PC
347        0/1     ==>          rf_we            = 1'b1;
348                           end
349                     
350                           OPCODE_OP_IMM: begin // Register-Immediate ALU Operations
351        0/1     ==>          rf_ren_a_o       = 1'b1;
352        0/1     ==>          rf_we            = 1'b1;
353                     
354        0/1     ==>          unique case (instr[14:12])
355                               3'b000,
356                               3'b010,
357                               3'b011,
358                               3'b100,
359                               3'b110,
360        0/1     ==>            3'b111: illegal_insn = 1'b0;
361                     
362                               3'b001: begin
363        0/1     ==>              unique case (instr[31:27])
364        0/1     ==>                5'b0_0000: illegal_insn = (instr[26:25] == 2'b00) ? 1'b0 : 1'b1;        // slli
365                                   5'b0_0100,                                                              // sloi
366                                   5'b0_1001,                                                              // sbclri
367                                   5'b0_0101,                                                              // sbseti
368        0/1     ==>                5'b0_1101: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;           // sbinvi
369        0/1     ==>                5'b0_0001: if (instr[26] == 1'b0) begin
370        0/1     ==>                  illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1;                    // shfl
371                                   end else begin
372        0/1     ==>                  illegal_insn = 1'b1;
373                                   end
374                                   5'b0_1100: begin
375        0/1     ==>                  unique case(instr[26:20])
376                                       7'b000_0000,                                                         // clz
377                                       7'b000_0001,                                                         // ctz
378                                       7'b000_0010,                                                         // pcnt
379                                       7'b000_0100,                                                         // sext.b
380        0/1     ==>                    7'b000_0101: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;      // sext.h
381                                       7'b001_0000,                                                         // crc32.b
382                                       7'b001_0001,                                                         // crc32.h
383                                       7'b001_0010,                                                         // crc32.w
384                                       7'b001_1000,                                                         // crc32c.b
385                                       7'b001_1001,                                                         // crc32c.h
386        0/1     ==>                    7'b001_1010: illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1;      // crc32c.w
387                     
388        0/1     ==>                    default: illegal_insn = 1'b1;
389                                     endcase
390                                   end
391        0/1     ==>                default : illegal_insn = 1'b1;
392                                 endcase
393                               end
394                     
395                               3'b101: begin
396        0/1     ==>              if (instr[26]) begin
397        0/1     ==>                illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;                       // fsri
398                                 end else begin
399        0/1     ==>                unique case (instr[31:27])
400                                     5'b0_0000,                                                             // srli
401        0/1     ==>                  5'b0_1000: illegal_insn = (instr[26:25] == 2'b00) ? 1'b0 : 1'b1;       // srai
402                     
403                                     5'b0_0100,                                                             // sroi
404                                     5'b0_1100,                                                             // rori
405        0/1     ==>                  5'b0_1001: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;          // sbexti
406                     
407                                     5'b0_1101: begin
408        0/1     ==>                    if ((RV32B == RV32BFull)) begin
409        0/1     ==>                      illegal_insn = 1'b0;                                               // grevi
410                                       end else begin
411        0/1     ==>                      unique case (instr[24:20])
412                                           5'b11111,                                                        // rev
413        0/1     ==>                        5'b11000: illegal_insn = (RV32B == RV32BBalanced) ? 1'b0 : 1'b1; // rev8
414                     
415        0/1     ==>                        default: illegal_insn = 1'b1;
416                                         endcase
417                                       end
418                                     end
419                                     5'b0_0101: begin
420        0/1     ==>                    if ((RV32B == RV32BFull)) begin
421        0/1     ==>                      illegal_insn = 1'b0;                                              // gorci
422        0/1     ==>                    end else if (instr[24:20] == 5'b00111) begin
423        0/1     ==>                      illegal_insn = (RV32B == RV32BBalanced) ? 1'b0 : 1'b1;            // orc.b
424                                       end else begin
425        0/1     ==>                      illegal_insn = 1'b1;
426                                       end
427                                     end
428                                     5'b0_0001: begin
429        0/1     ==>                    if (instr[26] == 1'b0) begin
430        0/1     ==>                      illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1;                // unshfl
431                                       end else begin
432        0/1     ==>                      illegal_insn = 1'b1;
433                                       end
434                                     end
435                     
436        0/1     ==>                  default: illegal_insn = 1'b1;
437                                   endcase
438                                 end
439                               end
440                     
441        0/1     ==>            default: illegal_insn = 1'b1;
442                             endcase
443                           end
444                     
445                           OPCODE_OP: begin  // Register-Register ALU operation
446        0/1     ==>          rf_ren_a_o      = 1'b1;
447        0/1     ==>          rf_ren_b_o      = 1'b1;
448        0/1     ==>          rf_we           = 1'b1;
449        0/1     ==>          if ({instr[26], instr[13:12]} == {1'b1, 2'b01}) begin
450        0/1     ==>            illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1; // cmix / cmov / fsl / fsr
451                             end else begin
452        0/1     ==>            unique case ({instr[31:25], instr[14:12]})
453                                 // RV32I ALU operations
454                                 {7'b000_0000, 3'b000},
455                                 {7'b010_0000, 3'b000},
456                                 {7'b000_0000, 3'b010},
457                                 {7'b000_0000, 3'b011},
458                                 {7'b000_0000, 3'b100},
459                                 {7'b000_0000, 3'b110},
460                                 {7'b000_0000, 3'b111},
461                                 {7'b000_0000, 3'b001},
462                                 {7'b000_0000, 3'b101},
463        0/1     ==>              {7'b010_0000, 3'b101}: illegal_insn = 1'b0;
464                     
465                                 // RV32B zbb
466                                 {7'b010_0000, 3'b111}, // andn
467                                 {7'b010_0000, 3'b110}, // orn
468                                 {7'b010_0000, 3'b100}, // xnor
469                                 {7'b001_0000, 3'b001}, // slo
470                                 {7'b001_0000, 3'b101}, // sro
471                                 {7'b011_0000, 3'b001}, // rol
472                                 {7'b011_0000, 3'b101}, // ror
473                                 {7'b000_0101, 3'b100}, // min
474                                 {7'b000_0101, 3'b101}, // max
475                                 {7'b000_0101, 3'b110}, // minu
476                                 {7'b000_0101, 3'b111}, // maxu
477                                 {7'b000_0100, 3'b100}, // pack
478                                 {7'b010_0100, 3'b100}, // packu
479                                 {7'b000_0100, 3'b111}, // packh
480                                 // RV32B zbs
481                                 {7'b010_0100, 3'b001}, // sbclr
482                                 {7'b001_0100, 3'b001}, // sbset
483                                 {7'b011_0100, 3'b001}, // sbinv
484                                 {7'b010_0100, 3'b101}, // sbext
485                                 // RV32B zbf
486        0/1     ==>              {7'b010_0100, 3'b111}: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1; // bfp
487                                 // RV32B zbe
488                                 {7'b010_0100, 3'b110}, // bdep
489                                 {7'b000_0100, 3'b110}, // bext
490                                 // RV32B zbp
491                                 {7'b011_0100, 3'b101}, // grev
492                                 {7'b001_0100, 3'b101}, // gorc
493                                 {7'b000_0100, 3'b001}, // shfl
494                                 {7'b000_0100, 3'b101}, // unshfl
495                                 // RV32B zbc
496                                 {7'b000_0101, 3'b001}, // clmul
497                                 {7'b000_0101, 3'b010}, // clmulr
498        0/1     ==>              {7'b000_0101, 3'b011}: illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1; // clmulh
499                     
500                                 // RV32M instructions
501                                 {7'b000_0001, 3'b000}: begin // mul
502        0/1     ==>                multdiv_operator_o    = MD_OP_MULL;
503        0/1     ==>                multdiv_signed_mode_o = 2'b00;
504        0/1     ==>                illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
505                                 end
506                                 {7'b000_0001, 3'b001}: begin // mulh
507        0/1     ==>                multdiv_operator_o    = MD_OP_MULH;
508        0/1     ==>                multdiv_signed_mode_o = 2'b11;
509        0/1     ==>                illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
510                                 end
511                                 {7'b000_0001, 3'b010}: begin // mulhsu
512        0/1     ==>                multdiv_operator_o    = MD_OP_MULH;
513        0/1     ==>                multdiv_signed_mode_o = 2'b01;
514        0/1     ==>                illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
515                                 end
516                                 {7'b000_0001, 3'b011}: begin // mulhu
517        0/1     ==>                multdiv_operator_o    = MD_OP_MULH;
518        0/1     ==>                multdiv_signed_mode_o = 2'b00;
519        0/1     ==>                illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
520                                 end
521                                 {7'b000_0001, 3'b100}: begin // div
522        0/1     ==>                multdiv_operator_o    = MD_OP_DIV;
523        0/1     ==>                multdiv_signed_mode_o = 2'b11;
524        0/1     ==>                illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
525                                 end
526                                 {7'b000_0001, 3'b101}: begin // divu
527        0/1     ==>                multdiv_operator_o    = MD_OP_DIV;
528        0/1     ==>                multdiv_signed_mode_o = 2'b00;
529        0/1     ==>                illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
530                                 end
531                                 {7'b000_0001, 3'b110}: begin // rem
532        0/1     ==>                multdiv_operator_o    = MD_OP_REM;
533        0/1     ==>                multdiv_signed_mode_o = 2'b11;
534        0/1     ==>                illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
535                                 end
536                                 {7'b000_0001, 3'b111}: begin // remu
537        0/1     ==>                multdiv_operator_o    = MD_OP_REM;
538        0/1     ==>                multdiv_signed_mode_o = 2'b00;
539        0/1     ==>                illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
540                                 end
541                                 default: begin
542        0/1     ==>                illegal_insn = 1'b1;
543                                 end
544                               endcase
545                             end
546                           end
547                     
548                           /////////////
549                           // Special //
550                           /////////////
551                     
552                           OPCODE_MISC_MEM: begin
553        0/1     ==>          unique case (instr[14:12])
554                               3'b000: begin
555                                 // FENCE is treated as a NOP since all memory operations are already strictly ordered.
556        0/1     ==>              rf_we           = 1'b0;
557                               end
558                               3'b001: begin
559                                 // FENCE.I is implemented as a jump to the next PC, this gives the required flushing
560                                 // behaviour (iside prefetch buffer flushed and response to any outstanding iside
561                                 // requests will be ignored).
562                                 // If present, the ICache will also be flushed.
563        0/1     ==>              jump_in_dec_o   = 1'b1;
564                     
565        0/1     ==>              rf_we           = 1'b0;
566                     
567        0/1     ==>              if (instr_first_cycle_i) begin
568        0/1     ==>                jump_set_o       = 1'b1;
569        0/1     ==>                icache_inval_o   = 1'b1;
570                                 end
                   ==>  MISSING_ELSE
571                               end
572                               default: begin
573        0/1     ==>              illegal_insn       = 1'b1;
574                               end
575                             endcase
576                           end
577                     
578                           OPCODE_SYSTEM: begin
579        0/1     ==>          if (instr[14:12] == 3'b000) begin
580                               // non CSR related SYSTEM instructions
581        0/1     ==>            unique case (instr[31:20])
582                                 12'h000:  // ECALL
583                                   // environment (system) call
584        0/1     ==>                ecall_insn_o = 1'b1;
585                     
586                                 12'h001:  // ebreak
587                                   // debugger trap
588        0/1     ==>                ebrk_insn_o = 1'b1;
589                     
590                                 12'h302:  // mret
591        0/1     ==>                mret_insn_o = 1'b1;
592                     
593                                 12'h7b2:  // dret
594        0/1     ==>                dret_insn_o = 1'b1;
595                     
596                                 12'h105:  // wfi
597        0/1     ==>                wfi_insn_o = 1'b1;
598                     
599                                 default:
600        0/1     ==>                illegal_insn = 1'b1;
601                               endcase
602                     
603                               // rs1 and rd must be 0
604        0/1     ==>            if (instr_rs1 != 5'b0 || instr_rd != 5'b0) begin
605        0/1     ==>              illegal_insn = 1'b1;
606                               end
                   ==>  MISSING_ELSE
607                             end else begin
608                               // instruction to read/modify CSR
609        0/1     ==>            csr_access_o     = 1'b1;
610        0/1     ==>            rf_wdata_sel_o   = RF_WD_CSR;
611        0/1     ==>            rf_we            = 1'b1;
612                     
613        0/1     ==>            if (~instr[14]) begin
614        0/1     ==>              rf_ren_a_o         = 1'b1;
615                               end
                   ==>  MISSING_ELSE
616                     
617        0/1     ==>            unique case (instr[13:12])
618        0/1     ==>              2'b01:   csr_op = CSR_OP_WRITE;
619        0/1     ==>              2'b10:   csr_op = CSR_OP_SET;
620        0/1     ==>              2'b11:   csr_op = CSR_OP_CLEAR;
621        0/1     ==>              default: csr_illegal = 1'b1;
622                               endcase
623                     
624        0/1     ==>            illegal_insn = csr_illegal;
625                             end
626                     
627                           end
628                           default: begin
629        1/1                  illegal_insn = 1'b1;
630                           end
631                         endcase
632                     
633                         // make sure illegal compressed instructions cause illegal instruction exceptions
634        1/1              if (illegal_c_insn_i) begin
635        0/1     ==>        illegal_insn = 1'b1;
636                         end
                        MISSING_ELSE
637                     
638                         // make sure illegal instructions detected in the decoder do not propagate from decoder
639                         // into register file, LSU, EX, WB, CSRs, PC
640                         // NOTE: instructions can also be detected to be illegal inside the CSRs (upon accesses with
641                         // insufficient privileges), or when accessing non-available registers in RV32E,
642                         // these cases are not handled here
643        1/1              if (illegal_insn) begin
644        1/1                rf_we           = 1'b0;
645        1/1                data_req_o      = 1'b0;
646        1/1                data_we_o       = 1'b0;
647        1/1                jump_in_dec_o   = 1'b0;
648        1/1                jump_set_o      = 1'b0;
649        1/1                branch_in_dec_o = 1'b0;
650        1/1                csr_access_o    = 1'b0;
651                         end
                   ==>  MISSING_ELSE
652                       end
653                     
654                       /////////////////////////////
655                       // Decoder for ALU control //
656                       /////////////////////////////
657                     
658                       always_comb begin
659        1/1              alu_operator_o     = ALU_SLTU;
660        1/1              alu_op_a_mux_sel_o = OP_A_IMM;
661        1/1              alu_op_b_mux_sel_o = OP_B_IMM;
662                     
663        1/1              imm_a_mux_sel_o    = IMM_A_ZERO;
664        1/1              imm_b_mux_sel_o    = IMM_B_I;
665                     
666        1/1              bt_a_mux_sel_o     = OP_A_CURRPC;
667        1/1              bt_b_mux_sel_o     = IMM_B_I;
668                     
669                     
670        1/1              opcode_alu         = opcode_e'(instr_alu[6:0]);
671                     
672        1/1              use_rs3_d          = 1'b0;
673        1/1              alu_multicycle_o   = 1'b0;
674        1/1              mult_sel_o         = 1'b0;
675        1/1              div_sel_o          = 1'b0;
676                     
677        1/1              unique case (opcode_alu)
678                     
679                           ///////////
680                           // Jumps //
681                           ///////////
682                     
683                           OPCODE_JAL: begin // Jump and Link
684        0/1     ==>          if (BranchTargetALU) begin
685        0/1     ==>            bt_a_mux_sel_o = OP_A_CURRPC;
686        0/1     ==>            bt_b_mux_sel_o = IMM_B_J;
687                             end
                   ==>  MISSING_ELSE
688                     
689                             // Jumps take two cycles without the BTALU
690        0/1     ==>          if (instr_first_cycle_i && !BranchTargetALU) begin
691                               // Calculate jump target
692        0/1     ==>            alu_op_a_mux_sel_o  = OP_A_CURRPC;
693        0/1     ==>            alu_op_b_mux_sel_o  = OP_B_IMM;
694        0/1     ==>            imm_b_mux_sel_o     = IMM_B_J;
695        0/1     ==>            alu_operator_o      = ALU_ADD;
696                             end else begin
697                               // Calculate and store PC+4
698        0/1     ==>            alu_op_a_mux_sel_o  = OP_A_CURRPC;
699        0/1     ==>            alu_op_b_mux_sel_o  = OP_B_IMM;
700        0/1     ==>            imm_b_mux_sel_o     = IMM_B_INCR_PC;
701        0/1     ==>            alu_operator_o      = ALU_ADD;
702                             end
703                           end
704                     
705                           OPCODE_JALR: begin // Jump and Link Register
706        0/1     ==>          if (BranchTargetALU) begin
707        0/1     ==>            bt_a_mux_sel_o = OP_A_REG_A;
708        0/1     ==>            bt_b_mux_sel_o = IMM_B_I;
709                             end
                   ==>  MISSING_ELSE
710                     
711                             // Jumps take two cycles without the BTALU
712        0/1     ==>          if (instr_first_cycle_i && !BranchTargetALU) begin
713                               // Calculate jump target
714        0/1     ==>            alu_op_a_mux_sel_o  = OP_A_REG_A;
715        0/1     ==>            alu_op_b_mux_sel_o  = OP_B_IMM;
716        0/1     ==>            imm_b_mux_sel_o     = IMM_B_I;
717        0/1     ==>            alu_operator_o      = ALU_ADD;
718                             end else begin
719                               // Calculate and store PC+4
720        0/1     ==>            alu_op_a_mux_sel_o  = OP_A_CURRPC;
721        0/1     ==>            alu_op_b_mux_sel_o  = OP_B_IMM;
722        0/1     ==>            imm_b_mux_sel_o     = IMM_B_INCR_PC;
723        0/1     ==>            alu_operator_o      = ALU_ADD;
724                             end
725                           end
726                     
727                           OPCODE_BRANCH: begin // Branch
728                             // Check branch condition selection
729        0/1     ==>          unique case (instr_alu[14:12])
730        0/1     ==>            3'b000:  alu_operator_o = ALU_EQ;
731        0/1     ==>            3'b001:  alu_operator_o = ALU_NE;
732        0/1     ==>            3'b100:  alu_operator_o = ALU_LT;
733        0/1     ==>            3'b101:  alu_operator_o = ALU_GE;
734        0/1     ==>            3'b110:  alu_operator_o = ALU_LTU;
735        0/1     ==>            3'b111:  alu_operator_o = ALU_GEU;
736        0/1     ==>            default: ;
737                             endcase
738                     
739        0/1     ==>          if (BranchTargetALU) begin
740        0/1     ==>            bt_a_mux_sel_o = OP_A_CURRPC;
741                               // Not-taken branch will jump to next instruction (used in secure mode)
742        0/1     ==>            bt_b_mux_sel_o = branch_taken_i ? IMM_B_B : IMM_B_INCR_PC;
743                             end
                   ==>  MISSING_ELSE
744                     
745                             // Without branch target ALU, a branch is a two-stage operation using the Main ALU in both
746                             // stages
747        0/1     ==>          if (instr_first_cycle_i) begin
748                               // First evaluate the branch condition
749        0/1     ==>            alu_op_a_mux_sel_o  = OP_A_REG_A;
750        0/1     ==>            alu_op_b_mux_sel_o  = OP_B_REG_B;
751                             end else begin
752                               // Then calculate jump target
753        0/1     ==>            alu_op_a_mux_sel_o  = OP_A_CURRPC;
754        0/1     ==>            alu_op_b_mux_sel_o  = OP_B_IMM;
755                               // Not-taken branch will jump to next instruction (used in secure mode)
756        0/1     ==>            imm_b_mux_sel_o     = branch_taken_i ? IMM_B_B : IMM_B_INCR_PC;
757        0/1     ==>            alu_operator_o      = ALU_ADD;
758                             end
759                           end
760                     
761                           ////////////////
762                           // Load/store //
763                           ////////////////
764                     
765                           OPCODE_STORE: begin
766        0/1     ==>          alu_op_a_mux_sel_o = OP_A_REG_A;
767        0/1     ==>          alu_op_b_mux_sel_o = OP_B_REG_B;
768        0/1     ==>          alu_operator_o     = ALU_ADD;
769                     
770        0/1     ==>          if (!instr_alu[14]) begin
771                               // offset from immediate
772        0/1     ==>            imm_b_mux_sel_o     = IMM_B_S;
773        0/1     ==>            alu_op_b_mux_sel_o  = OP_B_IMM;
774                             end
                   ==>  MISSING_ELSE
775                           end
776                     
777                           OPCODE_LOAD: begin
778        0/1     ==>          alu_op_a_mux_sel_o  = OP_A_REG_A;
779                     
780                             // offset from immediate
781        0/1     ==>          alu_operator_o      = ALU_ADD;
782        0/1     ==>          alu_op_b_mux_sel_o  = OP_B_IMM;
783        0/1     ==>          imm_b_mux_sel_o     = IMM_B_I;
784                           end
785                     
786                           /////////
787                           // ALU //
788                           /////////
789                     
790                           OPCODE_LUI: begin  // Load Upper Immediate
791        0/1     ==>          alu_op_a_mux_sel_o  = OP_A_IMM;
792        0/1     ==>          alu_op_b_mux_sel_o  = OP_B_IMM;
793        0/1     ==>          imm_a_mux_sel_o     = IMM_A_ZERO;
794        0/1     ==>          imm_b_mux_sel_o     = IMM_B_U;
795        0/1     ==>          alu_operator_o      = ALU_ADD;
796                           end
797                     
798                           OPCODE_AUIPC: begin  // Add Upper Immediate to PC
799        0/1     ==>          alu_op_a_mux_sel_o  = OP_A_CURRPC;
800        0/1     ==>          alu_op_b_mux_sel_o  = OP_B_IMM;
801        0/1     ==>          imm_b_mux_sel_o     = IMM_B_U;
802        0/1     ==>          alu_operator_o      = ALU_ADD;
803                           end
804                     
805                           OPCODE_OP_IMM: begin // Register-Immediate ALU Operations
806        0/1     ==>          alu_op_a_mux_sel_o  = OP_A_REG_A;
807        0/1     ==>          alu_op_b_mux_sel_o  = OP_B_IMM;
808        0/1     ==>          imm_b_mux_sel_o     = IMM_B_I;
809                     
810        0/1     ==>          unique case (instr_alu[14:12])
811        0/1     ==>            3'b000: alu_operator_o = ALU_ADD;  // Add Immediate
812        0/1     ==>            3'b010: alu_operator_o = ALU_SLT;  // Set to one if Lower Than Immediate
813        0/1     ==>            3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned
814        0/1     ==>            3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate
815        0/1     ==>            3'b110: alu_operator_o = ALU_OR;   // Or with Immediate
816        0/1     ==>            3'b111: alu_operator_o = ALU_AND;  // And with Immediate
817                     
818                               3'b001: begin
819        0/1     ==>              if (RV32B != RV32BNone) begin
820        0/1     ==>                unique case (instr_alu[31:27])
821        0/1     ==>                  5'b0_0000: alu_operator_o = ALU_SLL;    // Shift Left Logical by Immediate
822        0/1     ==>                  5'b0_0100: alu_operator_o = ALU_SLO;    // Shift Left Ones by Immediate
823        0/1     ==>                  5'b0_1001: alu_operator_o = ALU_SBCLR;  // Clear bit specified by immediate
824        0/1     ==>                  5'b0_0101: alu_operator_o = ALU_SBSET;  // Set bit specified by immediate
825        0/1     ==>                  5'b0_1101: alu_operator_o = ALU_SBINV;  // Invert bit specified by immediate.
826                                     // Shuffle with Immediate Control Value
827        0/2     ==>                  5'b0_0001: if (instr_alu[26] == 0) alu_operator_o = ALU_SHFL;
                   ==>  MISSING_ELSE
828                                     5'b0_1100: begin
829        0/1     ==>                    unique case (instr_alu[26:20])
830        0/1     ==>                      7'b000_0000: alu_operator_o = ALU_CLZ;   // clz
831        0/1     ==>                      7'b000_0001: alu_operator_o = ALU_CTZ;   // ctz
832        0/1     ==>                      7'b000_0010: alu_operator_o = ALU_PCNT;  // pcnt
833        0/1     ==>                      7'b000_0100: alu_operator_o = ALU_SEXTB; // sext.b
834        0/1     ==>                      7'b000_0101: alu_operator_o = ALU_SEXTH; // sext.h
835                                         7'b001_0000: begin
836        0/1     ==>                        if (RV32B == RV32BFull) begin
837        0/1     ==>                          alu_operator_o = ALU_CRC32_B;  // crc32.b
838        0/1     ==>                          alu_multicycle_o = 1'b1;
839                                           end
                   ==>  MISSING_ELSE
840                                         end
841                                         7'b001_0001: begin
842        0/1     ==>                        if (RV32B == RV32BFull) begin
843        0/1     ==>                          alu_operator_o = ALU_CRC32_H;  // crc32.h
844        0/1     ==>                          alu_multicycle_o = 1'b1;
845                                           end
                   ==>  MISSING_ELSE
846                                         end
847                                         7'b001_0010: begin
848        0/1     ==>                        if (RV32B == RV32BFull) begin
849        0/1     ==>                          alu_operator_o = ALU_CRC32_W;  // crc32.w
850        0/1     ==>                          alu_multicycle_o = 1'b1;
851                                           end
                   ==>  MISSING_ELSE
852                                         end
853                                         7'b001_1000: begin
854        0/1     ==>                        if (RV32B == RV32BFull) begin
855        0/1     ==>                          alu_operator_o = ALU_CRC32C_B; // crc32c.b
856        0/1     ==>                          alu_multicycle_o = 1'b1;
857                                           end
                   ==>  MISSING_ELSE
858                                         end
859                                         7'b001_1001: begin
860        0/1     ==>                        if (RV32B == RV32BFull) begin
861        0/1     ==>                          alu_operator_o = ALU_CRC32C_H; // crc32c.h
862        0/1     ==>                          alu_multicycle_o = 1'b1;
863                                           end
                   ==>  MISSING_ELSE
864                                         end
865                                         7'b001_1010: begin
866        0/1     ==>                        if (RV32B == RV32BFull) begin
867        0/1     ==>                          alu_operator_o = ALU_CRC32C_W; // crc32c.w
868        0/1     ==>                          alu_multicycle_o = 1'b1;
869                                           end
                   ==>  MISSING_ELSE
870                                         end
871        0/1     ==>                      default: ;
872                                       endcase
873                                     end
874                     
875        0/1     ==>                  default: ;
876                                   endcase
877                                 end else begin
878        0/1     ==>                alu_operator_o = ALU_SLL; // Shift Left Logical by Immediate
879                                 end
880                               end
881                     
882                               3'b101: begin
883        0/1     ==>              if (RV32B != RV32BNone) begin
884        0/1     ==>                if (instr_alu[26] == 1'b1) begin
885        0/1     ==>                  alu_operator_o = ALU_FSR;
886        0/1     ==>                  alu_multicycle_o = 1'b1;
887        0/1     ==>                  if (instr_first_cycle_i) begin
888        0/1     ==>                    use_rs3_d = 1'b1;
889                                     end else begin
890        0/1     ==>                    use_rs3_d = 1'b0;
891                                     end
892                                   end else begin
893        0/1     ==>                  unique case (instr_alu[31:27])
894        0/1     ==>                    5'b0_0000: alu_operator_o = ALU_SRL;   // Shift Right Logical by Immediate
895        0/1     ==>                    5'b0_1000: alu_operator_o = ALU_SRA;   // Shift Right Arithmetically by Immediate
896        0/1     ==>                    5'b0_0100: alu_operator_o = ALU_SRO;   // Shift Right Ones by Immediate
897        0/1     ==>                    5'b0_1001: alu_operator_o = ALU_SBEXT; // Extract bit specified by immediate.
898                                       5'b0_1100: begin
899        0/1     ==>                      alu_operator_o = ALU_ROR;            // Rotate Right by Immediate
900        0/1     ==>                      alu_multicycle_o = 1'b1;
901                                       end
902        0/1     ==>                    5'b0_1101: alu_operator_o = ALU_GREV;  // General Reverse with Imm Control Val
903        0/1     ==>                    5'b0_0101: alu_operator_o = ALU_GORC;  // General Or-combine with Imm Control Val
904                                       // Unshuffle with Immediate Control Value
905                                       5'b0_0001: begin
906        0/1     ==>                      if (RV32B == RV32BFull) begin
907        0/2     ==>                        if (instr_alu[26] == 1'b0) alu_operator_o = ALU_UNSHFL;
                   ==>  MISSING_ELSE
908                                         end
                   ==>  MISSING_ELSE
909                                       end
910        0/1     ==>                    default: ;
911                                     endcase
912                                   end
913                     
914                                 end else begin
915        0/1     ==>                if (instr_alu[31:27] == 5'b0_0000) begin
916        0/1     ==>                  alu_operator_o = ALU_SRL;               // Shift Right Logical by Immediate
917        0/1     ==>                end else if (instr_alu[31:27] == 5'b0_1000) begin
918        0/1     ==>                  alu_operator_o = ALU_SRA;               // Shift Right Arithmetically by Immediate
919                                   end
                   ==>  MISSING_ELSE
920                                 end
921                               end
922                     
923        0/1     ==>            default: ;
924                             endcase
925                           end
926                     
927                           OPCODE_OP: begin  // Register-Register ALU operation
928        0/1     ==>          alu_op_a_mux_sel_o = OP_A_REG_A;
929        0/1     ==>          alu_op_b_mux_sel_o = OP_B_REG_B;
930                     
931        0/1     ==>          if (instr_alu[26]) begin
932        0/1     ==>            if (RV32B != RV32BNone) begin
933        0/1     ==>              unique case ({instr_alu[26:25], instr_alu[14:12]})
934                                   {2'b11, 3'b001}: begin
935        0/1     ==>                  alu_operator_o   = ALU_CMIX; // cmix
936        0/1     ==>                  alu_multicycle_o = 1'b1;
937        0/1     ==>                  if (instr_first_cycle_i) begin
938        0/1     ==>                    use_rs3_d = 1'b1;
939                                     end else begin
940        0/1     ==>                    use_rs3_d = 1'b0;
941                                     end
942                                   end
943                                   {2'b11, 3'b101}: begin
944        0/1     ==>                  alu_operator_o   = ALU_CMOV; // cmov
945        0/1     ==>                  alu_multicycle_o = 1'b1;
946        0/1     ==>                  if (instr_first_cycle_i) begin
947        0/1     ==>                    use_rs3_d = 1'b1;
948                                     end else begin
949        0/1     ==>                    use_rs3_d = 1'b0;
950                                     end
951                                   end
952                                   {2'b10, 3'b001}: begin
953        0/1     ==>                  alu_operator_o   = ALU_FSL;  // fsl
954        0/1     ==>                  alu_multicycle_o = 1'b1;
955        0/1     ==>                  if (instr_first_cycle_i) begin
956        0/1     ==>                    use_rs3_d = 1'b1;
957                                     end else begin
958        0/1     ==>                    use_rs3_d = 1'b0;
959                                     end
960                                   end
961                                   {2'b10, 3'b101}: begin
962        0/1     ==>                  alu_operator_o   = ALU_FSR;  // fsr
963        0/1     ==>                  alu_multicycle_o = 1'b1;
964        0/1     ==>                  if (instr_first_cycle_i) begin
965        0/1     ==>                    use_rs3_d = 1'b1;
966                                     end else begin
967        0/1     ==>                    use_rs3_d = 1'b0;
968                                     end
969                                   end
970        0/1     ==>                default: ;
971                                 endcase
972                               end
                   ==>  MISSING_ELSE
973                             end else begin
974        0/1     ==>            unique case ({instr_alu[31:25], instr_alu[14:12]})
975                                 // RV32I ALU operations
976        0/1     ==>              {7'b000_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add
977        0/1     ==>              {7'b010_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub
978        0/1     ==>              {7'b000_0000, 3'b010}: alu_operator_o = ALU_SLT;   // Set Lower Than
979        0/1     ==>              {7'b000_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned
980        0/1     ==>              {7'b000_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor
981        0/1     ==>              {7'b000_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or
982        0/1     ==>              {7'b000_0000, 3'b111}: alu_operator_o = ALU_AND;   // And
983        0/1     ==>              {7'b000_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical
984        0/1     ==>              {7'b000_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical
985        0/1     ==>              {7'b010_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic
986                     
987                                 // RV32B ALU Operations
988        0/2     ==>              {7'b001_0000, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_SLO;   // slo
                   ==>  MISSING_ELSE
989        0/2     ==>              {7'b001_0000, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_SRO;   // sro
                   ==>  MISSING_ELSE
990                                 {7'b011_0000, 3'b001}: begin
991        0/1     ==>                if (RV32B != RV32BNone) begin
992        0/1     ==>                  alu_operator_o = ALU_ROL;   // rol
993        0/1     ==>                  alu_multicycle_o = 1'b1;
994                                   end
                   ==>  MISSING_ELSE
995                                 end
996                                 {7'b011_0000, 3'b101}: begin
997        0/1     ==>                if (RV32B != RV32BNone) begin
998        0/1     ==>                  alu_operator_o = ALU_ROR;   // ror
999        0/1     ==>                  alu_multicycle_o = 1'b1;
1000                                  end
                   ==>  MISSING_ELSE
1001                                end
1002                    
1003       0/2     ==>              {7'b000_0101, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_MIN;    // min
                   ==>  MISSING_ELSE
1004       0/2     ==>              {7'b000_0101, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_MAX;    // max
                   ==>  MISSING_ELSE
1005       0/2     ==>              {7'b000_0101, 3'b110}: if (RV32B != RV32BNone) alu_operator_o = ALU_MINU;   // minu
                   ==>  MISSING_ELSE
1006       0/2     ==>              {7'b000_0101, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_MAXU;   // maxu
                   ==>  MISSING_ELSE
1007                    
1008       0/2     ==>              {7'b000_0100, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACK;   // pack
                   ==>  MISSING_ELSE
1009       0/2     ==>              {7'b010_0100, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACKU;  // packu
                   ==>  MISSING_ELSE
1010       0/2     ==>              {7'b000_0100, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACKH;  // packh
                   ==>  MISSING_ELSE
1011                    
1012       0/2     ==>              {7'b010_0000, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_XNOR;   // xnor
                   ==>  MISSING_ELSE
1013       0/2     ==>              {7'b010_0000, 3'b110}: if (RV32B != RV32BNone) alu_operator_o = ALU_ORN;    // orn
                   ==>  MISSING_ELSE
1014       0/2     ==>              {7'b010_0000, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_ANDN;   // andn
                   ==>  MISSING_ELSE
1015                    
1016                                // RV32B zbs
1017       0/2     ==>              {7'b010_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_SBCLR;  // sbclr
                   ==>  MISSING_ELSE
1018       0/2     ==>              {7'b001_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_SBSET;  // sbset
                   ==>  MISSING_ELSE
1019       0/2     ==>              {7'b011_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_SBINV;  // sbinv
                   ==>  MISSING_ELSE
1020       0/2     ==>              {7'b010_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_SBEXT;  // sbext
                   ==>  MISSING_ELSE
1021                    
1022                                // RV32B zbf
1023       0/2     ==>              {7'b010_0100, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_BFP;    // bfp
                   ==>  MISSING_ELSE
1024                    
1025                                // RV32B zbp
1026       0/2     ==>              {7'b011_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_GREV;   // grev
                   ==>  MISSING_ELSE
1027       0/2     ==>              {7'b001_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_GORC;   // grev
                   ==>  MISSING_ELSE
1028       0/2     ==>              {7'b000_0100, 3'b001}: if (RV32B == RV32BFull) alu_operator_o = ALU_SHFL;   // shfl
                   ==>  MISSING_ELSE
1029       0/2     ==>              {7'b000_0100, 3'b101}: if (RV32B == RV32BFull) alu_operator_o = ALU_UNSHFL; // unshfl
                   ==>  MISSING_ELSE
1030                    
1031                                // RV32B zbc
1032       0/2     ==>              {7'b000_0101, 3'b001}: if (RV32B == RV32BFull) alu_operator_o = ALU_CLMUL;  // clmul
                   ==>  MISSING_ELSE
1033       0/2     ==>              {7'b000_0101, 3'b010}: if (RV32B == RV32BFull) alu_operator_o = ALU_CLMULR; // clmulr
                   ==>  MISSING_ELSE
1034       0/2     ==>              {7'b000_0101, 3'b011}: if (RV32B == RV32BFull) alu_operator_o = ALU_CLMULH; // clmulh
                   ==>  MISSING_ELSE
1035                    
1036                                // RV32B zbe
1037                                {7'b010_0100, 3'b110}: begin
1038       0/1     ==>                if (RV32B == RV32BFull) begin
1039       0/1     ==>                  alu_operator_o = ALU_BDEP;   // bdep
1040       0/1     ==>                  alu_multicycle_o = 1'b1;
1041                                  end
                   ==>  MISSING_ELSE
1042                                end
1043                                {7'b000_0100, 3'b110}: begin
1044       0/1     ==>                if (RV32B == RV32BFull) begin
1045       0/1     ==>                  alu_operator_o = ALU_BEXT;   // bext
1046       0/1     ==>                  alu_multicycle_o = 1'b1;
1047                                  end
                   ==>  MISSING_ELSE
1048                                end
1049                    
1050                                // RV32M instructions, all use the same ALU operation
1051                                {7'b000_0001, 3'b000}: begin // mul
1052       0/1     ==>                alu_operator_o = ALU_ADD;
1053       0/1     ==>                mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1054                                end
1055                                {7'b000_0001, 3'b001}: begin // mulh
1056       0/1     ==>                alu_operator_o = ALU_ADD;
1057       0/1     ==>                mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1058                                end
1059                                {7'b000_0001, 3'b010}: begin // mulhsu
1060       0/1     ==>                alu_operator_o = ALU_ADD;
1061       0/1     ==>                mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1062                                end
1063                                {7'b000_0001, 3'b011}: begin // mulhu
1064       0/1     ==>                alu_operator_o = ALU_ADD;
1065       0/1     ==>                mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1066                                end
1067                                {7'b000_0001, 3'b100}: begin // div
1068       0/1     ==>                alu_operator_o = ALU_ADD;
1069       0/1     ==>                div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1070                                end
1071                                {7'b000_0001, 3'b101}: begin // divu
1072       0/1     ==>                alu_operator_o = ALU_ADD;
1073       0/1     ==>                div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1074                                end
1075                                {7'b000_0001, 3'b110}: begin // rem
1076       0/1     ==>                alu_operator_o = ALU_ADD;
1077       0/1     ==>                div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1078                                end
1079                                {7'b000_0001, 3'b111}: begin // remu
1080       0/1     ==>                alu_operator_o = ALU_ADD;
1081       0/1     ==>                div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1082                                end
1083                    
1084       0/1     ==>              default: ;
1085                              endcase
1086                            end
1087                          end
1088                    
1089                          /////////////
1090                          // Special //
1091                          /////////////
1092                    
1093                          OPCODE_MISC_MEM: begin
1094       0/1     ==>          unique case (instr_alu[14:12])
1095                              3'b000: begin
1096                                // FENCE is treated as a NOP since all memory operations are already strictly ordered.
1097       0/1     ==>              alu_operator_o     = ALU_ADD; // nop
1098       0/1     ==>              alu_op_a_mux_sel_o = OP_A_REG_A;
1099       0/1     ==>              alu_op_b_mux_sel_o = OP_B_IMM;
1100                              end
1101                              3'b001: begin
1102                                // FENCE.I will flush the IF stage, prefetch buffer and ICache if present.
1103       0/1     ==>              if (BranchTargetALU) begin
1104       0/1     ==>                bt_a_mux_sel_o     = OP_A_CURRPC;
1105       0/1     ==>                bt_b_mux_sel_o     = IMM_B_INCR_PC;
1106                                end else begin
1107       0/1     ==>                alu_op_a_mux_sel_o = OP_A_CURRPC;
1108       0/1     ==>                alu_op_b_mux_sel_o = OP_B_IMM;
1109       0/1     ==>                imm_b_mux_sel_o    = IMM_B_INCR_PC;
1110       0/1     ==>                alu_operator_o     = ALU_ADD;
1111                                end
1112                              end
1113       0/1     ==>            default: ;
1114                            endcase
1115                          end
1116                    
1117                          OPCODE_SYSTEM: begin
1118       0/1     ==>          if (instr_alu[14:12] == 3'b000) begin
1119                              // non CSR related SYSTEM instructions
1120       0/1     ==>            alu_op_a_mux_sel_o = OP_A_REG_A;
1121       0/1     ==>            alu_op_b_mux_sel_o = OP_B_IMM;
1122                            end else begin
1123                              // instruction to read/modify CSR
1124       0/1     ==>            alu_op_b_mux_sel_o = OP_B_IMM;
1125       0/1     ==>            imm_a_mux_sel_o    = IMM_A_Z;
1126       0/1     ==>            imm_b_mux_sel_o    = IMM_B_I;  // CSR address is encoded in I imm
1127                    
1128       0/1     ==>            if (instr_alu[14]) begin
1129                                // rs1 field is used as immediate
1130       0/1     ==>              alu_op_a_mux_sel_o = OP_A_IMM;
1131                              end else begin
1132       0/1     ==>              alu_op_a_mux_sel_o = OP_A_REG_A;
1133                              end
1134                            end
1135                    
1136                          end
1137       1/1                default: ;

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_decoder

               Total   Covered  Percent
Conditions         27        4    14.81
Logical            27        4    14.81
Non-Logical         0        0
Event               0        0

 LINE       195
 EXPRESSION (((csr_op == CSR_OP_SET) || (csr_op == CSR_OP_CLEAR)) && (instr_rs1 == '0))
             --------------------------1-------------------------    --------2--------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       195
 SUB-EXPRESSION ((csr_op == CSR_OP_SET) || (csr_op == CSR_OP_CLEAR))
                 -----------1----------    ------------2-----------

-1- -2- Status
 0   0  Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       364
 EXPRESSION ((instr[26:25] == 2'b0) ? 1'b0 : 1'b1)
             -----------1----------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       401
 EXPRESSION ((instr[26:25] == 2'b0) ? 1'b0 : 1'b1)
             -----------1----------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       604
 EXPRESSION ((instr_rs1 != 5'b0) || (instr_rd != 5'b0))
             ---------1---------    ---------2--------

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       690
 EXPRESSION (instr_first_cycle_i && ((!BranchTargetALU)))
             ---------1---------    ----------2---------

-1- -2- Status
 0   -  Not Covered
 1   -  Not Covered

 LINE       712
 EXPRESSION (instr_first_cycle_i && ((!BranchTargetALU)))
             ---------1---------    ----------2---------

-1- -2- Status
 0   -  Not Covered
 1   -  Not Covered

 LINE       742
 EXPRESSION (branch_taken_i ? IMM_B_B : IMM_B_INCR_PC)
             -------1------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       756
 EXPRESSION (branch_taken_i ? IMM_B_B : IMM_B_INCR_PC)
             -------1------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       169
 EXPRESSION (((use_rs3_q & (~instr_first_cycle_i))) ? instr_rs3 : instr_rs1)
             -------------------1------------------

-1- Status
 0  Covered
 1  Not Covered

 LINE       1142
 EXPRESSION (illegal_insn ? 1'b0 : mult_sel_o)
             ------1-----

-1- Status
 0  Not Covered
 1  Covered

 LINE       1143
 EXPRESSION (illegal_insn ? 1'b0 : div_sel_o)
             ------1-----

-1- Status
 0  Not Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_decoder
                Total Covered Percent 
Totals          68    0       0.00    
Total Bits      886   0       0.00    
Total Bits 0->1 443   0       0.00    
Total Bits 1->0 443   0       0.00    

                            
Ports          50  0 0.00   
Port Bits      650 0 0.00   
Port Bits 0->1 325 0 0.00   
Port Bits 1->0 325 0 0.00   

                              
Signals          18  0 0.00   
Signal Bits      236 0 0.00   
Signal Bits 0->1 118 0 0.00   
Signal Bits 1->0 118 0 0.00   

Port Details
                           Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                      No     No          No          INPUT     
rst_ni                     No     No          No          INPUT     
illegal_insn_o             No     No          No          OUTPUT    
ebrk_insn_o                No     No          No          OUTPUT    
mret_insn_o                No     No          No          OUTPUT    
dret_insn_o                No     No          No          OUTPUT    
ecall_insn_o               No     No          No          OUTPUT    
wfi_insn_o                 No     No          No          OUTPUT    
jump_set_o                 No     No          No          OUTPUT    
branch_taken_i             No     No          No          INPUT     
icache_inval_o             No     No          No          OUTPUT    
instr_first_cycle_i        No     No          No          INPUT     
instr_rdata_i[31:0]        No     No          No          INPUT     
instr_rdata_alu_i[31:0]    No     No          No          INPUT     
illegal_c_insn_i           No     No          No          INPUT     
imm_a_mux_sel_o            No     No          No          OUTPUT    
imm_b_mux_sel_o[2:0]       No     No          No          OUTPUT    
bt_a_mux_sel_o[1:0]        No     No          No          OUTPUT    
bt_b_mux_sel_o[2:0]        No     No          No          OUTPUT    
imm_i_type_o[31:0]         No     No          No          OUTPUT    
imm_s_type_o[31:0]         No     No          No          OUTPUT    
imm_b_type_o[31:0]         No     No          No          OUTPUT    
imm_u_type_o[31:0]         No     No          No          OUTPUT    
imm_j_type_o[31:0]         No     No          No          OUTPUT    
zimm_rs1_type_o[31:0]      No     No          No          OUTPUT    
rf_wdata_sel_o             No     No          No          OUTPUT    
rf_we_o                    No     No          No          OUTPUT    
rf_raddr_a_o[4:0]          No     No          No          OUTPUT    
rf_raddr_b_o[4:0]          No     No          No          OUTPUT    
rf_waddr_o[4:0]            No     No          No          OUTPUT    
rf_ren_a_o                 No     No          No          OUTPUT    
rf_ren_b_o                 No     No          No          OUTPUT    
alu_operator_o[5:0]        No     No          No          OUTPUT    
alu_op_a_mux_sel_o[1:0]    No     No          No          OUTPUT    
alu_op_b_mux_sel_o         No     No          No          OUTPUT    
alu_multicycle_o           No     No          No          OUTPUT    
mult_en_o                  No     No          No          OUTPUT    
div_en_o                   No     No          No          OUTPUT    
mult_sel_o                 No     No          No          OUTPUT    
div_sel_o                  No     No          No          OUTPUT    
multdiv_operator_o[1:0]    No     No          No          OUTPUT    
multdiv_signed_mode_o[1:0] No     No          No          OUTPUT    
csr_access_o               No     No          No          OUTPUT    
csr_op_o[1:0]              No     No          No          OUTPUT    
data_req_o                 No     No          No          OUTPUT    
data_we_o                  No     No          No          OUTPUT    
data_type_o[1:0]           No     No          No          OUTPUT    
data_sign_extension_o      No     No          No          OUTPUT    
jump_in_dec_o              No     No          No          OUTPUT    
branch_in_dec_o            No     No          No          OUTPUT    

Signal Details
                             Toggle Toggle 1->0 Toggle 0->1 
illegal_insn                 No     No          No          
illegal_reg_rv32e            No     No          No          
csr_illegal                  No     No          No          
rf_we                        No     No          No          
instr[31:0]                  No     No          No          
instr_alu[31:0]              No     No          No          
unused_instr_alu[9:0]        No     No          No          
instr_rs1[4:0]               No     No          No          
instr_rs2[4:0]               No     No          No          
instr_rs3[4:0]               No     No          No          
instr_rd[4:0]                No     No          No          
use_rs3_d                    No     No          No          
use_rs3_q                    No     No          No          
csr_op[1:0]                  No     No          No          
opcode[6:0]                  No     No          No          
opcode_alu[6:0]              No     No          No          
gen_no_rs3_flop.unused_clk   No     No          No          
gen_no_rs3_flop.unused_rst_n No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_decoder
         Line No. Total Covered Percent 
Branches          258   8       3.10    
TERNARY  169      2     1       50.00   
TERNARY  1142     2     1       50.00   
TERNARY  1143     2     1       50.00   
IF       195      2     1       50.00   
CASE     237      77    1       1.30    
IF       634      2     1       50.00   
IF       643      2     1       50.00   
CASE     677      169   1       0.59    


169          assign rf_raddr_a_o = (use_rs3_q & ~instr_first_cycle_i) ? instr_rs3 : instr_rs1; // rs3 / rs1
                                                                      -1-  
                                                                      ==>  
                                                                      ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


1142         assign mult_en_o = illegal_insn ? 1'b0 : mult_sel_o;
                                             -1-  
                                             ==>  
                                             ==>  

Branches:

-1- Status      
1   Covered     
0   Not Covered 


1143         assign div_en_o  = illegal_insn ? 1'b0 : div_sel_o;
                                             -1-  
                                             ==>  
                                             ==>  

Branches:

-1- Status      
1   Covered     
0   Not Covered 


195            if ((csr_op == CSR_OP_SET || csr_op == CSR_OP_CLEAR) &&
               -1-  
196                instr_rs1 == '0) begin
197              csr_op_o = CSR_OP_READ;
                 ==>
198            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


237            unique case (opcode)
                      -1-  
238        
239              ///////////
240              // Jumps //
241              ///////////
242        
243              OPCODE_JAL: begin   // Jump and Link
244                jump_in_dec_o      = 1'b1;
245        
246                if (instr_first_cycle_i) begin
                   -2-  
247                  // Calculate jump target (and store PC + 4 if BranchTargetALU is configured)
248                  rf_we            = BranchTargetALU;
                     ==>
249                  jump_set_o       = 1'b1;
250                end else begin
251                  // Calculate and store PC+4
252                  rf_we            = 1'b1;
                     ==>
253                end
254              end
255        
256              OPCODE_JALR: begin  // Jump and Link Register
257                jump_in_dec_o      = 1'b1;
258        
259                if (instr_first_cycle_i) begin
                   -3-  
260                  // Calculate jump target (and store PC + 4 if BranchTargetALU is configured)
261                  rf_we            = BranchTargetALU;
                     ==>
262                  jump_set_o       = 1'b1;
263                end else begin
264                  // Calculate and store PC+4
265                  rf_we            = 1'b1;
                     ==>
266                end
267                if (instr[14:12] != 3'b0) begin
                   -4-  
268                  illegal_insn = 1'b1;
                     ==>
269                end
                   MISSING_ELSE
                   ==>
270        
271                rf_ren_a_o = 1'b1;
272              end
273        
274              OPCODE_BRANCH: begin // Branch
275                branch_in_dec_o       = 1'b1;
276                // Check branch condition selection
277                unique case (instr[14:12])
                          -5-  
278                  3'b000,
279                  3'b001,
280                  3'b100,
281                  3'b101,
282                  3'b110,
283                  3'b111:  illegal_insn = 1'b0;
                     ==>
284                  default: illegal_insn = 1'b1;
                     ==>
285                endcase
286        
287                rf_ren_a_o = 1'b1;
288                rf_ren_b_o = 1'b1;
289              end
290        
291              ////////////////
292              // Load/store //
293              ////////////////
294        
295              OPCODE_STORE: begin
296                rf_ren_a_o         = 1'b1;
297                rf_ren_b_o         = 1'b1;
298                data_req_o         = 1'b1;
299                data_we_o          = 1'b1;
300        
301                if (instr[14]) begin
                   -6-  
302                  illegal_insn = 1'b1;
                     ==>
303                end
                   MISSING_ELSE
                   ==>
304        
305                // store size
306                unique case (instr[13:12])
                          -7-  
307                  2'b00:   data_type_o  = 2'b10; // sb
                     ==>
308                  2'b01:   data_type_o  = 2'b01; // sh
                     ==>
309                  2'b10:   data_type_o  = 2'b00; // sw
                     ==>
310                  default: illegal_insn = 1'b1;
                     ==>
311                endcase
312              end
313        
314              OPCODE_LOAD: begin
315                rf_ren_a_o          = 1'b1;
316                data_req_o          = 1'b1;
317                data_type_o         = 2'b00;
318        
319                // sign/zero extension
320                data_sign_extension_o = ~instr[14];
321        
322                // load size
323                unique case (instr[13:12])
                          -8-  
324                  2'b00: data_type_o = 2'b10; // lb(u)
                     ==>
325                  2'b01: data_type_o = 2'b01; // lh(u)
                     ==>
326                  2'b10: begin
327                    data_type_o = 2'b00;      // lw
328                    if (instr[14]) begin
                       -9-  
329                      illegal_insn = 1'b1;    // lwu does not exist
                         ==>
330                    end
                       MISSING_ELSE
                       ==>
331                  end
332                  default: begin
333                    illegal_insn = 1'b1;
                       ==>
334                  end
335                endcase
336              end
337        
338              /////////
339              // ALU //
340              /////////
341        
342              OPCODE_LUI: begin  // Load Upper Immediate
343                rf_we            = 1'b1;
                   ==>
344              end
345        
346              OPCODE_AUIPC: begin  // Add Upper Immediate to PC
347                rf_we            = 1'b1;
                   ==>
348              end
349        
350              OPCODE_OP_IMM: begin // Register-Immediate ALU Operations
351                rf_ren_a_o       = 1'b1;
352                rf_we            = 1'b1;
353        
354                unique case (instr[14:12])
                          -10-  
355                  3'b000,
356                  3'b010,
357                  3'b011,
358                  3'b100,
359                  3'b110,
360                  3'b111: illegal_insn = 1'b0;
                     ==>
361        
362                  3'b001: begin
363                    unique case (instr[31:27])
                              -11-  
364                      5'b0_0000: illegal_insn = (instr[26:25] == 2'b00) ? 1'b0 : 1'b1;        // slli
                                                                           -12-  
                                                                           ==>  
                                                                           ==>  
365                      5'b0_0100,                                                              // sloi
366                      5'b0_1001,                                                              // sbclri
367                      5'b0_0101,                                                              // sbseti
368                      5'b0_1101: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;           // sbinvi
                         ==>
369                      5'b0_0001: if (instr[26] == 1'b0) begin
                                    -13-  
370                        illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1;                    // shfl
                           ==>
371                      end else begin
372                        illegal_insn = 1'b1;
                           ==>
373                      end
374                      5'b0_1100: begin
375                        unique case(instr[26:20])
                                  -14-  
376                          7'b000_0000,                                                         // clz
377                          7'b000_0001,                                                         // ctz
378                          7'b000_0010,                                                         // pcnt
379                          7'b000_0100,                                                         // sext.b
380                          7'b000_0101: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;      // sext.h
                             ==>
381                          7'b001_0000,                                                         // crc32.b
382                          7'b001_0001,                                                         // crc32.h
383                          7'b001_0010,                                                         // crc32.w
384                          7'b001_1000,                                                         // crc32c.b
385                          7'b001_1001,                                                         // crc32c.h
386                          7'b001_1010: illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1;      // crc32c.w
                             ==>
387        
388                          default: illegal_insn = 1'b1;
                             ==>
389                        endcase
390                      end
391                      default : illegal_insn = 1'b1;
                         ==>
392                    endcase
393                  end
394        
395                  3'b101: begin
396                    if (instr[26]) begin
                       -15-  
397                      illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;                       // fsri
                         ==>
398                    end else begin
399                      unique case (instr[31:27])
                                -16-  
400                        5'b0_0000,                                                             // srli
401                        5'b0_1000: illegal_insn = (instr[26:25] == 2'b00) ? 1'b0 : 1'b1;       // srai
                                                                             -17-  
                                                                             ==>  
                                                                             ==>  
402        
403                        5'b0_0100,                                                             // sroi
404                        5'b0_1100,                                                             // rori
405                        5'b0_1001: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;          // sbexti
                           ==>
406        
407                        5'b0_1101: begin
408                          if ((RV32B == RV32BFull)) begin
                             -18-  
409                            illegal_insn = 1'b0;                                               // grevi
                               ==>
410                          end else begin
411                            unique case (instr[24:20])
                                      -19-  
412                              5'b11111,                                                        // rev
413                              5'b11000: illegal_insn = (RV32B == RV32BBalanced) ? 1'b0 : 1'b1; // rev8
                                 ==>
414        
415                              default: illegal_insn = 1'b1;
                                 ==>
416                            endcase
417                          end
418                        end
419                        5'b0_0101: begin
420                          if ((RV32B == RV32BFull)) begin
                             -20-  
421                            illegal_insn = 1'b0;                                              // gorci
                               ==>
422                          end else if (instr[24:20] == 5'b00111) begin
                                      -21-  
423                            illegal_insn = (RV32B == RV32BBalanced) ? 1'b0 : 1'b1;            // orc.b
                               ==>
424                          end else begin
425                            illegal_insn = 1'b1;
                               ==>
426                          end
427                        end
428                        5'b0_0001: begin
429                          if (instr[26] == 1'b0) begin
                             -22-  
430                            illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1;                // unshfl
                               ==>
431                          end else begin
432                            illegal_insn = 1'b1;
                               ==>
433                          end
434                        end
435        
436                        default: illegal_insn = 1'b1;
                           ==>
437                      endcase
438                    end
439                  end
440        
441                  default: illegal_insn = 1'b1;
                     ==>
442                endcase
443              end
444        
445              OPCODE_OP: begin  // Register-Register ALU operation
446                rf_ren_a_o      = 1'b1;
447                rf_ren_b_o      = 1'b1;
448                rf_we           = 1'b1;
449                if ({instr[26], instr[13:12]} == {1'b1, 2'b01}) begin
                   -23-  
450                  illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1; // cmix / cmov / fsl / fsr
                     ==>
451                end else begin
452                  unique case ({instr[31:25], instr[14:12]})
                            -24-  
453                    // RV32I ALU operations
454                    {7'b000_0000, 3'b000},
455                    {7'b010_0000, 3'b000},
456                    {7'b000_0000, 3'b010},
457                    {7'b000_0000, 3'b011},
458                    {7'b000_0000, 3'b100},
459                    {7'b000_0000, 3'b110},
460                    {7'b000_0000, 3'b111},
461                    {7'b000_0000, 3'b001},
462                    {7'b000_0000, 3'b101},
463                    {7'b010_0000, 3'b101}: illegal_insn = 1'b0;
                       ==>
464        
465                    // RV32B zbb
466                    {7'b010_0000, 3'b111}, // andn
467                    {7'b010_0000, 3'b110}, // orn
468                    {7'b010_0000, 3'b100}, // xnor
469                    {7'b001_0000, 3'b001}, // slo
470                    {7'b001_0000, 3'b101}, // sro
471                    {7'b011_0000, 3'b001}, // rol
472                    {7'b011_0000, 3'b101}, // ror
473                    {7'b000_0101, 3'b100}, // min
474                    {7'b000_0101, 3'b101}, // max
475                    {7'b000_0101, 3'b110}, // minu
476                    {7'b000_0101, 3'b111}, // maxu
477                    {7'b000_0100, 3'b100}, // pack
478                    {7'b010_0100, 3'b100}, // packu
479                    {7'b000_0100, 3'b111}, // packh
480                    // RV32B zbs
481                    {7'b010_0100, 3'b001}, // sbclr
482                    {7'b001_0100, 3'b001}, // sbset
483                    {7'b011_0100, 3'b001}, // sbinv
484                    {7'b010_0100, 3'b101}, // sbext
485                    // RV32B zbf
486                    {7'b010_0100, 3'b111}: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1; // bfp
                       ==>
487                    // RV32B zbe
488                    {7'b010_0100, 3'b110}, // bdep
489                    {7'b000_0100, 3'b110}, // bext
490                    // RV32B zbp
491                    {7'b011_0100, 3'b101}, // grev
492                    {7'b001_0100, 3'b101}, // gorc
493                    {7'b000_0100, 3'b001}, // shfl
494                    {7'b000_0100, 3'b101}, // unshfl
495                    // RV32B zbc
496                    {7'b000_0101, 3'b001}, // clmul
497                    {7'b000_0101, 3'b010}, // clmulr
498                    {7'b000_0101, 3'b011}: illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1; // clmulh
                       ==>
499        
500                    // RV32M instructions
501                    {7'b000_0001, 3'b000}: begin // mul
502                      multdiv_operator_o    = MD_OP_MULL;
                         ==>
503                      multdiv_signed_mode_o = 2'b00;
504                      illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
505                    end
506                    {7'b000_0001, 3'b001}: begin // mulh
507                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
508                      multdiv_signed_mode_o = 2'b11;
509                      illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
510                    end
511                    {7'b000_0001, 3'b010}: begin // mulhsu
512                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
513                      multdiv_signed_mode_o = 2'b01;
514                      illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
515                    end
516                    {7'b000_0001, 3'b011}: begin // mulhu
517                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
518                      multdiv_signed_mode_o = 2'b00;
519                      illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
520                    end
521                    {7'b000_0001, 3'b100}: begin // div
522                      multdiv_operator_o    = MD_OP_DIV;
                         ==>
523                      multdiv_signed_mode_o = 2'b11;
524                      illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
525                    end
526                    {7'b000_0001, 3'b101}: begin // divu
527                      multdiv_operator_o    = MD_OP_DIV;
                         ==>
528                      multdiv_signed_mode_o = 2'b00;
529                      illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
530                    end
531                    {7'b000_0001, 3'b110}: begin // rem
532                      multdiv_operator_o    = MD_OP_REM;
                         ==>
533                      multdiv_signed_mode_o = 2'b11;
534                      illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
535                    end
536                    {7'b000_0001, 3'b111}: begin // remu
537                      multdiv_operator_o    = MD_OP_REM;
                         ==>
538                      multdiv_signed_mode_o = 2'b00;
539                      illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;
540                    end
541                    default: begin
542                      illegal_insn = 1'b1;
                         ==>
543                    end
544                  endcase
545                end
546              end
547        
548              /////////////
549              // Special //
550              /////////////
551        
552              OPCODE_MISC_MEM: begin
553                unique case (instr[14:12])
                          -25-  
554                  3'b000: begin
555                    // FENCE is treated as a NOP since all memory operations are already strictly ordered.
556                    rf_we           = 1'b0;
                       ==>
557                  end
558                  3'b001: begin
559                    // FENCE.I is implemented as a jump to the next PC, this gives the required flushing
560                    // behaviour (iside prefetch buffer flushed and response to any outstanding iside
561                    // requests will be ignored).
562                    // If present, the ICache will also be flushed.
563                    jump_in_dec_o   = 1'b1;
564        
565                    rf_we           = 1'b0;
566        
567                    if (instr_first_cycle_i) begin
                       -26-  
568                      jump_set_o       = 1'b1;
                         ==>
569                      icache_inval_o   = 1'b1;
570                    end
                       MISSING_ELSE
                       ==>
571                  end
572                  default: begin
573                    illegal_insn       = 1'b1;
                       ==>
574                  end
575                endcase
576              end
577        
578              OPCODE_SYSTEM: begin
579                if (instr[14:12] == 3'b000) begin
                   -27-  
580                  // non CSR related SYSTEM instructions
581                  unique case (instr[31:20])
                            -28-  
582                    12'h000:  // ECALL
583                      // environment (system) call
584                      ecall_insn_o = 1'b1;
                         ==>
585        
586                    12'h001:  // ebreak
587                      // debugger trap
588                      ebrk_insn_o = 1'b1;
                         ==>
589        
590                    12'h302:  // mret
591                      mret_insn_o = 1'b1;
                         ==>
592        
593                    12'h7b2:  // dret
594                      dret_insn_o = 1'b1;
                         ==>
595        
596                    12'h105:  // wfi
597                      wfi_insn_o = 1'b1;
                         ==>
598        
599                    default:
600                      illegal_insn = 1'b1;
                         ==>
601                  endcase
602        
603                  // rs1 and rd must be 0
604                  if (instr_rs1 != 5'b0 || instr_rd != 5'b0) begin
                     -29-  
605                    illegal_insn = 1'b1;
                       ==>
606                  end
                     MISSING_ELSE
                     ==>
607                end else begin
608                  // instruction to read/modify CSR
609                  csr_access_o     = 1'b1;
610                  rf_wdata_sel_o   = RF_WD_CSR;
611                  rf_we            = 1'b1;
612        
613                  if (~instr[14]) begin
                     -30-  
614                    rf_ren_a_o         = 1'b1;
                       ==>
615                  end
                     MISSING_ELSE
                     ==>
616        
617                  unique case (instr[13:12])
                            -31-  
618                    2'b01:   csr_op = CSR_OP_WRITE;
                       ==>
619                    2'b10:   csr_op = CSR_OP_SET;
                       ==>
620                    2'b11:   csr_op = CSR_OP_CLEAR;
                       ==>
621                    default: csr_illegal = 1'b1;
                       ==>
622                  endcase
623        
624                  illegal_insn = csr_illegal;
625                end
626        
627              end
628              default: begin
629                illegal_insn = 1'b1;
                   ==>

Branches:

-1-              -2- -3- -4- -5-                                    -6- -7-     -8-     -9- -10-                                     -11-                                 -12- -13- -14-                                                               -15- -16-                        -17- -18- -19-               -20- -21- -22- -23- -24-                                                                                                                                                                                                                                                                                                                                                                                                              -25-    -26- -27- -28-     -29- -30- -31-    Status      
OPCODE_JAL       1   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_JAL       0   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_JALR      -   1   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_JALR      -   0   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_JALR      -   -   1   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_JALR      -   -   0   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_BRANCH    -   -   -   3'b0 3'b1 3'b100 3'b101 3'b110 3'b111  -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_BRANCH    -   -   -   default                                -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_STORE     -   -   -   -                                      1   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_STORE     -   -   -   -                                      0   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_STORE     -   -   -   -                                      -   2'b00   -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_STORE     -   -   -   -                                      -   2'b01   -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_STORE     -   -   -   -                                      -   2'b10   -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_STORE     -   -   -   -                                      -   default -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_LOAD      -   -   -   -                                      -   -       2'b00   -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_LOAD      -   -   -   -                                      -   -       2'b01   -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_LOAD      -   -   -   -                                      -   -       2'b10   1   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_LOAD      -   -   -   -                                      -   -       2'b10   0   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_LOAD      -   -   -   -                                      -   -       default -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_LUI       -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_AUIPC     -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b0 3'b010 3'b011 3'b100 3'b110 3'b111  -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   5'b00000                             1    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   5'b00000                             0    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   5'b00100 5'b01001 5'b00101 5'b01101  -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   5'b00001                             -    1    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   5'b00001                             -    0    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   5'b01100                             -    -    7'b0 7'b1 7'b0000010 7'b0000100 7'b0000101                         -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   5'b01100                             -    -    7'b0010000 7'b0010001 7'b0010010 7'b0011000 7'b0011001 7'b0011010  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   5'b01100                             -    -    default                                                            -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b001                                   default                              -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  1    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b0 5'b01000               1    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b0 5'b01000               0    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b00100 5'b01100 5'b01001  -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b01101                    -    1    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b01101                    -    0    5'b11111 5'b11000  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b01101                    -    0    default            -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b00101                    -    -    -                  1    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b00101                    -    -    -                  0    1    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b00101                    -    -    -                  0    0    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b00001                    -    -    -                  -    -    1    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    5'b00001                    -    -    -                  -    -    0    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   3'b101                                   -                                    -    -    -                                                                  0    default                     -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP_IMM    -   -   -   -                                      -   -       -       -   default                                  -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    1    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    CASEITEM-1: {7'b0, 3'b0} {7'b0100000, 3'b0} {7'b0, 3'b010} {7'b0, 3'b011} {7'b0, 3'b100} {7'b0, 3'b110} {7'b0, 3'b111} {7'b0, 3'b1} {7'b0, 3'b101} {7'b0100000, 3'b101}                                                                                                                                                                                                                                           -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    CASEITEM-2: {7'b0100000, 3'b111} {7'b0100000, 3'b110} {7'b0100000, 3'b100} {7'b0010000, 3'b1} {7'b0010000, 3'b101} {7'b0110000, 3'b1} {7'b0110000, 3'b101} {7'b0000101, 3'b100} {7'b0000101, 3'b101} {7'b0000101, 3'b110} {7'b0000101, 3'b111} {7'b0000100, 3'b100} {7'b0100100, 3'b100} {7'b0000100, 3'b111} {7'b0100100, 3'b1} {7'b0010100, 3'b1} {7'b0110100, 3'b1} {7'b0100100, 3'b101} {7'b0100100, 3'b111}  -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    CASEITEM-3: {7'b0100100, 3'b110} {7'b0000100, 3'b110} {7'b0110100, 3'b101} {7'b0010100, 3'b101} {7'b0000100, 3'b1} {7'b0000100, 3'b101} {7'b0000101, 3'b1} {7'b0000101, 3'b010} {7'b0000101, 3'b011}                                                                                                                                                                                                              -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    {7'b1, 3'b0}                                                                                                                                                                                                                                                                                                                                                                                                      -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    {7'b1, 3'b1}                                                                                                                                                                                                                                                                                                                                                                                                      -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    {7'b1, 3'b010}                                                                                                                                                                                                                                                                                                                                                                                                    -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    {7'b1, 3'b011}                                                                                                                                                                                                                                                                                                                                                                                                    -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    {7'b1, 3'b100}                                                                                                                                                                                                                                                                                                                                                                                                    -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    {7'b1, 3'b101}                                                                                                                                                                                                                                                                                                                                                                                                    -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    {7'b1, 3'b110}                                                                                                                                                                                                                                                                                                                                                                                                    -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    {7'b1, 3'b111}                                                                                                                                                                                                                                                                                                                                                                                                    -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    0    default                                                                                                                                                                                                                                                                                                                                                                                                           -       -    -    -        -    -    -       Not Covered 
OPCODE_MISC_MEM  -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 3'b000  -    -    -        -    -    -       Not Covered 
OPCODE_MISC_MEM  -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 3'b001  1    -    -        -    -    -       Not Covered 
OPCODE_MISC_MEM  -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 3'b001  0    -    -        -    -    -       Not Covered 
OPCODE_MISC_MEM  -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 default -    -    -        -    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    1    12'h000  -    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    1    12'h001  -    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    1    12'h302  -    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    1    12'h7b2  -    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    1    12'h105  -    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    1    default  -    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    1    -        1    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    1    -        0    -    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    0    -        -    1    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    0    -        -    0    -       Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    0    -        -    -    2'b01   Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    0    -        -    -    2'b10   Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    0    -        -    -    2'b11   Not Covered 
OPCODE_SYSTEM    -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    0    -        -    -    default Not Covered 
default          -   -   -   -                                      -   -       -       -   -                                        -                                    -    -    -                                                                  -    -                           -    -    -                  -    -    -    -    -                                                                                                                                                                                                                                                                                                                                                                                                                 -       -    -    -        -    -    -       Covered     


634            if (illegal_c_insn_i) begin
               -1-  
635              illegal_insn = 1'b1;
                 ==>
636            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


643            if (illegal_insn) begin
               -1-  
644              rf_we           = 1'b0;
                 ==>
645              data_req_o      = 1'b0;
646              data_we_o       = 1'b0;
647              jump_in_dec_o   = 1'b0;
648              jump_set_o      = 1'b0;
649              branch_in_dec_o = 1'b0;
650              csr_access_o    = 1'b0;
651            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


677            unique case (opcode_alu)
                      -1-  
678        
679              ///////////
680              // Jumps //
681              ///////////
682        
683              OPCODE_JAL: begin // Jump and Link
684                if (BranchTargetALU) begin
                   -2-  
685                  bt_a_mux_sel_o = OP_A_CURRPC;
                     ==>
686                  bt_b_mux_sel_o = IMM_B_J;
687                end
                   MISSING_ELSE
                   ==>
688        
689                // Jumps take two cycles without the BTALU
690                if (instr_first_cycle_i && !BranchTargetALU) begin
                   -3-  
691                  // Calculate jump target
692                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
                     ==>
693                  alu_op_b_mux_sel_o  = OP_B_IMM;
694                  imm_b_mux_sel_o     = IMM_B_J;
695                  alu_operator_o      = ALU_ADD;
696                end else begin
697                  // Calculate and store PC+4
698                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
                     ==>
699                  alu_op_b_mux_sel_o  = OP_B_IMM;
700                  imm_b_mux_sel_o     = IMM_B_INCR_PC;
701                  alu_operator_o      = ALU_ADD;
702                end
703              end
704        
705              OPCODE_JALR: begin // Jump and Link Register
706                if (BranchTargetALU) begin
                   -4-  
707                  bt_a_mux_sel_o = OP_A_REG_A;
                     ==>
708                  bt_b_mux_sel_o = IMM_B_I;
709                end
                   MISSING_ELSE
                   ==>
710        
711                // Jumps take two cycles without the BTALU
712                if (instr_first_cycle_i && !BranchTargetALU) begin
                   -5-  
713                  // Calculate jump target
714                  alu_op_a_mux_sel_o  = OP_A_REG_A;
                     ==>
715                  alu_op_b_mux_sel_o  = OP_B_IMM;
716                  imm_b_mux_sel_o     = IMM_B_I;
717                  alu_operator_o      = ALU_ADD;
718                end else begin
719                  // Calculate and store PC+4
720                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
                     ==>
721                  alu_op_b_mux_sel_o  = OP_B_IMM;
722                  imm_b_mux_sel_o     = IMM_B_INCR_PC;
723                  alu_operator_o      = ALU_ADD;
724                end
725              end
726        
727              OPCODE_BRANCH: begin // Branch
728                // Check branch condition selection
729                unique case (instr_alu[14:12])
                          -6-  
730                  3'b000:  alu_operator_o = ALU_EQ;
                     ==>
731                  3'b001:  alu_operator_o = ALU_NE;
                     ==>
732                  3'b100:  alu_operator_o = ALU_LT;
                     ==>
733                  3'b101:  alu_operator_o = ALU_GE;
                     ==>
734                  3'b110:  alu_operator_o = ALU_LTU;
                     ==>
735                  3'b111:  alu_operator_o = ALU_GEU;
                     ==>
736                  default: ;
                     ==>
737                endcase
738        
739                if (BranchTargetALU) begin
                   -7-  
740                  bt_a_mux_sel_o = OP_A_CURRPC;
741                  // Not-taken branch will jump to next instruction (used in secure mode)
742                  bt_b_mux_sel_o = branch_taken_i ? IMM_B_B : IMM_B_INCR_PC;
                                                     -8-  
                                                     ==>  
                                                     ==>  
743                end
                   MISSING_ELSE
                   ==>
744        
745                // Without branch target ALU, a branch is a two-stage operation using the Main ALU in both
746                // stages
747                if (instr_first_cycle_i) begin
                   -9-  
748                  // First evaluate the branch condition
749                  alu_op_a_mux_sel_o  = OP_A_REG_A;
                     ==>
750                  alu_op_b_mux_sel_o  = OP_B_REG_B;
751                end else begin
752                  // Then calculate jump target
753                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
754                  alu_op_b_mux_sel_o  = OP_B_IMM;
755                  // Not-taken branch will jump to next instruction (used in secure mode)
756                  imm_b_mux_sel_o     = branch_taken_i ? IMM_B_B : IMM_B_INCR_PC;
                                                          -10-  
                                                          ==>  
                                                          ==>  
757                  alu_operator_o      = ALU_ADD;
758                end
759              end
760        
761              ////////////////
762              // Load/store //
763              ////////////////
764        
765              OPCODE_STORE: begin
766                alu_op_a_mux_sel_o = OP_A_REG_A;
767                alu_op_b_mux_sel_o = OP_B_REG_B;
768                alu_operator_o     = ALU_ADD;
769        
770                if (!instr_alu[14]) begin
                   -11-  
771                  // offset from immediate
772                  imm_b_mux_sel_o     = IMM_B_S;
                     ==>
773                  alu_op_b_mux_sel_o  = OP_B_IMM;
774                end
                   MISSING_ELSE
                   ==>
775              end
776        
777              OPCODE_LOAD: begin
778                alu_op_a_mux_sel_o  = OP_A_REG_A;
                   ==>
779        
780                // offset from immediate
781                alu_operator_o      = ALU_ADD;
782                alu_op_b_mux_sel_o  = OP_B_IMM;
783                imm_b_mux_sel_o     = IMM_B_I;
784              end
785        
786              /////////
787              // ALU //
788              /////////
789        
790              OPCODE_LUI: begin  // Load Upper Immediate
791                alu_op_a_mux_sel_o  = OP_A_IMM;
                   ==>
792                alu_op_b_mux_sel_o  = OP_B_IMM;
793                imm_a_mux_sel_o     = IMM_A_ZERO;
794                imm_b_mux_sel_o     = IMM_B_U;
795                alu_operator_o      = ALU_ADD;
796              end
797        
798              OPCODE_AUIPC: begin  // Add Upper Immediate to PC
799                alu_op_a_mux_sel_o  = OP_A_CURRPC;
                   ==>
800                alu_op_b_mux_sel_o  = OP_B_IMM;
801                imm_b_mux_sel_o     = IMM_B_U;
802                alu_operator_o      = ALU_ADD;
803              end
804        
805              OPCODE_OP_IMM: begin // Register-Immediate ALU Operations
806                alu_op_a_mux_sel_o  = OP_A_REG_A;
807                alu_op_b_mux_sel_o  = OP_B_IMM;
808                imm_b_mux_sel_o     = IMM_B_I;
809        
810                unique case (instr_alu[14:12])
                          -12-  
811                  3'b000: alu_operator_o = ALU_ADD;  // Add Immediate
                     ==>
812                  3'b010: alu_operator_o = ALU_SLT;  // Set to one if Lower Than Immediate
                     ==>
813                  3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned
                     ==>
814                  3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate
                     ==>
815                  3'b110: alu_operator_o = ALU_OR;   // Or with Immediate
                     ==>
816                  3'b111: alu_operator_o = ALU_AND;  // And with Immediate
                     ==>
817        
818                  3'b001: begin
819                    if (RV32B != RV32BNone) begin
                       -13-  
820                      unique case (instr_alu[31:27])
                                -14-  
821                        5'b0_0000: alu_operator_o = ALU_SLL;    // Shift Left Logical by Immediate
                           ==>
822                        5'b0_0100: alu_operator_o = ALU_SLO;    // Shift Left Ones by Immediate
                           ==>
823                        5'b0_1001: alu_operator_o = ALU_SBCLR;  // Clear bit specified by immediate
                           ==>
824                        5'b0_0101: alu_operator_o = ALU_SBSET;  // Set bit specified by immediate
                           ==>
825                        5'b0_1101: alu_operator_o = ALU_SBINV;  // Invert bit specified by immediate.
                           ==>
826                        // Shuffle with Immediate Control Value
827                        5'b0_0001: if (instr_alu[26] == 0) alu_operator_o = ALU_SHFL;
                                      -15-  
                           ==>
                           MISSING_ELSE
                           ==>
828                        5'b0_1100: begin
829                          unique case (instr_alu[26:20])
                                    -16-  
830                            7'b000_0000: alu_operator_o = ALU_CLZ;   // clz
                               ==>
831                            7'b000_0001: alu_operator_o = ALU_CTZ;   // ctz
                               ==>
832                            7'b000_0010: alu_operator_o = ALU_PCNT;  // pcnt
                               ==>
833                            7'b000_0100: alu_operator_o = ALU_SEXTB; // sext.b
                               ==>
834                            7'b000_0101: alu_operator_o = ALU_SEXTH; // sext.h
                               ==>
835                            7'b001_0000: begin
836                              if (RV32B == RV32BFull) begin
                                 -17-  
837                                alu_operator_o = ALU_CRC32_B;  // crc32.b
                                   ==>
838                                alu_multicycle_o = 1'b1;
839                              end
                                 MISSING_ELSE
                                 ==>
840                            end
841                            7'b001_0001: begin
842                              if (RV32B == RV32BFull) begin
                                 -18-  
843                                alu_operator_o = ALU_CRC32_H;  // crc32.h
                                   ==>
844                                alu_multicycle_o = 1'b1;
845                              end
                                 MISSING_ELSE
                                 ==>
846                            end
847                            7'b001_0010: begin
848                              if (RV32B == RV32BFull) begin
                                 -19-  
849                                alu_operator_o = ALU_CRC32_W;  // crc32.w
                                   ==>
850                                alu_multicycle_o = 1'b1;
851                              end
                                 MISSING_ELSE
                                 ==>
852                            end
853                            7'b001_1000: begin
854                              if (RV32B == RV32BFull) begin
                                 -20-  
855                                alu_operator_o = ALU_CRC32C_B; // crc32c.b
                                   ==>
856                                alu_multicycle_o = 1'b1;
857                              end
                                 MISSING_ELSE
                                 ==>
858                            end
859                            7'b001_1001: begin
860                              if (RV32B == RV32BFull) begin
                                 -21-  
861                                alu_operator_o = ALU_CRC32C_H; // crc32c.h
                                   ==>
862                                alu_multicycle_o = 1'b1;
863                              end
                                 MISSING_ELSE
                                 ==>
864                            end
865                            7'b001_1010: begin
866                              if (RV32B == RV32BFull) begin
                                 -22-  
867                                alu_operator_o = ALU_CRC32C_W; // crc32c.w
                                   ==>
868                                alu_multicycle_o = 1'b1;
869                              end
                                 MISSING_ELSE
                                 ==>
870                            end
871                            default: ;
                               ==>
872                          endcase
873                        end
874        
875                        default: ;
                           ==>
876                      endcase
877                    end else begin
878                      alu_operator_o = ALU_SLL; // Shift Left Logical by Immediate
                         ==>
879                    end
880                  end
881        
882                  3'b101: begin
883                    if (RV32B != RV32BNone) begin
                       -23-  
884                      if (instr_alu[26] == 1'b1) begin
                         -24-  
885                        alu_operator_o = ALU_FSR;
886                        alu_multicycle_o = 1'b1;
887                        if (instr_first_cycle_i) begin
                           -25-  
888                          use_rs3_d = 1'b1;
                             ==>
889                        end else begin
890                          use_rs3_d = 1'b0;
                             ==>
891                        end
892                      end else begin
893                        unique case (instr_alu[31:27])
                                  -26-  
894                          5'b0_0000: alu_operator_o = ALU_SRL;   // Shift Right Logical by Immediate
                             ==>
895                          5'b0_1000: alu_operator_o = ALU_SRA;   // Shift Right Arithmetically by Immediate
                             ==>
896                          5'b0_0100: alu_operator_o = ALU_SRO;   // Shift Right Ones by Immediate
                             ==>
897                          5'b0_1001: alu_operator_o = ALU_SBEXT; // Extract bit specified by immediate.
                             ==>
898                          5'b0_1100: begin
899                            alu_operator_o = ALU_ROR;            // Rotate Right by Immediate
                               ==>
900                            alu_multicycle_o = 1'b1;
901                          end
902                          5'b0_1101: alu_operator_o = ALU_GREV;  // General Reverse with Imm Control Val
                             ==>
903                          5'b0_0101: alu_operator_o = ALU_GORC;  // General Or-combine with Imm Control Val
                             ==>
904                          // Unshuffle with Immediate Control Value
905                          5'b0_0001: begin
906                            if (RV32B == RV32BFull) begin
                               -27-  
907                              if (instr_alu[26] == 1'b0) alu_operator_o = ALU_UNSHFL;
                                 -28-  
                                 ==>
                                 MISSING_ELSE
                                 ==>
908                            end
                               MISSING_ELSE
                               ==>
909                          end
910                          default: ;
                             ==>
911                        endcase
912                      end
913        
914                    end else begin
915                      if (instr_alu[31:27] == 5'b0_0000) begin
                         -29-  
916                        alu_operator_o = ALU_SRL;               // Shift Right Logical by Immediate
                           ==>
917                      end else if (instr_alu[31:27] == 5'b0_1000) begin
                                  -30-  
918                        alu_operator_o = ALU_SRA;               // Shift Right Arithmetically by Immediate
                           ==>
919                      end
                         MISSING_ELSE
                         ==>
920                    end
921                  end
922        
923                  default: ;
                     ==>
924                endcase
925              end
926        
927              OPCODE_OP: begin  // Register-Register ALU operation
928                alu_op_a_mux_sel_o = OP_A_REG_A;
929                alu_op_b_mux_sel_o = OP_B_REG_B;
930        
931                if (instr_alu[26]) begin
                   -31-  
932                  if (RV32B != RV32BNone) begin
                     -32-  
933                    unique case ({instr_alu[26:25], instr_alu[14:12]})
                              -33-  
934                      {2'b11, 3'b001}: begin
935                        alu_operator_o   = ALU_CMIX; // cmix
936                        alu_multicycle_o = 1'b1;
937                        if (instr_first_cycle_i) begin
                           -34-  
938                          use_rs3_d = 1'b1;
                             ==>
939                        end else begin
940                          use_rs3_d = 1'b0;
                             ==>
941                        end
942                      end
943                      {2'b11, 3'b101}: begin
944                        alu_operator_o   = ALU_CMOV; // cmov
945                        alu_multicycle_o = 1'b1;
946                        if (instr_first_cycle_i) begin
                           -35-  
947                          use_rs3_d = 1'b1;
                             ==>
948                        end else begin
949                          use_rs3_d = 1'b0;
                             ==>
950                        end
951                      end
952                      {2'b10, 3'b001}: begin
953                        alu_operator_o   = ALU_FSL;  // fsl
954                        alu_multicycle_o = 1'b1;
955                        if (instr_first_cycle_i) begin
                           -36-  
956                          use_rs3_d = 1'b1;
                             ==>
957                        end else begin
958                          use_rs3_d = 1'b0;
                             ==>
959                        end
960                      end
961                      {2'b10, 3'b101}: begin
962                        alu_operator_o   = ALU_FSR;  // fsr
963                        alu_multicycle_o = 1'b1;
964                        if (instr_first_cycle_i) begin
                           -37-  
965                          use_rs3_d = 1'b1;
                             ==>
966                        end else begin
967                          use_rs3_d = 1'b0;
                             ==>
968                        end
969                      end
970                      default: ;
                         ==>
971                    endcase
972                  end
                     MISSING_ELSE
                     ==>
973                end else begin
974                  unique case ({instr_alu[31:25], instr_alu[14:12]})
                            -38-  
975                    // RV32I ALU operations
976                    {7'b000_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add
                       ==>
977                    {7'b010_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub
                       ==>
978                    {7'b000_0000, 3'b010}: alu_operator_o = ALU_SLT;   // Set Lower Than
                       ==>
979                    {7'b000_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned
                       ==>
980                    {7'b000_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor
                       ==>
981                    {7'b000_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or
                       ==>
982                    {7'b000_0000, 3'b111}: alu_operator_o = ALU_AND;   // And
                       ==>
983                    {7'b000_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical
                       ==>
984                    {7'b000_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical
                       ==>
985                    {7'b010_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic
                       ==>
986        
987                    // RV32B ALU Operations
988                    {7'b001_0000, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_SLO;   // slo
                                              -39-  
                       ==>
                       MISSING_ELSE
                       ==>
989                    {7'b001_0000, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_SRO;   // sro
                                              -40-  
                       ==>
                       MISSING_ELSE
                       ==>
990                    {7'b011_0000, 3'b001}: begin
991                      if (RV32B != RV32BNone) begin
                         -41-  
992                        alu_operator_o = ALU_ROL;   // rol
                           ==>
993                        alu_multicycle_o = 1'b1;
994                      end
                         MISSING_ELSE
                         ==>
995                    end
996                    {7'b011_0000, 3'b101}: begin
997                      if (RV32B != RV32BNone) begin
                         -42-  
998                        alu_operator_o = ALU_ROR;   // ror
                           ==>
999                        alu_multicycle_o = 1'b1;
1000                     end
                         MISSING_ELSE
                         ==>
1001                   end
1002       
1003                   {7'b000_0101, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_MIN;    // min
                                              -43-  
                       ==>
                       MISSING_ELSE
                       ==>
1004                   {7'b000_0101, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_MAX;    // max
                                              -44-  
                       ==>
                       MISSING_ELSE
                       ==>
1005                   {7'b000_0101, 3'b110}: if (RV32B != RV32BNone) alu_operator_o = ALU_MINU;   // minu
                                              -45-  
                       ==>
                       MISSING_ELSE
                       ==>
1006                   {7'b000_0101, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_MAXU;   // maxu
                                              -46-  
                       ==>
                       MISSING_ELSE
                       ==>
1007       
1008                   {7'b000_0100, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACK;   // pack
                                              -47-  
                       ==>
                       MISSING_ELSE
                       ==>
1009                   {7'b010_0100, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACKU;  // packu
                                              -48-  
                       ==>
                       MISSING_ELSE
                       ==>
1010                   {7'b000_0100, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACKH;  // packh
                                              -49-  
                       ==>
                       MISSING_ELSE
                       ==>
1011       
1012                   {7'b010_0000, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_XNOR;   // xnor
                                              -50-  
                       ==>
                       MISSING_ELSE
                       ==>
1013                   {7'b010_0000, 3'b110}: if (RV32B != RV32BNone) alu_operator_o = ALU_ORN;    // orn
                                              -51-  
                       ==>
                       MISSING_ELSE
                       ==>
1014                   {7'b010_0000, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_ANDN;   // andn
                                              -52-  
                       ==>
                       MISSING_ELSE
                       ==>
1015       
1016                   // RV32B zbs
1017                   {7'b010_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_SBCLR;  // sbclr
                                              -53-  
                       ==>
                       MISSING_ELSE
                       ==>
1018                   {7'b001_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_SBSET;  // sbset
                                              -54-  
                       ==>
                       MISSING_ELSE
                       ==>
1019                   {7'b011_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_SBINV;  // sbinv
                                              -55-  
                       ==>
                       MISSING_ELSE
                       ==>
1020                   {7'b010_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_SBEXT;  // sbext
                                              -56-  
                       ==>
                       MISSING_ELSE
                       ==>
1021       
1022                   // RV32B zbf
1023                   {7'b010_0100, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_BFP;    // bfp
                                              -57-  
                       ==>
                       MISSING_ELSE
                       ==>
1024       
1025                   // RV32B zbp
1026                   {7'b011_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_GREV;   // grev
                                              -58-  
                       ==>
                       MISSING_ELSE
                       ==>
1027                   {7'b001_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_GORC;   // grev
                                              -59-  
                       ==>
                       MISSING_ELSE
                       ==>
1028                   {7'b000_0100, 3'b001}: if (RV32B == RV32BFull) alu_operator_o = ALU_SHFL;   // shfl
                                              -60-  
                       ==>
                       MISSING_ELSE
                       ==>
1029                   {7'b000_0100, 3'b101}: if (RV32B == RV32BFull) alu_operator_o = ALU_UNSHFL; // unshfl
                                              -61-  
                       ==>
                       MISSING_ELSE
                       ==>
1030       
1031                   // RV32B zbc
1032                   {7'b000_0101, 3'b001}: if (RV32B == RV32BFull) alu_operator_o = ALU_CLMUL;  // clmul
                                              -62-  
                       ==>
                       MISSING_ELSE
                       ==>
1033                   {7'b000_0101, 3'b010}: if (RV32B == RV32BFull) alu_operator_o = ALU_CLMULR; // clmulr
                                              -63-  
                       ==>
                       MISSING_ELSE
                       ==>
1034                   {7'b000_0101, 3'b011}: if (RV32B == RV32BFull) alu_operator_o = ALU_CLMULH; // clmulh
                                              -64-  
                       ==>
                       MISSING_ELSE
                       ==>
1035       
1036                   // RV32B zbe
1037                   {7'b010_0100, 3'b110}: begin
1038                     if (RV32B == RV32BFull) begin
                         -65-  
1039                       alu_operator_o = ALU_BDEP;   // bdep
                           ==>
1040                       alu_multicycle_o = 1'b1;
1041                     end
                         MISSING_ELSE
                         ==>
1042                   end
1043                   {7'b000_0100, 3'b110}: begin
1044                     if (RV32B == RV32BFull) begin
                         -66-  
1045                       alu_operator_o = ALU_BEXT;   // bext
                           ==>
1046                       alu_multicycle_o = 1'b1;
1047                     end
                         MISSING_ELSE
                         ==>
1048                   end
1049       
1050                   // RV32M instructions, all use the same ALU operation
1051                   {7'b000_0001, 3'b000}: begin // mul
1052                     alu_operator_o = ALU_ADD;
                         ==>
1053                     mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1054                   end
1055                   {7'b000_0001, 3'b001}: begin // mulh
1056                     alu_operator_o = ALU_ADD;
                         ==>
1057                     mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1058                   end
1059                   {7'b000_0001, 3'b010}: begin // mulhsu
1060                     alu_operator_o = ALU_ADD;
                         ==>
1061                     mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1062                   end
1063                   {7'b000_0001, 3'b011}: begin // mulhu
1064                     alu_operator_o = ALU_ADD;
                         ==>
1065                     mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1066                   end
1067                   {7'b000_0001, 3'b100}: begin // div
1068                     alu_operator_o = ALU_ADD;
                         ==>
1069                     div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1070                   end
1071                   {7'b000_0001, 3'b101}: begin // divu
1072                     alu_operator_o = ALU_ADD;
                         ==>
1073                     div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1074                   end
1075                   {7'b000_0001, 3'b110}: begin // rem
1076                     alu_operator_o = ALU_ADD;
                         ==>
1077                     div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1078                   end
1079                   {7'b000_0001, 3'b111}: begin // remu
1080                     alu_operator_o = ALU_ADD;
                         ==>
1081                     div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;
1082                   end
1083       
1084                   default: ;
                       ==>
1085                 endcase
1086               end
1087             end
1088       
1089             /////////////
1090             // Special //
1091             /////////////
1092       
1093             OPCODE_MISC_MEM: begin
1094               unique case (instr_alu[14:12])
                          -67-  
1095                 3'b000: begin
1096                   // FENCE is treated as a NOP since all memory operations are already strictly ordered.
1097                   alu_operator_o     = ALU_ADD; // nop
                       ==>
1098                   alu_op_a_mux_sel_o = OP_A_REG_A;
1099                   alu_op_b_mux_sel_o = OP_B_IMM;
1100                 end
1101                 3'b001: begin
1102                   // FENCE.I will flush the IF stage, prefetch buffer and ICache if present.
1103                   if (BranchTargetALU) begin
                       -68-  
1104                     bt_a_mux_sel_o     = OP_A_CURRPC;
                         ==>
1105                     bt_b_mux_sel_o     = IMM_B_INCR_PC;
1106                   end else begin
1107                     alu_op_a_mux_sel_o = OP_A_CURRPC;
                         ==>
1108                     alu_op_b_mux_sel_o = OP_B_IMM;
1109                     imm_b_mux_sel_o    = IMM_B_INCR_PC;
1110                     alu_operator_o     = ALU_ADD;
1111                   end
1112                 end
1113                 default: ;
                     ==>
1114               endcase
1115             end
1116       
1117             OPCODE_SYSTEM: begin
1118               if (instr_alu[14:12] == 3'b000) begin
                   -69-  
1119                 // non CSR related SYSTEM instructions
1120                 alu_op_a_mux_sel_o = OP_A_REG_A;
                     ==>
1121                 alu_op_b_mux_sel_o = OP_B_IMM;
1122               end else begin
1123                 // instruction to read/modify CSR
1124                 alu_op_b_mux_sel_o = OP_B_IMM;
1125                 imm_a_mux_sel_o    = IMM_A_Z;
1126                 imm_b_mux_sel_o    = IMM_B_I;  // CSR address is encoded in I imm
1127       
1128                 if (instr_alu[14]) begin
                     -70-  
1129                   // rs1 field is used as immediate
1130                   alu_op_a_mux_sel_o = OP_A_IMM;
                       ==>
1131                 end else begin
1132                   alu_op_a_mux_sel_o = OP_A_REG_A;
                       ==>
1133                 end
1134               end
1135       
1136             end
1137             default: ;
                 ==>

Branches:

Branch                                                                                                                    Status      
(1.OPCODE_JAL )->(2)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                       Not Covered 
(1.OPCODE_JAL )->(!2)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                      Not Covered 
(1.OPCODE_JAL )->(3)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                       Not Covered 
(1.OPCODE_JAL )->(!3)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                      Not Covered 
(1.OPCODE_JALR )->(4)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                      Not Covered 
(1.OPCODE_JALR )->(!4)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                     Not Covered 
(1.OPCODE_JALR )->(5)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                      Not Covered 
(1.OPCODE_JALR )->(!5)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                     Not Covered 
(1.OPCODE_BRANCH )->(6.3'b000 )->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_BRANCH )->(6.3'b001 )->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_BRANCH )->(6.3'b100 )->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_BRANCH )->(6.3'b101 )->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_BRANCH )->(6.3'b110 )->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_BRANCH )->(6.3'b111 )->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_BRANCH )->(6.default)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_BRANCH )->(6.-)->(7)->(8)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                               Not Covered 
(1.OPCODE_BRANCH )->(6.-)->(7)->(!8)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                              Not Covered 
(1.OPCODE_BRANCH )->(6.-)->(!7)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_BRANCH )->(6.-)->(9)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                    Not Covered 
(1.OPCODE_BRANCH )->(6.-)->(!9)->(10)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                             Not Covered 
(1.OPCODE_BRANCH )->(6.-)->(!9)->(!10)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                            Not Covered 
(1.OPCODE_STORE )->(6.-)->(11)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                    Not Covered 
(1.OPCODE_STORE )->(6.-)->(!11)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_LOAD )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                           Not Covered 
(1.OPCODE_LUI )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                            Not Covered 
(1.OPCODE_AUIPC )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                          Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b000 )->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b010 )->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b011 )->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b100 )->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b110 )->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b111 )->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b00000 )->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b00100 )->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01001 )->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b00101 )->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01101 )->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b00001 )->(15)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)               Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b00001 )->(!15)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0000000 )->(26.-)->(33.-)->(38.-)->(67.-)           Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0000001 )->(26.-)->(33.-)->(38.-)->(67.-)           Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0000010 )->(26.-)->(33.-)->(38.-)->(67.-)           Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0000100 )->(26.-)->(33.-)->(38.-)->(67.-)           Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0000101 )->(26.-)->(33.-)->(38.-)->(67.-)           Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0010000 )->(17)->(26.-)->(33.-)->(38.-)->(67.-)     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0010000 )->(!17)->(26.-)->(33.-)->(38.-)->(67.-)    Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0010001 )->(18)->(26.-)->(33.-)->(38.-)->(67.-)     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0010001 )->(!18)->(26.-)->(33.-)->(38.-)->(67.-)    Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0010010 )->(19)->(26.-)->(33.-)->(38.-)->(67.-)     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0010010 )->(!19)->(26.-)->(33.-)->(38.-)->(67.-)    Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0011000 )->(20)->(26.-)->(33.-)->(38.-)->(67.-)     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0011000 )->(!20)->(26.-)->(33.-)->(38.-)->(67.-)    Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0011001 )->(21)->(26.-)->(33.-)->(38.-)->(67.-)     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0011001 )->(!21)->(26.-)->(33.-)->(38.-)->(67.-)    Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0011010 )->(22)->(26.-)->(33.-)->(38.-)->(67.-)     Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.7'b0011010 )->(!22)->(26.-)->(33.-)->(38.-)->(67.-)    Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.5'b01100 )->(16.default)->(26.-)->(33.-)->(38.-)->(67.-)               Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(13)->(14.default)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                       Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b001 )->(!13)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                            Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(24)->(25)->(26.-)->(33.-)->(38.-)->(67.-)                 Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(24)->(!25)->(26.-)->(33.-)->(38.-)->(67.-)                Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b00000 )->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b01000 )->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b00100 )->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b01001 )->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b01100 )->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b01101 )->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b00101 )->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b00001 )->(27)->(28)->(33.-)->(38.-)->(67.-)  Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b00001 )->(27)->(!28)->(33.-)->(38.-)->(67.-) Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.5'b00001 )->(!27)->(33.-)->(38.-)->(67.-)       Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(23)->(!24)->(26.default)->(33.-)->(38.-)->(67.-)                Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(!23)->(26.-)->(29)->(33.-)->(38.-)->(67.-)                      Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(!23)->(26.-)->(!29)->(30)->(33.-)->(38.-)->(67.-)               Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.3'b101 )->(14.-)->(16.-)->(!23)->(26.-)->(!29)->(!30)->(33.-)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP_IMM )->(6.-)->(12.default)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                   Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.{2'b11, 3'b1} )->(34)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.{2'b11, 3'b1} )->(!34)->(38.-)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.{2'b11, 3'b101} )->(35)->(38.-)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.{2'b11, 3'b101} )->(!35)->(38.-)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.{2'b10, 3'b1} )->(36)->(38.-)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.{2'b10, 3'b1} )->(!36)->(38.-)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.{2'b10, 3'b101} )->(37)->(38.-)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.{2'b10, 3'b101} )->(!37)->(38.-)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(32)->(33.default)->(38.-)->(67.-)                           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(31)->(!32)->(33.-)->(38.-)->(67.-)                                Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0, 3'b0} )->(67.-)                          Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100000, 3'b0} )->(67.-)                    Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0, 3'b010} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0, 3'b011} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0, 3'b100} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0, 3'b110} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0, 3'b111} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0, 3'b1} )->(67.-)                          Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0, 3'b101} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100000, 3'b101} )->(67.-)                  Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0010000, 3'b1} )->(39)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0010000, 3'b1} )->(!39)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0010000, 3'b101} )->(40)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0010000, 3'b101} )->(!40)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0110000, 3'b1} )->(41)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0110000, 3'b1} )->(!41)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0110000, 3'b101} )->(42)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0110000, 3'b101} )->(!42)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b100} )->(43)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b100} )->(!43)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b101} )->(44)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b101} )->(!44)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b110} )->(45)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b110} )->(!45)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b111} )->(46)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b111} )->(!46)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b100} )->(47)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b100} )->(!47)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b100} )->(48)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b100} )->(!48)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b111} )->(49)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b111} )->(!49)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100000, 3'b100} )->(50)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100000, 3'b100} )->(!50)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100000, 3'b110} )->(51)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100000, 3'b110} )->(!51)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100000, 3'b111} )->(52)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100000, 3'b111} )->(!52)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b1} )->(53)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b1} )->(!53)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0010100, 3'b1} )->(54)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0010100, 3'b1} )->(!54)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0110100, 3'b1} )->(55)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0110100, 3'b1} )->(!55)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b101} )->(56)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b101} )->(!56)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b111} )->(57)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b111} )->(!57)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0110100, 3'b101} )->(58)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0110100, 3'b101} )->(!58)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0010100, 3'b101} )->(59)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0010100, 3'b101} )->(!59)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b1} )->(60)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b1} )->(!60)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b101} )->(61)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b101} )->(!61)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b1} )->(62)->(67.-)              Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b1} )->(!62)->(67.-)             Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b010} )->(63)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b010} )->(!63)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b011} )->(64)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000101, 3'b011} )->(!64)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b110} )->(65)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0100100, 3'b110} )->(!65)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b110} )->(66)->(67.-)            Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b0000100, 3'b110} )->(!66)->(67.-)           Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b1, 3'b0} )->(67.-)                          Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b1, 3'b1} )->(67.-)                          Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b1, 3'b010} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b1, 3'b011} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b1, 3'b100} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b1, 3'b101} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b1, 3'b110} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.{7'b1, 3'b111} )->(67.-)                        Not Covered 
(1.OPCODE_OP )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(!31)->(33.-)->(38.default)->(67.-)                                Not Covered 
(1.OPCODE_MISC_MEM )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.3'b000 )                                 Not Covered 
(1.OPCODE_MISC_MEM )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.3'b001 )->(68)                           Not Covered 
(1.OPCODE_MISC_MEM )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.3'b001 )->(!68)                          Not Covered 
(1.OPCODE_MISC_MEM )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.default)                                 Not Covered 
(1.OPCODE_SYSTEM )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)->(69)                                   Not Covered 
(1.OPCODE_SYSTEM )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)->(!69)->(70)                            Not Covered 
(1.OPCODE_SYSTEM )->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)->(!69)->(!70)                           Not Covered 
(1.default)->(6.-)->(12.-)->(14.-)->(16.-)->(26.-)->(33.-)->(38.-)->(67.-)                                                Covered     


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_decoder
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                 Attempts Real Successes Failures Incomplete 
IbexRegImmAluOpKnown 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.id_stage_i.decoder_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  5.80  11.06  14.81   0.00   3.10   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  5.80  11.06  14.81   0.00   3.10   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME         
  5.80  11.06  14.81   0.00   3.10   0.00 ibex_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 17.45  36.36  22.73   0.00  28.17   0.00 id_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : core_ibex_fcov_if
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.21  23.53   5.88   0.00  11.63   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/verif/core_ibex_fcov_if.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                          
  8.21  23.53   5.88   0.00  11.63   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.u_fcov_bind 



-------------------------------------------------------------------------------
Line Coverage for Module : core_ibex_fcov_if

             Line No.   Total   Covered  Percent
TOTAL                       68       16    23.53
ALWAYS             56       45        5    11.11
ALWAYS            185        8        2    25.00
ALWAYS            214        9        5    55.56
INITIAL           314        1        1   100.00
INITIAL           317        5        3    60.00

55                        always_comb begin
56         1/1              id_instr_category = InstrCategoryOther;
57                      
58         1/1              case (id_stage_i.instr_rdata_i[6:0])
59         0/1     ==>        ibex_pkg::OPCODE_LUI:    id_instr_category = InstrCategoryALU;
60         0/1     ==>        ibex_pkg::OPCODE_AUIPC:  id_instr_category = InstrCategoryALU;
61         0/1     ==>        ibex_pkg::OPCODE_JAL:    id_instr_category = InstrCategoryJump;
62         0/1     ==>        ibex_pkg::OPCODE_JALR:   id_instr_category = InstrCategoryJump;
63         0/1     ==>        ibex_pkg::OPCODE_BRANCH: id_instr_category = InstrCategoryBranch;
64         0/1     ==>        ibex_pkg::OPCODE_LOAD:   id_instr_category = InstrCategoryLoad;
65         0/1     ==>        ibex_pkg::OPCODE_STORE:  id_instr_category = InstrCategoryStore;
66         0/1     ==>        ibex_pkg::OPCODE_OP_IMM: id_instr_category = InstrCategoryALU;
67                            ibex_pkg::OPCODE_OP: begin
68         0/1     ==>          if ({id_stage_i.instr_rdata_i[26], id_stage_i.instr_rdata_i[13:12]} == {1'b1, 2'b01}) begin
69         0/1     ==>            id_instr_category = InstrCategoryALU; // reg-reg/reg-imm ops
70         0/1     ==>          end else if (id_stage_i.instr_rdata_i[31:25] inside {7'b000_0000, 7'b010_0000, 7'b011_0000,
71                                    7'b011_0100, 7'b001_0100, 7'b001_0000, 7'b000_0101, 7'b000_0100, 7'b010_0100}) begin
72         0/1     ==>            id_instr_category = InstrCategoryALU; // RV32I and RV32B reg-reg/reg-imm ops
73         0/1     ==>          end else if (id_stage_i.instr_rdata_i[31:25] == 7'b000_0001) begin
74         0/1     ==>            if (id_stage_i.instr_rdata_i[14]) begin
75         0/1     ==>              id_instr_category = InstrCategoryDiv; // DIV*
76                                end else begin
77         0/1     ==>              id_instr_category = InstrCategoryMul; // MUL*
78                                end
79                              end
                   ==>  MISSING_ELSE
80                            end
81                            ibex_pkg::OPCODE_SYSTEM: begin
82         0/1     ==>          if (id_stage_i.instr_rdata_i[14:12] == 3'b000) begin
83         0/1     ==>            case (id_stage_i.instr_rdata_i[31:20])
84         0/1     ==>              12'h000: id_instr_category = InstrCategoryECall;
85                                  12'h001: begin
86         0/1     ==>                if (id_stage_i.debug_ebreakm_i && priv_mode_id == PRIV_LVL_M) begin
87         0/1     ==>                  id_instr_category = InstrCategoryEBreakDbg;
88         0/1     ==>                end else if (id_stage_i.debug_ebreaku_i && priv_mode_id == PRIV_LVL_U) begin
89         0/1     ==>                  id_instr_category = InstrCategoryEBreakDbg;
90                                    end else begin
91         0/1     ==>                  id_instr_category = InstrCategoryEBreakExc;
92                                    end
93                                  end
94         0/1     ==>              12'h302: id_instr_category = InstrCategoryMRet;
95         0/1     ==>              12'h7b2: id_instr_category = InstrCategoryDRet;
96         0/1     ==>              12'h105: id_instr_category = InstrCategoryWFI;
                   ==>  MISSING_DEFAULT
97                                endcase
98                              end else begin
99         0/1     ==>            id_instr_category = InstrCategoryCSRAccess;
100                             end
101                           end
102                           ibex_pkg::OPCODE_MISC_MEM: begin
103        0/1     ==>          if (id_stage_i.instr_rdata_i[14:12] == 3'b001) begin
104        0/1     ==>            id_instr_category = InstrCategoryFenceI;
105                             end
                   ==>  MISSING_ELSE
106                           end
107        1/1                default: id_instr_category = InstrCategoryOther;
108                         endcase
109                     
110        1/1              if (id_stage_i.instr_valid_i) begin
111        0/1     ==>        if (id_stage_i.instr_fetch_err_i) begin
112        0/1     ==>          id_instr_category = InstrCategoryFetchError;
113        0/1     ==>        end else if (id_stage_i.illegal_c_insn_i) begin
114        0/1     ==>          id_instr_category = InstrCategoryCompressedIllegal;
115        0/1     ==>        end else if (id_stage_i.illegal_insn_dec) begin
116        0/1     ==>          id_instr_category = InstrCategoryUncompressedIllegal;
117        0/1     ==>        end else if (id_stage_i.illegal_csr_insn_i) begin
118        0/1     ==>          id_instr_category = InstrCategoryCSRIllegal;
119        0/1     ==>        end else if (id_stage_i.illegal_insn_o) begin
120        0/1     ==>          id_instr_category = InstrCategoryOtherIllegal;
121                           end
                   ==>  MISSING_ELSE
122                         end else begin
123        1/1                id_instr_category = InstrCategoryNone;
124                         end
125                       end
126                     
127                       // Check instruction categories calculated from instruction bits match what decoder has produced.
128                     
129                       // The ALU category is tricky as there's no specific ALU enable and instructions that actively use
130                       // the result of the ALU but aren't themselves ALU operations (such as load/store and JALR). This
131                       // categorizes anything that selects the ALU as the source of register write data and enables
132                       // register writes minus some exclusions as an ALU operation.
133                       `ASSERT(InstrCategoryALUCorrect, id_instr_category == InstrCategoryALU |->
134                           (id_stage_i.rf_wdata_sel == RF_WD_EX) && id_stage_i.rf_we_dec && ~id_stage_i.mult_sel_ex_o &&
135                           ~id_stage_i.div_sel_ex_o && ~id_stage_i.lsu_req_dec && ~id_stage_i.jump_in_dec);
136                     
137                       `ASSERT(InstrCategoryMulCorrect,
138                           id_instr_category == InstrCategoryMul |-> id_stage_i.mult_sel_ex_o)
139                     
140                       `ASSERT(InstrCategoryDivCorrect,
141                           id_instr_category == InstrCategoryDiv |-> id_stage_i.div_sel_ex_o)
142                     
143                       `ASSERT(InstrCategoryBranchCorrect,
144                           id_instr_category == InstrCategoryBranch |-> id_stage_i.branch_in_dec)
145                     
146                       `ASSERT(InstrCategoryJumpCorrect,
147                           id_instr_category == InstrCategoryJump |-> id_stage_i.jump_in_dec)
148                     
149                       `ASSERT(InstrCategoryLoadCorrect,
150                           id_instr_category == InstrCategoryLoad |-> id_stage_i.lsu_req_dec && !id_stage_i.lsu_we)
151                     
152                       `ASSERT(InstrCategoryStoreCorrect,
153                           id_instr_category == InstrCategoryStore |-> id_stage_i.lsu_req_dec && id_stage_i.lsu_we)
154                     
155                       `ASSERT(InstrCategoryCSRAccessCorrect,
156                           id_instr_category == InstrCategoryCSRAccess |-> id_stage_i.csr_access_o)
157                       `ASSERT(InstrCategoryEBreakDbgCorrect, id_instr_category == InstrCategoryEBreakDbg |->
158                           id_stage_i.ebrk_insn && id_stage_i.controller_i.ebreak_into_debug)
159                     
160                       `ASSERT(InstrCategoryEBreakExcCorrect, id_instr_category == InstrCategoryEBreakExc |->
161                           id_stage_i.ebrk_insn && !id_stage_i.controller_i.ebreak_into_debug)
162                     
163                       `ASSERT(InstrCategoryECallCorrect,
164                           id_instr_category == InstrCategoryECall |-> id_stage_i.ecall_insn_dec)
165                     
166                       `ASSERT(InstrCategoryMRetCorrect,
167                           id_instr_category == InstrCategoryMRet |-> id_stage_i.mret_insn_dec)
168                     
169                       `ASSERT(InstrCategoryDRetCorrect,
170                           id_instr_category == InstrCategoryDRet |-> id_stage_i.dret_insn_dec)
171                     
172                       `ASSERT(InstrCategoryWFICorrect,
173                           id_instr_category == InstrCategoryWFI |-> id_stage_i.wfi_insn_dec)
174                     
175                       `ASSERT(InstrCategoryFenceICorrect,
176                           id_instr_category == InstrCategoryFenceI && id_stage_i.instr_first_cycle |->
177                           id_stage_i.icache_inval_o)
178                     
179                     
180                     
181                       id_stall_type_e id_stall_type;
182                     
183                       // Set `id_stall_type` to the appropriate type based on signals in the ID/EX stage
184                       always_comb begin
185        1/1              id_stall_type = IdStallTypeNone;
186                     
187        1/1              if (id_stage_i.instr_valid_i) begin
188        0/1     ==>        if (id_stage_i.stall_mem) begin
189        0/1     ==>          id_stall_type = IdStallTypeMem;
190                           end
                   ==>  MISSING_ELSE
191                     
192        0/1     ==>        if (id_stage_i.stall_ld_hz) begin
193        0/1     ==>          id_stall_type = IdStallTypeLdHz;
194                           end
                   ==>  MISSING_ELSE
195                     
196        0/1     ==>        if (id_stage_i.stall_multdiv || id_stage_i.stall_branch ||
197                               id_stage_i.stall_jump) begin
198        0/1     ==>          id_stall_type = IdStallTypeInstr;
199                           end
                   ==>  MISSING_ELSE
200                         end
                        MISSING_ELSE
201                       end
202                     
203                       logic            instr_unstalled;
204                       logic            instr_unstalled_last;
205                       logic            id_stall_type_last_valid;
206                       id_stall_type_e  id_stall_type_last;
207                       instr_category_e id_instr_category_last;
208                     
209                       // Keep track of previous values for some signals. These are used for some of the crosses relating
210                       // to exception and debug entry. We want to cross different instruction categories and stalling
211                       // behaviour with exception and debug entry but signals indicating entry occur a cycle after the
212                       // relevant information is flushed from the pipeline.
213                       always @(posedge clk_i or negedge rst_ni) begin
214        1/1              if (!rst_ni) begin
215                           // First cycle out of reset there is no last stall, use valid bit to deal with this case
216        1/1                id_stall_type_last_valid <= 1'b0;
217        1/1                id_stall_type_last       <= IdStallTypeNone;
218        1/1                instr_unstalled_last     <= 1'b0;
219        1/1                id_instr_category_last   <= InstrCategoryNone;
220                         end else begin
221        0/1     ==>        id_stall_type_last_valid <= 1'b1;
222        0/1     ==>        id_stall_type_last       <= id_stall_type;
223        0/1     ==>        instr_unstalled_last     <= instr_unstalled;
224        0/1     ==>        id_instr_category_last   <= id_instr_category;
225                         end
226                       end
227                     
228                       assign instr_unstalled =
229                         (id_stall_type == IdStallTypeNone) && (id_stall_type_last != IdStallTypeNone) &&
230                         id_stall_type_last_valid;
231                     
232                       covergroup uarch_cg @(posedge clk_i);
233                         cp_instr_category_id: coverpoint id_instr_category;
234                         cp_stall_type_id: coverpoint id_stall_type;
235                     
236                         cp_wb_reg_hz: coverpoint id_stage_i.fcov_rf_rd_wb_hz;
237                         cp_wb_load_hz: coverpoint id_stage_i.fcov_rf_rd_wb_hz &&
238                                                   wb_stage_i.outstanding_load_wb_o;
239                     
240                         cp_ls_error_exception: coverpoint load_store_unit_i.fcov_ls_error_exception;
241                         cp_ls_pmp_exception: coverpoint load_store_unit_i.fcov_ls_pmp_exception;
242                     
243                         cp_branch_taken: coverpoint id_stage_i.fcov_branch_taken;
244                         cp_branch_not_taken: coverpoint id_stage_i.fcov_branch_not_taken;
245                     
246                         cp_priv_mode_id: coverpoint priv_mode_id {
247                           illegal_bins illegal = {PRIV_LVL_H, PRIV_LVL_S};
248                         }
249                         cp_priv_mode_if: coverpoint priv_mode_if {
250                           illegal_bins illegal = {PRIV_LVL_H, PRIV_LVL_S};
251                         }
252                         cp_priv_mode_lsu: coverpoint priv_mode_lsu {
253                           illegal_bins illegal = {PRIV_LVL_H, PRIV_LVL_S};
254                         }
255                     
256                         cp_irq_pending: coverpoint id_stage_i.irq_pending_i | id_stage_i.irq_nm_i;
257                         cp_debug_req: coverpoint id_stage_i.controller_i.fcov_debug_req;
258                     
259                         `DV_FCOV_EXPR_SEEN(interrupt_taken, id_stage_i.controller_i.fcov_interrupt_taken)
260                         `DV_FCOV_EXPR_SEEN(debug_entry_if, id_stage_i.controller_i.fcov_debug_entry_if)
261                         `DV_FCOV_EXPR_SEEN(debug_entry_id, id_stage_i.controller_i.fcov_debug_entry_id)
262                         `DV_FCOV_EXPR_SEEN(pipe_flush, id_stage_i.controller_i.fcov_pipe_flush)
263                     
264                         priv_mode_instr_cross: cross cp_priv_mode_id, cp_instr_category_id;
265                     
266                         stall_cross: cross cp_instr_category_id, cp_stall_type_id {
267                           illegal_bins illegal =
268                             // Only Div, Mul, Branch and Jump instructions can see an instruction stall
269                             (!binsof(cp_instr_category_id) intersect {InstrCategoryDiv, InstrCategoryMul,
270                                                                      InstrCategoryBranch, InstrCategoryJump} &&
271                              binsof(cp_stall_type_id) intersect {IdStallTypeInstr})
272                         ||
273                             // Only ALU, Mul, Div, Branch, Jump, Load, Store and CSR Access can see a load hazard stall
274                             (!binsof(cp_instr_category_id) intersect {InstrCategoryALU, InstrCategoryMul,
275                                                                      InstrCategoryDiv, InstrCategoryBranch,
276                                                                      InstrCategoryJump, InstrCategoryLoad,
277                                                                      InstrCategoryStore, InstrCategoryCSRAccess} &&
278                              binsof(cp_stall_type_id) intersect {IdStallTypeLdHz});
279                         }
280                     
281                         wb_reg_hz_instr_cross: cross cp_instr_category_id, cp_wb_reg_hz;
282                     
283                         pipe_cross: cross cp_instr_category_id, if_stage_i.if_instr_valid,
284                                           wb_stage_i.fcov_wb_valid;
285                     
286                         interrupt_taken_instr_cross: cross cp_interrupt_taken, instr_unstalled_last, id_instr_category_last {
287                           illegal_bins illegal = binsof(instr_unstalled_last) intersect {0} &&
288                             binsof(id_instr_category_last) intersect {InstrCategoryDiv};
289                         }
290                     
291                         debug_entry_if_instr_cross: cross cp_debug_entry_if, instr_unstalled_last, id_instr_category_last;
292                         pipe_flush_instr_cross: cross cp_pipe_flush, instr_unstalled, cp_instr_category_id;
293                     
294                         exception_stall_instr_cross: cross cp_ls_pmp_exception, cp_ls_error_exception,
295                           cp_instr_category_id, cp_stall_type_id, instr_unstalled, cp_irq_pending, cp_debug_req {
296                           illegal_bins illegal =
297                             // Only Div, Mul, Branch and Jump instructions can see an instruction stall
298                             (!binsof(cp_instr_category_id) intersect {InstrCategoryDiv, InstrCategoryMul,
299                                                                      InstrCategoryBranch, InstrCategoryJump} &&
300                              binsof(cp_stall_type_id) intersect {IdStallTypeInstr})
301                         ||
302                             // Only ALU, Mul, Div, Branch, Jump, Load, Store and CSR Access can see a load hazard stall
303                             (!binsof(cp_instr_category_id) intersect {InstrCategoryALU, InstrCategoryMul,
304                                                                      InstrCategoryDiv, InstrCategoryBranch,
305                                                                      InstrCategoryJump, InstrCategoryLoad,
306                                                                      InstrCategoryStore, InstrCategoryCSRAccess} &&
307                              binsof(cp_stall_type_id) intersect {IdStallTypeLdHz});
308                         }
309                       endgroup
310                     
311                       bit en_uarch_cov;
312                     
313                       initial begin
314        1/1             void'($value$plusargs("enable_uarch_cov=%d", en_uarch_cov));
315                       end
316                     
317        3/5     ==>    `DV_FCOV_INSTANTIATE_CG(uarch_cg, en_uarch_cov)
DV_FCOV_INSTANTIATE_CG(uarch_cg, en_uarch_cov):
317.1                   bit en_uarch_cg = 1'b0; 
317.2                       uarch_cg uarch_cg_inst; 
317.3                       initial begin 
317.4                          
317.5      2/2                #1; 
317.6      1/1                if ((en_uarch_cg) || (en_uarch_cov)) begin 
317.7      0/1     ==>          $display("%0t: (%0s:%0d) [%m] %0s", $time, "verif/core_ibex_fcov_if.sv", 317, 
317.8                                    {"Creating covergroup ", "uarch_cg"}); 
317.9      0/1     ==>          uarch_cg_inst = new(); 
317.10                        end 
317.11                      end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : core_ibex_fcov_if

               Total   Covered  Percent
Conditions         17        1     5.88
Logical            17        1     5.88
Non-Logical         0        0
Event               0        0

 LINE       86
 EXPRESSION (id_stage_i.debug_ebreakm_i && (priv_mode_id == PRIV_LVL_M))
             -------------1------------    --------------2-------------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       88
 EXPRESSION (id_stage_i.debug_ebreaku_i && (priv_mode_id == PRIV_LVL_U))
             -------------1------------    --------------2-------------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       196
 EXPRESSION (id_stage_i.stall_multdiv || id_stage_i.stall_branch || id_stage_i.stall_jump)
             ------------1-----------    -----------2-----------    ----------3----------

-1- -2- -3- Status
 0   0   0  Not Covered
 0   0   1  Not Covered
 0   1   0  Not Covered
 1   0   0  Not Covered

 LINE       317
 EXPRESSION (en_uarch_cg || en_uarch_cov)
             -----1-----    ------2-----

-1- -2- Status
 0   0  Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       228
 EXPRESSION ((id_stall_type == IdStallTypeNone) && (id_stall_type_last != IdStallTypeNone) && id_stall_type_last_valid)
             -----------------1----------------    -------------------2-------------------    ------------3-----------

-1- -2- -3- Status
 0   1   1  Not Covered
 1   0   1  Not Covered
 1   1   0  Not Covered
 1   1   1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : core_ibex_fcov_if
                Total Covered Percent 
Totals          10    0       0.00    
Total Bits      26    0       0.00    
Total Bits 0->1 13    0       0.00    
Total Bits 1->0 13    0       0.00    

                           
Ports          5  0 0.00   
Port Bits      16 0 0.00   
Port Bits 0->1 8  0 0.00   
Port Bits 1->0 8  0 0.00   

                             
Signals          5  0 0.00   
Signal Bits      10 0 0.00   
Signal Bits 0->1 5  0 0.00   
Signal Bits 1->0 5  0 0.00   

Port Details
                   Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i              No     No          No          INPUT     
rst_ni             No     No          No          INPUT     
priv_mode_id[1:0]  No     No          No          INPUT     
priv_mode_if[1:0]  No     No          No          INPUT     
priv_mode_lsu[1:0] No     No          No          INPUT     

Signal Details
                         Toggle Toggle 1->0 Toggle 0->1 
instr_unstalled          No     No          No          
instr_unstalled_last     No     No          No          
id_stall_type_last_valid No     No          No          
en_uarch_cov             No     No          No          
en_uarch_cg              No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : core_ibex_fcov_if
         Line No. Total Covered Percent 
Branches          43    5       11.63   
CASE     58       25    1       4.00    
IF       110      7     1       14.29   
IF       187      7     1       14.29   
IF       214      2     1       50.00   
IF       317      2     1       50.00   


58             case (id_stage_i.instr_rdata_i[6:0])
               -1-  
59               ibex_pkg::OPCODE_LUI:    id_instr_category = InstrCategoryALU;
                 ==>
60               ibex_pkg::OPCODE_AUIPC:  id_instr_category = InstrCategoryALU;
                 ==>
61               ibex_pkg::OPCODE_JAL:    id_instr_category = InstrCategoryJump;
                 ==>
62               ibex_pkg::OPCODE_JALR:   id_instr_category = InstrCategoryJump;
                 ==>
63               ibex_pkg::OPCODE_BRANCH: id_instr_category = InstrCategoryBranch;
                 ==>
64               ibex_pkg::OPCODE_LOAD:   id_instr_category = InstrCategoryLoad;
                 ==>
65               ibex_pkg::OPCODE_STORE:  id_instr_category = InstrCategoryStore;
                 ==>
66               ibex_pkg::OPCODE_OP_IMM: id_instr_category = InstrCategoryALU;
                 ==>
67               ibex_pkg::OPCODE_OP: begin
68                 if ({id_stage_i.instr_rdata_i[26], id_stage_i.instr_rdata_i[13:12]} == {1'b1, 2'b01}) begin
                   -2-  
69                   id_instr_category = InstrCategoryALU; // reg-reg/reg-imm ops
                     ==>
70                 end else if (id_stage_i.instr_rdata_i[31:25] inside {7'b000_0000, 7'b010_0000, 7'b011_0000,
                            -3-  
71                       7'b011_0100, 7'b001_0100, 7'b001_0000, 7'b000_0101, 7'b000_0100, 7'b010_0100}) begin
72                   id_instr_category = InstrCategoryALU; // RV32I and RV32B reg-reg/reg-imm ops
                     ==>
73                 end else if (id_stage_i.instr_rdata_i[31:25] == 7'b000_0001) begin
                            -4-  
74                   if (id_stage_i.instr_rdata_i[14]) begin
                     -5-  
75                     id_instr_category = InstrCategoryDiv; // DIV*
                       ==>
76                   end else begin
77                     id_instr_category = InstrCategoryMul; // MUL*
                       ==>
78                   end
79                 end
                   MISSING_ELSE
                   ==>
80               end
81               ibex_pkg::OPCODE_SYSTEM: begin
82                 if (id_stage_i.instr_rdata_i[14:12] == 3'b000) begin
                   -6-  
83                   case (id_stage_i.instr_rdata_i[31:20])
                     -7-  
84                     12'h000: id_instr_category = InstrCategoryECall;
                       ==>
85                     12'h001: begin
86                       if (id_stage_i.debug_ebreakm_i && priv_mode_id == PRIV_LVL_M) begin
                         -8-  
87                         id_instr_category = InstrCategoryEBreakDbg;
                           ==>
88                       end else if (id_stage_i.debug_ebreaku_i && priv_mode_id == PRIV_LVL_U) begin
                                  -9-  
89                         id_instr_category = InstrCategoryEBreakDbg;
                           ==>
90                       end else begin
91                         id_instr_category = InstrCategoryEBreakExc;
                           ==>
92                       end
93                     end
94                     12'h302: id_instr_category = InstrCategoryMRet;
                       ==>
95                     12'h7b2: id_instr_category = InstrCategoryDRet;
                       ==>
96                     12'h105: id_instr_category = InstrCategoryWFI;
                       ==>
                       MISSING_DEFAULT
                       ==>
97                   endcase
98                 end else begin
99                   id_instr_category = InstrCategoryCSRAccess;
                     ==>
100                end
101              end
102              ibex_pkg::OPCODE_MISC_MEM: begin
103                if (id_stage_i.instr_rdata_i[14:12] == 3'b001) begin
                   -10-  
104                  id_instr_category = InstrCategoryFenceI;
                     ==>
105                end
                   MISSING_ELSE
                   ==>
106              end
107              default: id_instr_category = InstrCategoryOther;
                 ==>

Branches:

-1-              -2- -3- -4- -5- -6- -7-             -8- -9- -10- Status      
OPCODE_LUI       -   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_AUIPC     -   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_JAL       -   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_JALR      -   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_BRANCH    -   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_LOAD      -   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_STORE     -   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_OP_IMM    -   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_OP        1   -   -   -   -   -               -   -   -    Not Covered 
OPCODE_OP        0   1   -   -   -   -               -   -   -    Not Covered 
OPCODE_OP        0   0   1   1   -   -               -   -   -    Not Covered 
OPCODE_OP        0   0   1   0   -   -               -   -   -    Not Covered 
OPCODE_OP        0   0   0   -   -   -               -   -   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   1   12'h000         -   -   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   1   12'h001         1   -   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   1   12'h001         0   1   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   1   12'h001         0   0   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   1   12'h302         -   -   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   1   12'h7b2         -   -   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   1   12'h105         -   -   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   1   MISSING_DEFAULT -   -   -    Not Covered 
OPCODE_SYSTEM    -   -   -   -   0   -               -   -   -    Not Covered 
OPCODE_MISC_MEM  -   -   -   -   -   -               -   -   1    Not Covered 
OPCODE_MISC_MEM  -   -   -   -   -   -               -   -   0    Not Covered 
default          -   -   -   -   -   -               -   -   -    Covered     


110            if (id_stage_i.instr_valid_i) begin
               -1-  
111              if (id_stage_i.instr_fetch_err_i) begin
                 -2-  
112                id_instr_category = InstrCategoryFetchError;
                   ==>
113              end else if (id_stage_i.illegal_c_insn_i) begin
                          -3-  
114                id_instr_category = InstrCategoryCompressedIllegal;
                   ==>
115              end else if (id_stage_i.illegal_insn_dec) begin
                          -4-  
116                id_instr_category = InstrCategoryUncompressedIllegal;
                   ==>
117              end else if (id_stage_i.illegal_csr_insn_i) begin
                          -5-  
118                id_instr_category = InstrCategoryCSRIllegal;
                   ==>
119              end else if (id_stage_i.illegal_insn_o) begin
                          -6-  
120                id_instr_category = InstrCategoryOtherIllegal;
                   ==>
121              end
                 MISSING_ELSE
                 ==>
122            end else begin
123              id_instr_category = InstrCategoryNone;
                 ==>

Branches:

-1- -2- -3- -4- -5- -6- Status      
1   1   -   -   -   -   Not Covered 
1   0   1   -   -   -   Not Covered 
1   0   0   1   -   -   Not Covered 
1   0   0   0   1   -   Not Covered 
1   0   0   0   0   1   Not Covered 
1   0   0   0   0   0   Not Covered 
0   -   -   -   -   -   Covered     


187            if (id_stage_i.instr_valid_i) begin
               -1-  
188              if (id_stage_i.stall_mem) begin
                 -2-  
189                id_stall_type = IdStallTypeMem;
                   ==>
190              end
                 MISSING_ELSE
                 ==>
191        
192              if (id_stage_i.stall_ld_hz) begin
                 -3-  
193                id_stall_type = IdStallTypeLdHz;
                   ==>
194              end
                 MISSING_ELSE
                 ==>
195        
196              if (id_stage_i.stall_multdiv || id_stage_i.stall_branch ||
                 -4-  
197                  id_stage_i.stall_jump) begin
198                id_stall_type = IdStallTypeInstr;
                   ==>
199              end
                 MISSING_ELSE
                 ==>
200            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- -3- -4- Status      
1   1   -   -   Not Covered 
1   0   -   -   Not Covered 
1   -   1   -   Not Covered 
1   -   0   -   Not Covered 
1   -   -   1   Not Covered 
1   -   -   0   Not Covered 
0   -   -   -   Covered     


214            if (!rst_ni) begin
               -1-  
215              // First cycle out of reset there is no last stall, use valid bit to deal with this case
216              id_stall_type_last_valid <= 1'b0;
                 ==>
217              id_stall_type_last       <= IdStallTypeNone;
218              instr_unstalled_last     <= 1'b0;
219              id_instr_category_last   <= InstrCategoryNone;
220            end else begin
221              id_stall_type_last_valid <= 1'b1;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


317          `DV_FCOV_INSTANTIATE_CG(uarch_cg, en_uarch_cov)
             -1-                                               
             ==>
             MISSING_ELSE
             ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


-------------------------------------------------------------------------------
Assert Coverage for Module : core_ibex_fcov_if
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       15    15        100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            15    15        100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                          Attempts Real Successes Failures Incomplete 
InstrCategoryALUCorrect       3        0              0        0          
InstrCategoryBranchCorrect    3        0              0        0          
InstrCategoryCSRAccessCorrect 3        0              0        0          
InstrCategoryDRetCorrect      3        0              0        0          
InstrCategoryDivCorrect       3        0              0        0          
InstrCategoryEBreakDbgCorrect 3        0              0        0          
InstrCategoryEBreakExcCorrect 3        0              0        0          
InstrCategoryECallCorrect     3        0              0        0          
InstrCategoryFenceICorrect    3        0              0        0          
InstrCategoryJumpCorrect      3        0              0        0          
InstrCategoryLoadCorrect      3        0              0        0          
InstrCategoryMRetCorrect      3        0              0        0          
InstrCategoryMulCorrect       3        0              0        0          
InstrCategoryStoreCorrect     3        0              0        0          
InstrCategoryWFICorrect       3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.u_fcov_bind
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.21  23.53   5.88   0.00  11.63   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.21  23.53   5.88   0.00  11.63   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME              
  8.21  23.53   5.88   0.00  11.63   0.00 core_ibex_fcov_if 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME        
 20.58  43.66  14.29   0.00  28.26  16.67 u_ibex_core 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_controller
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.40  30.04   3.33   0.00   8.60   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_controller.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                      
  8.40  30.04   3.33   0.00   8.60   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.id_stage_i.controller_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_controller

             Line No.   Total   Covered  Percent
TOTAL                      253       76    30.04
ALWAYS            174        0        0
ALWAYS            275       18       12    66.67
ALWAYS            352       29       15    51.72
ALWAYS            377      178       34    19.10
ALWAYS            823       19       10    52.63
ALWAYS            894        9        5    55.56

173                         // print warning in case of decoding errors
174        unreachable      if ((ctrl_fsm_cs == DECODE) && instr_valid_i && !instr_fetch_err_i && illegal_insn_d) begin
175        unreachable        $display("%t: Illegal instruction (hart %0x) at PC 0x%h: 0x%h", $time, ibex_core.hart_id_i,
176                                    ibex_id_stage.pc_id_i, ibex_id_stage.instr_rdata_i);
177                         end
                   ==>  MISSING_ELSE
178                       end
179                       // synopsys translate_on
180                     `endif
181                     
182                       ////////////////
183                       // Exceptions //
184                       ////////////////
185                     
186                       assign load_err_d  = load_err_i;
187                       assign store_err_d = store_err_i;
188                     
189                       // Decoder doesn't take instr_valid into account, factor it in here.
190                       assign ecall_insn      = ecall_insn_i      & instr_valid_i;
191                       assign mret_insn       = mret_insn_i       & instr_valid_i;
192                       assign dret_insn       = dret_insn_i       & instr_valid_i;
193                       assign wfi_insn        = wfi_insn_i        & instr_valid_i;
194                       assign ebrk_insn       = ebrk_insn_i       & instr_valid_i;
195                       assign csr_pipe_flush  = csr_pipe_flush_i  & instr_valid_i;
196                       assign instr_fetch_err = instr_fetch_err_i & instr_valid_i;
197                     
198                       // "Executing DRET outside of Debug Mode causes an illegal instruction exception."
199                       // [Debug Spec v0.13.2, p.41]
200                       assign illegal_dret = dret_insn & ~debug_mode_q;
201                     
202                       // Some instructions can only be executed in M-Mode
203                       assign illegal_umode = (priv_mode_i != PRIV_LVL_M) &
204                                              // MRET must be in M-Mode. TW means trap WFI to M-Mode.
205                                              (mret_insn | (csr_mstatus_tw_i & wfi_insn));
206                     
207                       // This is recorded in the illegal_insn_q flop to help timing.  Specifically
208                       // it is needed to break the path from ibex_cs_registers/illegal_csr_insn_o
209                       // to pc_set_o.  Clear when controller is in FLUSH so it won't remain set
210                       // once illegal instruction is handled.
211                       // All terms in this expression are qualified by instr_valid_i
212                       assign illegal_insn_d = (illegal_insn_i | illegal_dret | illegal_umode) & (ctrl_fsm_cs != FLUSH);
213                     
214                       // exception requests
215                       // requests are flopped in exc_req_q.  This is cleared when controller is in
216                       // the FLUSH state so the cycle following exc_req_q won't remain set for an
217                       // exception request that has just been handled.
218                       // All terms in this expression are qualified by instr_valid_i
219                       assign exc_req_d = (ecall_insn | ebrk_insn | illegal_insn_d | instr_fetch_err) &
220                                          (ctrl_fsm_cs != FLUSH);
221                     
222                       // LSU exception requests
223                       assign exc_req_lsu = store_err_i | load_err_i;
224                     
225                     
226                       // special requests: special instructions, pipeline flushes, exceptions...
227                       // All terms in these expressions are qualified by instr_valid_i except exc_req_lsu which can come
228                       // from the Writeback stage with no instr_valid_i from the ID stage
229                     
230                       // These special requests only cause a pipeline flush and in particular don't cause a PC change
231                       // that is outside the normal execution flow
232                       assign special_req_flush_only = wfi_insn | csr_pipe_flush;
233                     
234                       // These special requests cause a change in PC
235                       assign special_req_pc_change = mret_insn | dret_insn | exc_req_d | exc_req_lsu;
236                     
237                       // generic special request signal, applies to all instructions
238                       assign special_req = special_req_pc_change | special_req_flush_only;
239                     
240                       // Is there an instruction in ID or WB that has yet to complete?
241                       assign id_wb_pending = instr_valid_i | ~ready_wb_i;
242                     
243                       // Exception/fault prioritisation is taken from Table 3.7 of Priviledged Spec v1.11
244                       if (WritebackStage) begin : g_wb_exceptions
245                         always_comb begin
246                           instr_fetch_err_prio = 0;
247                           illegal_insn_prio    = 0;
248                           ecall_insn_prio      = 0;
249                           ebrk_insn_prio       = 0;
250                           store_err_prio       = 0;
251                           load_err_prio        = 0;
252                     
253                           // Note that with the writeback stage store/load errors occur on the instruction in writeback,
254                           // all other exception/faults occur on the instruction in ID/EX. The faults from writeback
255                           // must take priority as that instruction is architecurally ordered before the one in ID/EX.
256                           if (store_err_q) begin
257                             store_err_prio = 1'b1;
258                           end else if (load_err_q) begin
259                             load_err_prio  = 1'b1;
260                           end else if (instr_fetch_err) begin
261                             instr_fetch_err_prio = 1'b1;
262                           end else if (illegal_insn_q) begin
263                             illegal_insn_prio = 1'b1;
264                           end else if (ecall_insn) begin
265                             ecall_insn_prio = 1'b1;
266                           end else if (ebrk_insn) begin
267                             ebrk_insn_prio = 1'b1;
268                           end
269                         end
270                     
271                         // Instruction in writeback is generating an exception so instruction in ID must not execute
272                         assign wb_exception_o = load_err_q | store_err_q | load_err_i | store_err_i;
273                       end else begin : g_no_wb_exceptions
274                         always_comb begin
275        1/1                instr_fetch_err_prio = 0;
276        1/1                illegal_insn_prio    = 0;
277        1/1                ecall_insn_prio      = 0;
278        1/1                ebrk_insn_prio       = 0;
279        1/1                store_err_prio       = 0;
280        1/1                load_err_prio        = 0;
281                     
282        1/1                if (instr_fetch_err) begin
283        0/1     ==>          instr_fetch_err_prio = 1'b1;
284        1/1                end else if (illegal_insn_q) begin
285        0/1     ==>          illegal_insn_prio = 1'b1;
286        1/1                end else if (ecall_insn) begin
287        0/1     ==>          ecall_insn_prio = 1'b1;
288        1/1                end else if (ebrk_insn) begin
289        0/1     ==>          ebrk_insn_prio = 1'b1;
290        1/1                end else if (store_err_q) begin
291        0/1     ==>          store_err_prio = 1'b1;
292        1/1                end else if (load_err_q) begin
293        0/1     ==>          load_err_prio  = 1'b1;
294                           end
                        MISSING_ELSE
295                         end
296                         assign wb_exception_o = 1'b0;
297                       end
298                     
299                       `ASSERT_IF(IbexExceptionPrioOnehot,
300                                  $onehot({instr_fetch_err_prio,
301                                           illegal_insn_prio,
302                                           ecall_insn_prio,
303                                           ebrk_insn_prio,
304                                           store_err_prio,
305                                           load_err_prio}),
306                                  (ctrl_fsm_cs == FLUSH) & exc_req_q)
307                     
308                       ////////////////
309                       // Interrupts //
310                       ////////////////
311                     
312                       // Enter debug mode due to an external debug_req_i or because the core is in
313                       // single step mode (dcsr.step == 1). Single step must be qualified with
314                       // instruction valid otherwise the core will immediately enter debug mode
315                       // due to a recently flushed IF (or a delay in an instruction returning from
316                       // memory) before it has had anything to single step.
317                       // Also enter debug mode on a trigger match (hardware breakpoint)
318                     
319                       // Set `do_single_step_q` when a valid instruction is seen outside of debug mode and core is in
320                       // single step mode. The first valid instruction on debug mode entry will clear it. Hold its value
321                       // when there is no valid instruction so `do_single_step_d` remains asserted until debug mode is
322                       // entered.
323                       assign do_single_step_d = instr_valid_i ? ~debug_mode_q & debug_single_step_i : do_single_step_q;
324                       // Enter debug mode due to:
325                       // * external `debug_req_i`
326                       // * core in single step mode (dcsr.step == 1).
327                       // * trigger match (hardware breakpoint)
328                       //
329                       // `debug_req_i` and `do_single_step_d` request debug mode with priority. This results in a debug
330                       // mode entry even if the controller goes to `FLUSH` in preparation for handling an exception or
331                       // interrupt. `trigger_match_i` is not a priority entry into debug mode as it must be ignored
332                       // where control flow changes such that the instruction causing the trigger is no longer being
333                       // executed.
334                       assign enter_debug_mode_prio_d = (debug_req_i | do_single_step_d) & ~debug_mode_q;
335                       assign enter_debug_mode = enter_debug_mode_prio_d | (trigger_match_i & ~debug_mode_q);
336                     
337                       // Set when an ebreak should enter debug mode rather than jump to exception
338                       // handler
339                       assign ebreak_into_debug = priv_mode_i == PRIV_LVL_M ? debug_ebreakm_i :
340                                                  priv_mode_i == PRIV_LVL_U ? debug_ebreaku_i :
341                                                                              1'b0;
342                     
343                       // Interrupts including NMI are ignored,
344                       // - while in debug mode [Debug Spec v0.13.2, p.39],
345                       // - while in NMI mode (nested NMIs are not supported, NMI has highest priority and
346                       //   cannot be interrupted by regular interrupts).
347                       assign handle_irq = ~debug_mode_q & ~nmi_mode_q &
348                           (irq_nm_i | (irq_pending_i & csr_mstatus_mie_i));
349                     
350                       // generate ID of fast interrupts, highest priority to highest ID
351                       always_comb begin : gen_mfip_id
352        1/2     ==>      if      (irqs_i.irq_fast[14]) mfip_id = 4'd14;
353        1/2     ==>      else if (irqs_i.irq_fast[13]) mfip_id = 4'd13;
354        1/2     ==>      else if (irqs_i.irq_fast[12]) mfip_id = 4'd12;
355        1/2     ==>      else if (irqs_i.irq_fast[11]) mfip_id = 4'd11;
356        1/2     ==>      else if (irqs_i.irq_fast[10]) mfip_id = 4'd10;
357        1/2     ==>      else if (irqs_i.irq_fast[ 9]) mfip_id = 4'd9;
358        1/2     ==>      else if (irqs_i.irq_fast[ 8]) mfip_id = 4'd8;
359        1/2     ==>      else if (irqs_i.irq_fast[ 7]) mfip_id = 4'd7;
360        1/2     ==>      else if (irqs_i.irq_fast[ 6]) mfip_id = 4'd6;
361        1/2     ==>      else if (irqs_i.irq_fast[ 5]) mfip_id = 4'd5;
362        1/2     ==>      else if (irqs_i.irq_fast[ 4]) mfip_id = 4'd4;
363        1/2     ==>      else if (irqs_i.irq_fast[ 3]) mfip_id = 4'd3;
364        1/2     ==>      else if (irqs_i.irq_fast[ 2]) mfip_id = 4'd2;
365        1/2     ==>      else if (irqs_i.irq_fast[ 1]) mfip_id = 4'd1;
366        1/1              else                          mfip_id = 4'd0;
367                       end
368                     
369                       assign unused_irq_timer = irqs_i.irq_timer;
370                     
371                       /////////////////////
372                       // Core controller //
373                       /////////////////////
374                     
375                       always_comb begin
376                         // Default values
377        1/1              instr_req_o           = 1'b1;
378                     
379        1/1              csr_save_if_o         = 1'b0;
380        1/1              csr_save_id_o         = 1'b0;
381        1/1              csr_save_wb_o         = 1'b0;
382        1/1              csr_restore_mret_id_o = 1'b0;
383        1/1              csr_restore_dret_id_o = 1'b0;
384        1/1              csr_save_cause_o      = 1'b0;
385        1/1              csr_mtval_o           = '0;
386                     
387                         // The values of pc_mux and exc_pc_mux are only relevant if pc_set is set. Some of the states
388                         // below always set pc_mux and exc_pc_mux but only set pc_set if certain conditions are met.
389                         // This avoid having to factor those conditions into the pc_mux and exc_pc_mux select signals
390                         // helping timing.
391        1/1              pc_mux_o               = PC_BOOT;
392        1/1              pc_set_o               = 1'b0;
393        1/1              pc_set_spec_o          = 1'b0;
394        1/1              nt_branch_mispredict_o = 1'b0;
395                     
396        1/1              exc_pc_mux_o           = EXC_PC_IRQ;
397        1/1              exc_cause_o            = EXC_CAUSE_INSN_ADDR_MISA; // = 6'h00
398                     
399        1/1              ctrl_fsm_ns            = ctrl_fsm_cs;
400                     
401        1/1              ctrl_busy_o            = 1'b1;
402                     
403        1/1              halt_if                = 1'b0;
404        1/1              retain_id              = 1'b0;
405        1/1              flush_id               = 1'b0;
406                     
407        1/1              debug_csr_save_o       = 1'b0;
408        1/1              debug_cause_o          = DBG_CAUSE_EBREAK;
409        1/1              debug_mode_d           = debug_mode_q;
410        1/1              nmi_mode_d             = nmi_mode_q;
411                     
412        1/1              perf_tbranch_o         = 1'b0;
413        1/1              perf_jump_o            = 1'b0;
414                     
415        1/1              controller_run_o       = 1'b0;
416                     
417        1/1              unique case (ctrl_fsm_cs)
418                           RESET: begin
419        1/1                  instr_req_o   = 1'b0;
420        1/1                  pc_mux_o      = PC_BOOT;
421        1/1                  pc_set_o      = 1'b1;
422        1/1                  pc_set_spec_o = 1'b1;
423        1/1                  ctrl_fsm_ns   = BOOT_SET;
424                           end
425                     
426                           BOOT_SET: begin
427                             // copy boot address to instr fetch address
428        0/1     ==>          instr_req_o   = 1'b1;
429        0/1     ==>          pc_mux_o      = PC_BOOT;
430        0/1     ==>          pc_set_o      = 1'b1;
431        0/1     ==>          pc_set_spec_o = 1'b1;
432                     
433        0/1     ==>          ctrl_fsm_ns = FIRST_FETCH;
434                           end
435                     
436                           WAIT_SLEEP: begin
437        0/1     ==>          ctrl_busy_o   = 1'b0;
438        0/1     ==>          instr_req_o   = 1'b0;
439        0/1     ==>          halt_if       = 1'b1;
440        0/1     ==>          flush_id      = 1'b1;
441        0/1     ==>          ctrl_fsm_ns   = SLEEP;
442                           end
443                     
444                           SLEEP: begin
445                             // instruction in IF stage is already valid
446                             // we begin execution when an interrupt has arrived
447        0/1     ==>          instr_req_o   = 1'b0;
448        0/1     ==>          halt_if       = 1'b1;
449        0/1     ==>          flush_id      = 1'b1;
450                     
451                             // normal execution flow
452                             // in debug mode or single step mode we leave immediately (wfi=nop)
453        0/1     ==>          if (irq_nm_i || irq_pending_i || debug_req_i || debug_mode_q || debug_single_step_i) begin
454        0/1     ==>            ctrl_fsm_ns = FIRST_FETCH;
455                             end else begin
456                               // Make sure clock remains disabled.
457        0/1     ==>            ctrl_busy_o = 1'b0;
458                             end
459                           end
460                     
461                           FIRST_FETCH: begin
462                             // Stall because of IF miss
463        0/1     ==>          if (id_in_ready_o) begin
464        0/1     ==>            ctrl_fsm_ns = DECODE;
465                             end
                   ==>  MISSING_ELSE
466                     
467                             // handle interrupts
468        0/1     ==>          if (handle_irq) begin
469                               // We are handling an interrupt. Set halt_if to tell IF not to give
470                               // us any more instructions before it redirects to the handler, but
471                               // don't set flush_id: we must allow this instruction to complete
472                               // (since it might have outstanding loads or stores).
473        0/1     ==>            ctrl_fsm_ns = IRQ_TAKEN;
474        0/1     ==>            halt_if     = 1'b1;
475                             end
                   ==>  MISSING_ELSE
476                     
477                             // enter debug mode
478        0/1     ==>          if (enter_debug_mode) begin
479        0/1     ==>            ctrl_fsm_ns = DBG_TAKEN_IF;
480                               // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the
481                               // ID state is needed for correct debug mode entry
482        0/1     ==>            halt_if     = 1'b1;
483                             end
                   ==>  MISSING_ELSE
484                           end
485                     
486                           DECODE: begin
487                             // normal operating mode of the ID stage, in case of debug and interrupt requests,
488                             // priorities are as follows (lower number == higher priority)
489                             // 1. currently running (multicycle) instructions and exceptions caused by these
490                             // 2. debug requests
491                             // 3. interrupt requests
492                     
493        0/1     ==>          controller_run_o = 1'b1;
494                     
495                             // Set PC mux for branch and jump here to ease timing. Value is only relevant if pc_set_o is
496                             // also set. Setting the mux value here avoids factoring in special_req and instr_valid_i
497                             // which helps timing.
498        0/1     ==>          pc_mux_o = PC_JUMP;
499                     
500                     
501                             // Get ready for special instructions, exceptions, pipeline flushes
502        0/1     ==>          if (special_req) begin
503                               // Halt IF but don't flush ID. This leaves a valid instruction in
504                               // ID so controller can determine appropriate action in the
505                               // FLUSH state.
506        0/1     ==>            retain_id = 1'b1;
507                     
508                               // Wait for the writeback stage to either be ready for a new instruction or raise its own
509                               // exception before going to FLUSH. If the instruction in writeback raises an exception it
510                               // must take priority over any exception from an instruction in ID/EX. Only once the
511                               // writeback stage is ready can we be certain that won't happen. Without a writeback
512                               // stage ready_wb_i == 1 so the FSM will always go directly to FLUSH.
513                     
514        0/1     ==>            if (ready_wb_i | wb_exception_o) begin
515        0/1     ==>              ctrl_fsm_ns = FLUSH;
516                               end
                   ==>  MISSING_ELSE
517                             end
                   ==>  MISSING_ELSE
518                     
519        0/1     ==>          if (branch_set_i || jump_set_i) begin
520                               // Only set the PC if the branch predictor hasn't already done the branch for us
521        0/1     ==>            pc_set_o       = BranchPredictor ? ~instr_bp_taken_i : 1'b1;
522                     
523        0/1     ==>            perf_tbranch_o = branch_set_i;
524        0/1     ==>            perf_jump_o    = jump_set_i;
525                             end
                   ==>  MISSING_ELSE
526                     
527        0/1     ==>          if (BranchPredictor) begin
528        0/1     ==>            if (instr_bp_taken_i & branch_not_set_i) begin
529                                 // If the instruction is a branch that was predicted to be taken but was not taken
530                                 // signal a mispredict.
531        0/1     ==>              nt_branch_mispredict_o = 1'b1;
532                               end
                   ==>  MISSING_ELSE
533                             end
                   ==>  MISSING_ELSE
534                     
535                             // pc_set signal excluding branch taken condition
536        0/1     ==>          if (branch_set_spec_i || jump_set_i) begin
537                               // Only speculatively set the PC if the branch predictor hasn't already done the branch
538                               // for us
539        0/1     ==>            pc_set_spec_o = BranchPredictor ? ~instr_bp_taken_i : 1'b1;
540                             end
                   ==>  MISSING_ELSE
541                     
542                             // If entering debug mode or handling an IRQ the core needs to wait until any instruction in
543                             // ID or WB has finished executing. Stall IF during that time.
544        0/1     ==>          if ((enter_debug_mode || handle_irq) && (stall || id_wb_pending)) begin
545        0/1     ==>            halt_if = 1'b1;
546                             end
                   ==>  MISSING_ELSE
547                     
548        0/1     ==>          if (!stall && !special_req && !id_wb_pending) begin
549        0/1     ==>            if (enter_debug_mode) begin
550                                 // enter debug mode
551        0/1     ==>              ctrl_fsm_ns = DBG_TAKEN_IF;
552                                 // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the
553                                 // ID state is needed for correct debug mode entry
554        0/1     ==>              halt_if     = 1'b1;
555        0/1     ==>            end else if (handle_irq) begin
556                                 // handle interrupt (not in debug mode)
557        0/1     ==>              ctrl_fsm_ns = IRQ_TAKEN;
558                                 // We are handling an interrupt (not in debug mode). Set halt_if to
559                                 // tell IF not to give us any more instructions before it redirects
560                                 // to the handler, but don't set flush_id: we must allow this
561                                 // instruction to complete (since it might have outstanding loads
562                                 // or stores).
563        0/1     ==>              halt_if     = 1'b1;
564                               end
                   ==>  MISSING_ELSE
565                             end
                   ==>  MISSING_ELSE
566                     
567                           end // DECODE
568                     
569                           IRQ_TAKEN: begin
570        0/1     ==>          pc_mux_o     = PC_EXC;
571        0/1     ==>          exc_pc_mux_o = EXC_PC_IRQ;
572                     
573        0/1     ==>          if (handle_irq) begin
574        0/1     ==>            pc_set_o         = 1'b1;
575        0/1     ==>            pc_set_spec_o    = 1'b1;
576                     
577        0/1     ==>            csr_save_if_o    = 1'b1;
578        0/1     ==>            csr_save_cause_o = 1'b1;
579                     
580                               // interrupt priorities according to Privileged Spec v1.11 p.31
581        0/1     ==>            if (irq_nm_i && !nmi_mode_q) begin
582        0/1     ==>              exc_cause_o = EXC_CAUSE_IRQ_NM;
583        0/1     ==>              nmi_mode_d  = 1'b1; // enter NMI mode
584        0/1     ==>            end else if (irqs_i.irq_fast != 15'b0) begin
585                                 // generate exception cause ID from fast interrupt ID:
586                                 // - first bit distinguishes interrupts from exceptions,
587                                 // - second bit adds 16 to fast interrupt ID
588                                 // for example EXC_CAUSE_IRQ_FAST_0 = {1'b1, 5'd16}
589        0/1     ==>              exc_cause_o = exc_cause_e'({2'b11, mfip_id});
590        0/1     ==>            end else if (irqs_i.irq_external) begin
591        0/1     ==>              exc_cause_o = EXC_CAUSE_IRQ_EXTERNAL_M;
592        0/1     ==>            end else if (irqs_i.irq_software) begin
593        0/1     ==>              exc_cause_o = EXC_CAUSE_IRQ_SOFTWARE_M;
594                               end else begin // irqs_i.irq_timer
595        0/1     ==>              exc_cause_o = EXC_CAUSE_IRQ_TIMER_M;
596                               end
597                             end
                   ==>  MISSING_ELSE
598                     
599        0/1     ==>          ctrl_fsm_ns = DECODE;
600                           end
601                     
602                           DBG_TAKEN_IF: begin
603        0/1     ==>          pc_mux_o     = PC_EXC;
604        0/1     ==>          exc_pc_mux_o = EXC_PC_DBD;
605                     
606                             // enter debug mode and save PC in IF to dpc
607                             // jump to debug exception handler in debug memory
608        0/1     ==>          flush_id         = 1'b1;
609        0/1     ==>          pc_set_o         = 1'b1;
610        0/1     ==>          pc_set_spec_o    = 1'b1;
611                     
612        0/1     ==>          csr_save_if_o    = 1'b1;
613        0/1     ==>          debug_csr_save_o = 1'b1;
614                     
615        0/1     ==>          csr_save_cause_o = 1'b1;
616        0/1     ==>          if (trigger_match_i) begin
617        0/1     ==>            debug_cause_o = DBG_CAUSE_TRIGGER;
618        0/1     ==>          end else if (debug_single_step_i) begin
619        0/1     ==>            debug_cause_o = DBG_CAUSE_STEP;
620                             end else begin
621        0/1     ==>            debug_cause_o = DBG_CAUSE_HALTREQ;
622                             end
623                     
624                             // enter debug mode
625        0/1     ==>          debug_mode_d = 1'b1;
626                     
627        0/1     ==>          ctrl_fsm_ns  = DECODE;
628                           end
629                     
630                           DBG_TAKEN_ID: begin
631                             // enter debug mode and save PC in ID to dpc, used when encountering
632                             // 1. EBREAK during debug mode
633                             // 2. EBREAK with forced entry into debug mode (ebreakm or ebreaku set).
634                             // regular ebreak's go through FLUSH.
635                             //
636                             // for 1. do not update dcsr and dpc, for 2. do so [Debug Spec v0.13.2, p.39]
637                             // jump to debug exception handler in debug memory
638        0/1     ==>          flush_id      = 1'b1;
639        0/1     ==>          pc_mux_o      = PC_EXC;
640        0/1     ==>          pc_set_o      = 1'b1;
641        0/1     ==>          pc_set_spec_o = 1'b1;
642        0/1     ==>          exc_pc_mux_o  = EXC_PC_DBD;
643                     
644                             // update dcsr and dpc
645        0/1     ==>          if (ebreak_into_debug && !debug_mode_q) begin // ebreak with forced entry
646                     
647                               // dpc (set to the address of the EBREAK, i.e. set to PC in ID stage)
648        0/1     ==>            csr_save_cause_o = 1'b1;
649        0/1     ==>            csr_save_id_o    = 1'b1;
650                     
651                               // dcsr
652        0/1     ==>            debug_csr_save_o = 1'b1;
653        0/1     ==>            debug_cause_o    = DBG_CAUSE_EBREAK;
654                             end
                   ==>  MISSING_ELSE
655                     
656                             // enter debug mode
657        0/1     ==>          debug_mode_d = 1'b1;
658                     
659        0/1     ==>          ctrl_fsm_ns  = DECODE;
660                           end
661                     
662                           FLUSH: begin
663                             // flush the pipeline
664        0/1     ==>          halt_if     = 1'b1;
665        0/1     ==>          flush_id    = 1'b1;
666        0/1     ==>          ctrl_fsm_ns = DECODE;
667                     
668                             // As pc_mux and exc_pc_mux can take various values in this state they aren't set early
669                             // here.
670                     
671                             // exceptions: set exception PC, save PC and exception cause
672                             // exc_req_lsu is high for one clock cycle only (in DECODE)
673        0/1     ==>          if (exc_req_q || store_err_q || load_err_q) begin
674        0/1     ==>            pc_set_o         = 1'b1;
675        0/1     ==>            pc_set_spec_o    = 1'b1;
676        0/1     ==>            pc_mux_o         = PC_EXC;
677        0/1     ==>            exc_pc_mux_o     = debug_mode_q ? EXC_PC_DBG_EXC : EXC_PC_EXC;
678                     
679        0/1     ==>            if (WritebackStage) begin : g_writeback_mepc_save
680                                 // With the writeback stage present whether an instruction accessing memory will cause
681                                 // an exception is only known when it is in writeback. So when taking such an exception
682                                 // epc must come from writeback.
683        0/1     ==>              csr_save_id_o  = ~(store_err_q | load_err_q);
684        0/1     ==>              csr_save_wb_o  = store_err_q | load_err_q;
685                               end else begin : g_no_writeback_mepc_save
686        0/1     ==>              csr_save_id_o  = 1'b0;
687                               end
688                     
689        0/1     ==>            csr_save_cause_o = 1'b1;
690                     
691                               // Exception/fault prioritisation logic will have set exactly 1 X_prio signal
692        0/1     ==>            unique case (1'b1)
693                                 instr_fetch_err_prio: begin
694        0/1     ==>                  exc_cause_o = EXC_CAUSE_INSTR_ACCESS_FAULT;
695        0/1     ==>                  csr_mtval_o = instr_fetch_err_plus2_i ? (pc_id_i + 32'd2) : pc_id_i;
696                                 end
697                                 illegal_insn_prio: begin
698        0/1     ==>                exc_cause_o = EXC_CAUSE_ILLEGAL_INSN;
699        0/1     ==>                csr_mtval_o = instr_is_compressed_i ? {16'b0, instr_compressed_i} : instr_i;
700                                 end
701                                 ecall_insn_prio: begin
702        0/1     ==>                exc_cause_o = (priv_mode_i == PRIV_LVL_M) ? EXC_CAUSE_ECALL_MMODE :
703                                                                               EXC_CAUSE_ECALL_UMODE;
704                                 end
705                                 ebrk_insn_prio: begin
706        0/1     ==>                if (debug_mode_q | ebreak_into_debug) begin
707                                     /*
708                                      * EBREAK in debug mode re-enters debug mode
709                                      *
710                                      * "The only exception is EBREAK. When that is executed in Debug
711                                      * Mode, it halts the hart again but without updating dpc or
712                                      * dcsr." [Debug Spec v0.13.2, p.39]
713                                      */
714                     
715                                     /*
716                                      * dcsr.ebreakm == 1:
717                                      * "EBREAK instructions in M-mode enter Debug Mode."
718                                      * [Debug Spec v0.13.2, p.42]
719                                      */
720        0/1     ==>                  pc_set_o         = 1'b0;
721        0/1     ==>                  pc_set_spec_o    = 1'b0;
722        0/1     ==>                  csr_save_id_o    = 1'b0;
723        0/1     ==>                  csr_save_cause_o = 1'b0;
724        0/1     ==>                  ctrl_fsm_ns      = DBG_TAKEN_ID;
725        0/1     ==>                  flush_id         = 1'b0;
726                                   end else begin
727                                     /*
728                                      * "The EBREAK instruction is used by debuggers to cause control
729                                      * to be transferred back to a debugging environment. It
730                                      * generates a breakpoint exception and performs no other
731                                      * operation. [...] ECALL and EBREAK cause the receiving
732                                      * privilege mode's epc register to be set to the address of the
733                                      * ECALL or EBREAK instruction itself, not the address of the
734                                      * following instruction." [Privileged Spec v1.11, p.40]
735                                      */
736        0/1     ==>                  exc_cause_o      = EXC_CAUSE_BREAKPOINT;
737                                   end
738                                 end
739                                 store_err_prio: begin
740        0/1     ==>                exc_cause_o = EXC_CAUSE_STORE_ACCESS_FAULT;
741        0/1     ==>                csr_mtval_o = lsu_addr_last_i;
742                                 end
743                                 load_err_prio: begin
744        0/1     ==>                exc_cause_o = EXC_CAUSE_LOAD_ACCESS_FAULT;
745        0/1     ==>                csr_mtval_o = lsu_addr_last_i;
746                                 end
747        0/1     ==>              default: ;
748                               endcase
749                             end else begin
750                               // special instructions and pipeline flushes
751        0/1     ==>            if (mret_insn) begin
752        0/1     ==>              pc_mux_o              = PC_ERET;
753        0/1     ==>              pc_set_o              = 1'b1;
754        0/1     ==>              pc_set_spec_o         = 1'b1;
755        0/1     ==>              csr_restore_mret_id_o = 1'b1;
756        0/1     ==>              if (nmi_mode_q) begin
757        0/1     ==>                nmi_mode_d          = 1'b0; // exit NMI mode
758                                 end
                   ==>  MISSING_ELSE
759        0/1     ==>            end else if (dret_insn) begin
760        0/1     ==>              pc_mux_o              = PC_DRET;
761        0/1     ==>              pc_set_o              = 1'b1;
762        0/1     ==>              pc_set_spec_o         = 1'b1;
763        0/1     ==>              debug_mode_d          = 1'b0;
764        0/1     ==>              csr_restore_dret_id_o = 1'b1;
765        0/1     ==>            end else if (wfi_insn) begin
766        0/1     ==>              ctrl_fsm_ns           = WAIT_SLEEP;
767        0/1     ==>            end else if (csr_pipe_flush && handle_irq) begin
768                                 // start handling IRQs when doing CSR-related pipeline flushes
769        0/1     ==>              ctrl_fsm_ns           = IRQ_TAKEN;
770                               end
                   ==>  MISSING_ELSE
771                             end // exc_req_q
772                     
773                             // Entering debug mode due to either single step or debug_req. Ensure
774                             // registers are set for exception but then enter debug handler rather
775                             // than exception handler [Debug Spec v0.13.2, p.44]
776                             // Leave all other signals as is to ensure CSRs and PC get set as if
777                             // core was entering exception handler, entry to debug mode will then
778                             // see the appropriate state and setup dpc correctly.
779                             // If an EBREAK instruction is causing us to enter debug mode on the
780                             // same cycle as a debug_req or single step, honor the EBREAK and
781                             // proceed to DBG_TAKEN_ID.
782        0/1     ==>          if (enter_debug_mode_prio_q && !(ebrk_insn_prio && ebreak_into_debug)) begin
783        0/1     ==>            ctrl_fsm_ns = DBG_TAKEN_IF;
784                             end
                   ==>  MISSING_ELSE
785                           end // FLUSH
786                     
787                           default: begin
788        1/1                  instr_req_o = 1'b0;
789        1/1                  ctrl_fsm_ns = RESET;
790                           end
791                         endcase
792                       end
793                     
794                       assign flush_id_o = flush_id;
795                     
796                       // signal to CSR when in debug mode
797                       assign debug_mode_o = debug_mode_q;
798                     
799                       // signal to CSR when in an NMI handler (for nested exception handling)
800                       assign nmi_mode_o = nmi_mode_q;
801                     
802                       ///////////////////
803                       // Stall control //
804                       ///////////////////
805                     
806                       // If high current instruction cannot complete this cycle. Either because it needs more cycles to
807                       // finish (stall_id_i) or because the writeback stage cannot accept it yet (stall_wb_i). If there
808                       // is no writeback stage stall_wb_i is a constant 0.
809                       assign stall = stall_id_i | stall_wb_i;
810                     
811                       // signal to IF stage that ID stage is ready for next instr
812                       assign id_in_ready_o = ~stall & ~halt_if & ~retain_id;
813                     
814                       // kill instr in IF-ID pipeline reg that are done, or if a
815                       // multicycle instr causes an exception for example
816                       // retain_id is another kind of stall, where the instr_valid bit must remain
817                       // set (unless flush_id is set also). It cannot be factored directly into
818                       // stall as this causes a combinational loop.
819                       assign instr_valid_clear_o = ~(stall | retain_id) | flush_id;
820                     
821                       // update registers
822                       always_ff @(posedge clk_i or negedge rst_ni) begin : update_regs
823        1/1              if (!rst_ni) begin
824        1/1                ctrl_fsm_cs             <= RESET;
825        1/1                nmi_mode_q              <= 1'b0;
826        1/1                do_single_step_q        <= 1'b0;
827        1/1                debug_mode_q            <= 1'b0;
828        1/1                enter_debug_mode_prio_q <= 1'b0;
829        1/1                load_err_q              <= 1'b0;
830        1/1                store_err_q             <= 1'b0;
831        1/1                exc_req_q               <= 1'b0;
832        1/1                illegal_insn_q          <= 1'b0;
833                         end else begin
834        0/1     ==>        ctrl_fsm_cs             <= ctrl_fsm_ns;
835        0/1     ==>        nmi_mode_q              <= nmi_mode_d;
836        0/1     ==>        do_single_step_q        <= do_single_step_d;
837        0/1     ==>        debug_mode_q            <= debug_mode_d;
838        0/1     ==>        enter_debug_mode_prio_q <= enter_debug_mode_prio_d;
839        0/1     ==>        load_err_q              <= load_err_d;
840        0/1     ==>        store_err_q             <= store_err_d;
841        0/1     ==>        exc_req_q               <= exc_req_d;
842        0/1     ==>        illegal_insn_q          <= illegal_insn_d;
843                         end
844                       end
845                     
846                       //////////
847                       // FCOV //
848                       //////////
849                     
850                       `DV_FCOV_SIGNAL(logic, interrupt_taken, (ctrl_fsm_cs != IRQ_TAKEN) & (ctrl_fsm_ns == IRQ_TAKEN))
851                       `DV_FCOV_SIGNAL(logic, debug_entry_if,
852                           (ctrl_fsm_cs != DBG_TAKEN_IF) & (ctrl_fsm_ns == DBG_TAKEN_IF))
853                       `DV_FCOV_SIGNAL(logic, debug_entry_id,
854                           (ctrl_fsm_cs != DBG_TAKEN_ID) & (ctrl_fsm_ns == DBG_TAKEN_ID))
855                       `DV_FCOV_SIGNAL(logic, pipe_flush, (ctrl_fsm_cs != FLUSH) & (ctrl_fsm_ns == FLUSH))
856                       `DV_FCOV_SIGNAL(logic, debug_req, debug_req_i & ~debug_mode_q)
857                     
858                       ////////////////
859                       // Assertions //
860                       ////////////////
861                     
862                       `ASSERT(AlwaysInstrClearOnMispredict, nt_branch_mispredict_o |-> instr_valid_clear_o)
863                     
864                       // Selectors must be known/valid.
865                       `ASSERT(IbexCtrlStateValid, ctrl_fsm_cs inside {
866                           RESET, BOOT_SET, WAIT_SLEEP, SLEEP, FIRST_FETCH, DECODE, FLUSH,
867                           IRQ_TAKEN, DBG_TAKEN_IF, DBG_TAKEN_ID})
868                     
869                       // The speculative branch signal should be set whenever the actual branch signal is set
870                       `ASSERT(IbexSpecImpliesSetPC, pc_set_o |-> pc_set_spec_o)
871                     
872                       `ifdef INC_ASSERT
873                         // If something that causes a jump into an exception handler is seen that jump must occur before
874                         // the next instruction executes. The logic tracks whether a jump into an exception handler is
875                         // expected. Assertions check the jump occurs.
876                     
877                         logic exception_req, exception_req_pending, exception_req_accepted, exception_req_done;
878                         logic exception_pc_set, seen_exception_pc_set, expect_exception_pc_set;
879                         logic exception_req_needs_pc_set;
880                     
881                         assign exception_req = (special_req | enter_debug_mode | handle_irq);
882                         // Any exception rquest will cause a transition out of DECODE, once the controller transitions
883                         // back into DECODE we're done handling the request.
884                         assign exception_req_done =
885                           exception_req_pending & (ctrl_fsm_cs != DECODE) & (ctrl_fsm_ns == DECODE);
886                     
887                         assign exception_req_needs_pc_set = enter_debug_mode | handle_irq | special_req_pc_change;
888                     
889                         // An exception PC set uses specific PC types
890                         assign exception_pc_set =
891                           exception_req_pending & (pc_set_o & (pc_mux_o inside {PC_EXC, PC_ERET, PC_DRET}));
892                     
893                         always @(posedge clk_i or negedge rst_ni) begin
894        1/1                if (!rst_ni) begin
895        1/1                  exception_req_pending   <= 1'b0;
896        1/1                  exception_req_accepted  <= 1'b0;
897        1/1                  expect_exception_pc_set <= 1'b0;
898        1/1                  seen_exception_pc_set   <= 1'b0;
899                           end else begin
900                             // Keep `exception_req_pending` asserted once an exception_req is seen until it is done
901        0/1     ==>          exception_req_pending <= (exception_req_pending | exception_req) & ~exception_req_done;
902                     
903                             // The exception req has been accepted once the controller transitions out of decode
904        0/1     ==>          exception_req_accepted <= (exception_req_accepted & ~exception_req_done) |
905                               (exception_req & ctrl_fsm_ns != DECODE);
906                     
907                             // Set `expect_exception_pc_set` if exception req needs one and keep it asserted until
908                             // exception req is done
909        0/1     ==>          expect_exception_pc_set <= (expect_exception_pc_set | exception_req_needs_pc_set) &
910                               ~exception_req_done;
911                     
912                             // Keep `seen_exception_pc_set` asserted once an exception PC set is seen until the
913                             // exception req is done
914        0/1     ==>          seen_exception_pc_set <= (seen_exception_pc_set | exception_pc_set) & ~exception_req_done;

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_controller

               Total   Covered  Percent
Conditions         60        2     3.33
Logical            60        2     3.33
Non-Logical         0        0
Event               0        0

 LINE       453
 EXPRESSION (irq_nm_i || irq_pending_i || debug_req_i || debug_mode_q || debug_single_step_i)
             ----1---    ------2------    -----3-----    ------4-----    ---------5---------

-1- -2- -3- -4- -5- Status
 0   0   0   0   0  Not Covered
 0   0   0   0   1  Not Covered
 0   0   0   1   0  Not Covered
 0   0   1   0   0  Not Covered
 0   1   0   0   0  Not Covered
 1   0   0   0   0  Not Covered

 LINE       519
 EXPRESSION (branch_set_i || jump_set_i)
             ------1-----    -----2----

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       536
 EXPRESSION (branch_set_spec_i || jump_set_i)
             --------1--------    -----2----

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       544
 EXPRESSION ((enter_debug_mode || handle_irq) && (stall || id_wb_pending))
             ----------------1---------------    ------------2-----------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       544
 SUB-EXPRESSION (enter_debug_mode || handle_irq)
                 --------1-------    -----2----

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       544
 SUB-EXPRESSION (stall || id_wb_pending)
                 --1--    ------2------

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       548
 EXPRESSION (((!stall)) && ((!special_req)) && ((!id_wb_pending)))
             -----1----    --------2-------    ---------3--------

-1- -2- -3- Status
 0   1   1  Not Covered
 1   0   1  Not Covered
 1   1   0  Not Covered
 1   1   1  Not Covered

 LINE       581
 EXPRESSION (irq_nm_i && ((!nmi_mode_q)))
             ----1---    -------2-------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       645
 EXPRESSION (ebreak_into_debug && ((!debug_mode_q)))
             --------1--------    --------2--------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       673
 EXPRESSION (exc_req_q || store_err_q || load_err_q)
             ----1----    -----2-----    -----3----

-1- -2- -3- Status
 0   0   0  Not Covered
 0   0   1  Not Covered
 0   1   0  Not Covered
 1   0   0  Not Covered

 LINE       677
 EXPRESSION (debug_mode_q ? EXC_PC_DBG_EXC : EXC_PC_EXC)
             ------1-----

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       695
 EXPRESSION (instr_fetch_err_plus2_i ? ((pc_id_i + 32'd2)) : pc_id_i)
             -----------1-----------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       699
 EXPRESSION (instr_is_compressed_i ? ({16'b0, instr_compressed_i}) : instr_i)
             ----------1----------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       702
 EXPRESSION ((priv_mode_i == PRIV_LVL_M) ? EXC_CAUSE_ECALL_MMODE : EXC_CAUSE_ECALL_UMODE)
             -------------1-------------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       767
 EXPRESSION (csr_pipe_flush && handle_irq)
             -------1------    -----2----

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       782
 EXPRESSION (enter_debug_mode_prio_q && ( ! (ebrk_insn_prio && ebreak_into_debug) ))
             -----------1-----------    ---------------------2---------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       782
 SUB-EXPRESSION ( ! (ebrk_insn_prio && ebreak_into_debug) )
                    ------------------1------------------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       782
 SUB-EXPRESSION (ebrk_insn_prio && ebreak_into_debug)
                 -------1------    --------2--------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       323
 EXPRESSION (instr_valid_i ? (((~debug_mode_q) & debug_single_step_i)) : do_single_step_q)
             ------1------

-1- Status
 0  Covered
 1  Not Covered

 LINE       339
 EXPRESSION ((priv_mode_i == PRIV_LVL_M) ? debug_ebreakm_i : ((priv_mode_i == PRIV_LVL_U) ? debug_ebreaku_i : 1'b0))
             -------------1-------------

-1- Status
 0  Not Covered
 1  Covered

 LINE       339
 SUB-EXPRESSION ((priv_mode_i == PRIV_LVL_U) ? debug_ebreaku_i : 1'b0)
                 -------------1-------------

-1- Status
 0  Not Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_controller
                Total Covered Percent 
Totals          132   0       0.00    
Total Bits      610   0       0.00    
Total Bits 0->1 305   0       0.00    
Total Bits 1->0 305   0       0.00    

                            
Ports          67  0 0.00   
Port Bits      462 0 0.00   
Port Bits 0->1 231 0 0.00   
Port Bits 1->0 231 0 0.00   

                              
Signals          65  0 0.00   
Signal Bits      148 0 0.00   
Signal Bits 0->1 74  0 0.00   
Signal Bits 1->0 74  0 0.00   

Port Details
                         Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                    No     No          No          INPUT     
rst_ni                   No     No          No          INPUT     
ctrl_busy_o              No     No          No          OUTPUT    
illegal_insn_i           No     No          No          INPUT     
ecall_insn_i             No     No          No          INPUT     
mret_insn_i              No     No          No          INPUT     
dret_insn_i              No     No          No          INPUT     
wfi_insn_i               No     No          No          INPUT     
ebrk_insn_i              No     No          No          INPUT     
csr_pipe_flush_i         No     No          No          INPUT     
instr_valid_i            No     No          No          INPUT     
instr_i[31:0]            No     No          No          INPUT     
instr_compressed_i[15:0] No     No          No          INPUT     
instr_is_compressed_i    No     No          No          INPUT     
instr_bp_taken_i         No     No          No          INPUT     
instr_fetch_err_i        No     No          No          INPUT     
instr_fetch_err_plus2_i  No     No          No          INPUT     
pc_id_i[31:0]            No     No          No          INPUT     
instr_valid_clear_o      No     No          No          OUTPUT    
id_in_ready_o            No     No          No          OUTPUT    
controller_run_o         No     No          No          OUTPUT    
instr_req_o              No     No          No          OUTPUT    
pc_set_o                 No     No          No          OUTPUT    
pc_set_spec_o            No     No          No          OUTPUT    
pc_mux_o[2:0]            No     No          No          OUTPUT    
nt_branch_mispredict_o   No     No          No          OUTPUT    
exc_pc_mux_o[1:0]        No     No          No          OUTPUT    
exc_cause_o[5:0]         No     No          No          OUTPUT    
lsu_addr_last_i[31:0]    No     No          No          INPUT     
load_err_i               No     No          No          INPUT     
store_err_i              No     No          No          INPUT     
wb_exception_o           No     No          No          OUTPUT    
branch_set_i             No     No          No          INPUT     
branch_set_spec_i        No     No          No          INPUT     
branch_not_set_i         No     No          No          INPUT     
jump_set_i               No     No          No          INPUT     
csr_mstatus_mie_i        No     No          No          INPUT     
irq_pending_i            No     No          No          INPUT     
irqs_i.irq_fast[14:0]    No     No          No          INPUT     
irqs_i.irq_external      No     No          No          INPUT     
irqs_i.irq_timer         No     No          No          INPUT     
irqs_i.irq_software      No     No          No          INPUT     
irq_nm_i                 No     No          No          INPUT     
nmi_mode_o               No     No          No          OUTPUT    
debug_req_i              No     No          No          INPUT     
debug_cause_o[2:0]       No     No          No          OUTPUT    
debug_csr_save_o         No     No          No          OUTPUT    
debug_mode_o             No     No          No          OUTPUT    
debug_single_step_i      No     No          No          INPUT     
debug_ebreakm_i          No     No          No          INPUT     
debug_ebreaku_i          No     No          No          INPUT     
trigger_match_i          No     No          No          INPUT     
csr_save_if_o            No     No          No          OUTPUT    
csr_save_id_o            No     No          No          OUTPUT    
csr_save_wb_o            No     No          No          OUTPUT    
csr_restore_mret_id_o    No     No          No          OUTPUT    
csr_restore_dret_id_o    No     No          No          OUTPUT    
csr_save_cause_o         No     No          No          OUTPUT    
csr_mtval_o[31:0]        No     No          No          OUTPUT    
priv_mode_i[1:0]         No     No          No          INPUT     
csr_mstatus_tw_i         No     No          No          INPUT     
stall_id_i               No     No          No          INPUT     
stall_wb_i               No     No          No          INPUT     
flush_id_o               No     No          No          OUTPUT    
ready_wb_i               No     No          No          INPUT     
perf_jump_o              No     No          No          OUTPUT    
perf_tbranch_o           No     No          No          OUTPUT    

Signal Details
                            Toggle Toggle 1->0 Toggle 0->1 
ctrl_fsm_cs[3:0]            No     No          No          
ctrl_fsm_ns[3:0]            No     No          No          
nmi_mode_q                  No     No          No          
nmi_mode_d                  No     No          No          
debug_mode_q                No     No          No          
debug_mode_d                No     No          No          
load_err_q                  No     No          No          
load_err_d                  No     No          No          
store_err_q                 No     No          No          
store_err_d                 No     No          No          
exc_req_q                   No     No          No          
exc_req_d                   No     No          No          
illegal_insn_q              No     No          No          
illegal_insn_d              No     No          No          
instr_fetch_err_prio        No     No          No          
illegal_insn_prio           No     No          No          
ecall_insn_prio             No     No          No          
ebrk_insn_prio              No     No          No          
store_err_prio              No     No          No          
load_err_prio               No     No          No          
stall                       No     No          No          
halt_if                     No     No          No          
retain_id                   No     No          No          
flush_id                    No     No          No          
illegal_dret                No     No          No          
illegal_umode               No     No          No          
exc_req_lsu                 No     No          No          
special_req                 No     No          No          
special_req_pc_change       No     No          No          
special_req_flush_only      No     No          No          
do_single_step_d            No     No          No          
do_single_step_q            No     No          No          
enter_debug_mode_prio_d     No     No          No          
enter_debug_mode_prio_q     No     No          No          
enter_debug_mode            No     No          No          
ebreak_into_debug           No     No          No          
handle_irq                  No     No          No          
id_wb_pending               No     No          No          
mfip_id[3:0]                No     No          No          
unused_irq_timer            No     No          No          
ecall_insn                  No     No          No          
mret_insn                   No     No          No          
dret_insn                   No     No          No          
wfi_insn                    No     No          No          
ebrk_insn                   No     No          No          
csr_pipe_flush              No     No          No          
instr_fetch_err             No     No          No          
fcov_interrupt_taken        No     No          No          
unused_fcov_interrupt_taken No     No          No          
fcov_debug_entry_if         No     No          No          
unused_fcov_debug_entry_if  No     No          No          
fcov_debug_entry_id         No     No          No          
unused_fcov_debug_entry_id  No     No          No          
fcov_pipe_flush             No     No          No          
unused_fcov_pipe_flush      No     No          No          
fcov_debug_req              No     No          No          
unused_fcov_debug_req       No     No          No          
exception_req               No     No          No          
exception_req_pending       No     No          No          
exception_req_accepted      No     No          No          
exception_req_done          No     No          No          
exception_pc_set            No     No          No          
seen_exception_pc_set       No     No          No          
expect_exception_pc_set     No     No          No          
exception_req_needs_pc_set  No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_controller
         Line No. Total Covered Percent 
Branches          93    8       8.60    
TERNARY  323      2     1       50.00   
TERNARY  339      3     1       33.33   
IF       352      15    1       6.67    
CASE     417      62    2       3.23    
IF       823      2     1       50.00   
IF       894      2     1       50.00   
IF       282      7     1       14.29   


323          assign do_single_step_d = instr_valid_i ? ~debug_mode_q & debug_single_step_i : do_single_step_q;
                                                     -1-  
                                                     ==>  
                                                     ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


339          assign ebreak_into_debug = priv_mode_i == PRIV_LVL_M ? debug_ebreakm_i :
                                                                  -1-  
                                                                  ==>  
340                                     priv_mode_i == PRIV_LVL_U ? debug_ebreaku_i :
                                                                  -2-  
                                                                  ==>  
                                                                  ==>  

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


352            if      (irqs_i.irq_fast[14]) mfip_id = 4'd14;
               -1-  
               ==>
353            else if (irqs_i.irq_fast[13]) mfip_id = 4'd13;
                    -2-  
               ==>
354            else if (irqs_i.irq_fast[12]) mfip_id = 4'd12;
                    -3-  
               ==>
355            else if (irqs_i.irq_fast[11]) mfip_id = 4'd11;
                    -4-  
               ==>
356            else if (irqs_i.irq_fast[10]) mfip_id = 4'd10;
                    -5-  
               ==>
357            else if (irqs_i.irq_fast[ 9]) mfip_id = 4'd9;
                    -6-  
               ==>
358            else if (irqs_i.irq_fast[ 8]) mfip_id = 4'd8;
                    -7-  
               ==>
359            else if (irqs_i.irq_fast[ 7]) mfip_id = 4'd7;
                    -8-  
               ==>
360            else if (irqs_i.irq_fast[ 6]) mfip_id = 4'd6;
                    -9-  
               ==>
361            else if (irqs_i.irq_fast[ 5]) mfip_id = 4'd5;
                    -10-  
               ==>
362            else if (irqs_i.irq_fast[ 4]) mfip_id = 4'd4;
                    -11-  
               ==>
363            else if (irqs_i.irq_fast[ 3]) mfip_id = 4'd3;
                    -12-  
               ==>
364            else if (irqs_i.irq_fast[ 2]) mfip_id = 4'd2;
                    -13-  
               ==>
365            else if (irqs_i.irq_fast[ 1]) mfip_id = 4'd1;
                    -14-  
               ==>
366            else                          mfip_id = 4'd0;
               ==>

Branches:

-1- -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- -12- -13- -14- Status      
1   -   -   -   -   -   -   -   -   -    -    -    -    -    Not Covered 
0   1   -   -   -   -   -   -   -   -    -    -    -    -    Not Covered 
0   0   1   -   -   -   -   -   -   -    -    -    -    -    Not Covered 
0   0   0   1   -   -   -   -   -   -    -    -    -    -    Not Covered 
0   0   0   0   1   -   -   -   -   -    -    -    -    -    Not Covered 
0   0   0   0   0   1   -   -   -   -    -    -    -    -    Not Covered 
0   0   0   0   0   0   1   -   -   -    -    -    -    -    Not Covered 
0   0   0   0   0   0   0   1   -   -    -    -    -    -    Not Covered 
0   0   0   0   0   0   0   0   1   -    -    -    -    -    Not Covered 
0   0   0   0   0   0   0   0   0   1    -    -    -    -    Not Covered 
0   0   0   0   0   0   0   0   0   0    1    -    -    -    Not Covered 
0   0   0   0   0   0   0   0   0   0    0    1    -    -    Not Covered 
0   0   0   0   0   0   0   0   0   0    0    0    1    -    Not Covered 
0   0   0   0   0   0   0   0   0   0    0    0    0    1    Not Covered 
0   0   0   0   0   0   0   0   0   0    0    0    0    0    Covered     


417            unique case (ctrl_fsm_cs)
                      -1-  
418              RESET: begin
419                instr_req_o   = 1'b0;
                   ==>
420                pc_mux_o      = PC_BOOT;
421                pc_set_o      = 1'b1;
422                pc_set_spec_o = 1'b1;
423                ctrl_fsm_ns   = BOOT_SET;
424              end
425        
426              BOOT_SET: begin
427                // copy boot address to instr fetch address
428                instr_req_o   = 1'b1;
                   ==>
429                pc_mux_o      = PC_BOOT;
430                pc_set_o      = 1'b1;
431                pc_set_spec_o = 1'b1;
432        
433                ctrl_fsm_ns = FIRST_FETCH;
434              end
435        
436              WAIT_SLEEP: begin
437                ctrl_busy_o   = 1'b0;
                   ==>
438                instr_req_o   = 1'b0;
439                halt_if       = 1'b1;
440                flush_id      = 1'b1;
441                ctrl_fsm_ns   = SLEEP;
442              end
443        
444              SLEEP: begin
445                // instruction in IF stage is already valid
446                // we begin execution when an interrupt has arrived
447                instr_req_o   = 1'b0;
448                halt_if       = 1'b1;
449                flush_id      = 1'b1;
450        
451                // normal execution flow
452                // in debug mode or single step mode we leave immediately (wfi=nop)
453                if (irq_nm_i || irq_pending_i || debug_req_i || debug_mode_q || debug_single_step_i) begin
                   -2-  
454                  ctrl_fsm_ns = FIRST_FETCH;
                     ==>
455                end else begin
456                  // Make sure clock remains disabled.
457                  ctrl_busy_o = 1'b0;
                     ==>
458                end
459              end
460        
461              FIRST_FETCH: begin
462                // Stall because of IF miss
463                if (id_in_ready_o) begin
                   -3-  
464                  ctrl_fsm_ns = DECODE;
                     ==>
465                end
                   MISSING_ELSE
                   ==>
466        
467                // handle interrupts
468                if (handle_irq) begin
                   -4-  
469                  // We are handling an interrupt. Set halt_if to tell IF not to give
470                  // us any more instructions before it redirects to the handler, but
471                  // don't set flush_id: we must allow this instruction to complete
472                  // (since it might have outstanding loads or stores).
473                  ctrl_fsm_ns = IRQ_TAKEN;
                     ==>
474                  halt_if     = 1'b1;
475                end
                   MISSING_ELSE
                   ==>
476        
477                // enter debug mode
478                if (enter_debug_mode) begin
                   -5-  
479                  ctrl_fsm_ns = DBG_TAKEN_IF;
                     ==>
480                  // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the
481                  // ID state is needed for correct debug mode entry
482                  halt_if     = 1'b1;
483                end
                   MISSING_ELSE
                   ==>
484              end
485        
486              DECODE: begin
487                // normal operating mode of the ID stage, in case of debug and interrupt requests,
488                // priorities are as follows (lower number == higher priority)
489                // 1. currently running (multicycle) instructions and exceptions caused by these
490                // 2. debug requests
491                // 3. interrupt requests
492        
493                controller_run_o = 1'b1;
494        
495                // Set PC mux for branch and jump here to ease timing. Value is only relevant if pc_set_o is
496                // also set. Setting the mux value here avoids factoring in special_req and instr_valid_i
497                // which helps timing.
498                pc_mux_o = PC_JUMP;
499        
500        
501                // Get ready for special instructions, exceptions, pipeline flushes
502                if (special_req) begin
                   -6-  
503                  // Halt IF but don't flush ID. This leaves a valid instruction in
504                  // ID so controller can determine appropriate action in the
505                  // FLUSH state.
506                  retain_id = 1'b1;
507        
508                  // Wait for the writeback stage to either be ready for a new instruction or raise its own
509                  // exception before going to FLUSH. If the instruction in writeback raises an exception it
510                  // must take priority over any exception from an instruction in ID/EX. Only once the
511                  // writeback stage is ready can we be certain that won't happen. Without a writeback
512                  // stage ready_wb_i == 1 so the FSM will always go directly to FLUSH.
513        
514                  if (ready_wb_i | wb_exception_o) begin
                     -7-  
515                    ctrl_fsm_ns = FLUSH;
                       ==>
516                  end
                     MISSING_ELSE
                     ==>
517                end
                   MISSING_ELSE
                   ==>
518        
519                if (branch_set_i || jump_set_i) begin
                   -8-  
520                  // Only set the PC if the branch predictor hasn't already done the branch for us
521                  pc_set_o       = BranchPredictor ? ~instr_bp_taken_i : 1'b1;
                     ==>
522        
523                  perf_tbranch_o = branch_set_i;
524                  perf_jump_o    = jump_set_i;
525                end
                   MISSING_ELSE
                   ==>
526        
527                if (BranchPredictor) begin
                   -9-  
528                  if (instr_bp_taken_i & branch_not_set_i) begin
                     -10-  
529                    // If the instruction is a branch that was predicted to be taken but was not taken
530                    // signal a mispredict.
531                    nt_branch_mispredict_o = 1'b1;
                       ==>
532                  end
                     MISSING_ELSE
                     ==>
533                end
                   MISSING_ELSE
                   ==>
534        
535                // pc_set signal excluding branch taken condition
536                if (branch_set_spec_i || jump_set_i) begin
                   -11-  
537                  // Only speculatively set the PC if the branch predictor hasn't already done the branch
538                  // for us
539                  pc_set_spec_o = BranchPredictor ? ~instr_bp_taken_i : 1'b1;
                     ==>
540                end
                   MISSING_ELSE
                   ==>
541        
542                // If entering debug mode or handling an IRQ the core needs to wait until any instruction in
543                // ID or WB has finished executing. Stall IF during that time.
544                if ((enter_debug_mode || handle_irq) && (stall || id_wb_pending)) begin
                   -12-  
545                  halt_if = 1'b1;
                     ==>
546                end
                   MISSING_ELSE
                   ==>
547        
548                if (!stall && !special_req && !id_wb_pending) begin
                   -13-  
549                  if (enter_debug_mode) begin
                     -14-  
550                    // enter debug mode
551                    ctrl_fsm_ns = DBG_TAKEN_IF;
                       ==>
552                    // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the
553                    // ID state is needed for correct debug mode entry
554                    halt_if     = 1'b1;
555                  end else if (handle_irq) begin
                              -15-  
556                    // handle interrupt (not in debug mode)
557                    ctrl_fsm_ns = IRQ_TAKEN;
                       ==>
558                    // We are handling an interrupt (not in debug mode). Set halt_if to
559                    // tell IF not to give us any more instructions before it redirects
560                    // to the handler, but don't set flush_id: we must allow this
561                    // instruction to complete (since it might have outstanding loads
562                    // or stores).
563                    halt_if     = 1'b1;
564                  end
                     MISSING_ELSE
                     ==>
565                end
                   MISSING_ELSE
                   ==>
566        
567              end // DECODE
568        
569              IRQ_TAKEN: begin
570                pc_mux_o     = PC_EXC;
571                exc_pc_mux_o = EXC_PC_IRQ;
572        
573                if (handle_irq) begin
                   -16-  
574                  pc_set_o         = 1'b1;
575                  pc_set_spec_o    = 1'b1;
576        
577                  csr_save_if_o    = 1'b1;
578                  csr_save_cause_o = 1'b1;
579        
580                  // interrupt priorities according to Privileged Spec v1.11 p.31
581                  if (irq_nm_i && !nmi_mode_q) begin
                     -17-  
582                    exc_cause_o = EXC_CAUSE_IRQ_NM;
                       ==>
583                    nmi_mode_d  = 1'b1; // enter NMI mode
584                  end else if (irqs_i.irq_fast != 15'b0) begin
                              -18-  
585                    // generate exception cause ID from fast interrupt ID:
586                    // - first bit distinguishes interrupts from exceptions,
587                    // - second bit adds 16 to fast interrupt ID
588                    // for example EXC_CAUSE_IRQ_FAST_0 = {1'b1, 5'd16}
589                    exc_cause_o = exc_cause_e'({2'b11, mfip_id});
                       ==>
590                  end else if (irqs_i.irq_external) begin
                              -19-  
591                    exc_cause_o = EXC_CAUSE_IRQ_EXTERNAL_M;
                       ==>
592                  end else if (irqs_i.irq_software) begin
                              -20-  
593                    exc_cause_o = EXC_CAUSE_IRQ_SOFTWARE_M;
                       ==>
594                  end else begin // irqs_i.irq_timer
595                    exc_cause_o = EXC_CAUSE_IRQ_TIMER_M;
                       ==>
596                  end
597                end
                   MISSING_ELSE
                   ==>
598        
599                ctrl_fsm_ns = DECODE;
600              end
601        
602              DBG_TAKEN_IF: begin
603                pc_mux_o     = PC_EXC;
604                exc_pc_mux_o = EXC_PC_DBD;
605        
606                // enter debug mode and save PC in IF to dpc
607                // jump to debug exception handler in debug memory
608                flush_id         = 1'b1;
609                pc_set_o         = 1'b1;
610                pc_set_spec_o    = 1'b1;
611        
612                csr_save_if_o    = 1'b1;
613                debug_csr_save_o = 1'b1;
614        
615                csr_save_cause_o = 1'b1;
616                if (trigger_match_i) begin
                   -21-  
617                  debug_cause_o = DBG_CAUSE_TRIGGER;
                     ==>
618                end else if (debug_single_step_i) begin
                            -22-  
619                  debug_cause_o = DBG_CAUSE_STEP;
                     ==>
620                end else begin
621                  debug_cause_o = DBG_CAUSE_HALTREQ;
                     ==>
622                end
623        
624                // enter debug mode
625                debug_mode_d = 1'b1;
626        
627                ctrl_fsm_ns  = DECODE;
628              end
629        
630              DBG_TAKEN_ID: begin
631                // enter debug mode and save PC in ID to dpc, used when encountering
632                // 1. EBREAK during debug mode
633                // 2. EBREAK with forced entry into debug mode (ebreakm or ebreaku set).
634                // regular ebreak's go through FLUSH.
635                //
636                // for 1. do not update dcsr and dpc, for 2. do so [Debug Spec v0.13.2, p.39]
637                // jump to debug exception handler in debug memory
638                flush_id      = 1'b1;
639                pc_mux_o      = PC_EXC;
640                pc_set_o      = 1'b1;
641                pc_set_spec_o = 1'b1;
642                exc_pc_mux_o  = EXC_PC_DBD;
643        
644                // update dcsr and dpc
645                if (ebreak_into_debug && !debug_mode_q) begin // ebreak with forced entry
                   -23-  
646        
647                  // dpc (set to the address of the EBREAK, i.e. set to PC in ID stage)
648                  csr_save_cause_o = 1'b1;
                     ==>
649                  csr_save_id_o    = 1'b1;
650        
651                  // dcsr
652                  debug_csr_save_o = 1'b1;
653                  debug_cause_o    = DBG_CAUSE_EBREAK;
654                end
                   MISSING_ELSE
                   ==>
655        
656                // enter debug mode
657                debug_mode_d = 1'b1;
658        
659                ctrl_fsm_ns  = DECODE;
660              end
661        
662              FLUSH: begin
663                // flush the pipeline
664                halt_if     = 1'b1;
665                flush_id    = 1'b1;
666                ctrl_fsm_ns = DECODE;
667        
668                // As pc_mux and exc_pc_mux can take various values in this state they aren't set early
669                // here.
670        
671                // exceptions: set exception PC, save PC and exception cause
672                // exc_req_lsu is high for one clock cycle only (in DECODE)
673                if (exc_req_q || store_err_q || load_err_q) begin
                   -24-  
674                  pc_set_o         = 1'b1;
675                  pc_set_spec_o    = 1'b1;
676                  pc_mux_o         = PC_EXC;
677                  exc_pc_mux_o     = debug_mode_q ? EXC_PC_DBG_EXC : EXC_PC_EXC;
                                                     -25-  
                                                     ==>  
                                                     ==>  
678        
679                  if (WritebackStage) begin : g_writeback_mepc_save
                     -26-  
680                    // With the writeback stage present whether an instruction accessing memory will cause
681                    // an exception is only known when it is in writeback. So when taking such an exception
682                    // epc must come from writeback.
683                    csr_save_id_o  = ~(store_err_q | load_err_q);
                       ==>
684                    csr_save_wb_o  = store_err_q | load_err_q;
685                  end else begin : g_no_writeback_mepc_save
686                    csr_save_id_o  = 1'b0;
                       ==>
687                  end
688        
689                  csr_save_cause_o = 1'b1;
690        
691                  // Exception/fault prioritisation logic will have set exactly 1 X_prio signal
692                  unique case (1'b1)
                            -27-  
693                    instr_fetch_err_prio: begin
694                        exc_cause_o = EXC_CAUSE_INSTR_ACCESS_FAULT;
695                        csr_mtval_o = instr_fetch_err_plus2_i ? (pc_id_i + 32'd2) : pc_id_i;
                                                                 -28-  
                                                                 ==>  
                                                                 ==>  
696                    end
697                    illegal_insn_prio: begin
698                      exc_cause_o = EXC_CAUSE_ILLEGAL_INSN;
699                      csr_mtval_o = instr_is_compressed_i ? {16'b0, instr_compressed_i} : instr_i;
                                                             -29-  
                                                             ==>  
                                                             ==>  
700                    end
701                    ecall_insn_prio: begin
702                      exc_cause_o = (priv_mode_i == PRIV_LVL_M) ? EXC_CAUSE_ECALL_MMODE :
                                                                   -30-  
                                                                   ==>  
                                                                   ==>  
703                                                                  EXC_CAUSE_ECALL_UMODE;
704                    end
705                    ebrk_insn_prio: begin
706                      if (debug_mode_q | ebreak_into_debug) begin
                         -31-  
707                        /*
708                         * EBREAK in debug mode re-enters debug mode
709                         *
710                         * "The only exception is EBREAK. When that is executed in Debug
711                         * Mode, it halts the hart again but without updating dpc or
712                         * dcsr." [Debug Spec v0.13.2, p.39]
713                         */
714        
715                        /*
716                         * dcsr.ebreakm == 1:
717                         * "EBREAK instructions in M-mode enter Debug Mode."
718                         * [Debug Spec v0.13.2, p.42]
719                         */
720                        pc_set_o         = 1'b0;
                           ==>
721                        pc_set_spec_o    = 1'b0;
722                        csr_save_id_o    = 1'b0;
723                        csr_save_cause_o = 1'b0;
724                        ctrl_fsm_ns      = DBG_TAKEN_ID;
725                        flush_id         = 1'b0;
726                      end else begin
727                        /*
728                         * "The EBREAK instruction is used by debuggers to cause control
729                         * to be transferred back to a debugging environment. It
730                         * generates a breakpoint exception and performs no other
731                         * operation. [...] ECALL and EBREAK cause the receiving
732                         * privilege mode's epc register to be set to the address of the
733                         * ECALL or EBREAK instruction itself, not the address of the
734                         * following instruction." [Privileged Spec v1.11, p.40]
735                         */
736                        exc_cause_o      = EXC_CAUSE_BREAKPOINT;
                           ==>
737                      end
738                    end
739                    store_err_prio: begin
740                      exc_cause_o = EXC_CAUSE_STORE_ACCESS_FAULT;
                         ==>
741                      csr_mtval_o = lsu_addr_last_i;
742                    end
743                    load_err_prio: begin
744                      exc_cause_o = EXC_CAUSE_LOAD_ACCESS_FAULT;
                         ==>
745                      csr_mtval_o = lsu_addr_last_i;
746                    end
747                    default: ;
                       ==>
748                  endcase
749                end else begin
750                  // special instructions and pipeline flushes
751                  if (mret_insn) begin
                     -32-  
752                    pc_mux_o              = PC_ERET;
753                    pc_set_o              = 1'b1;
754                    pc_set_spec_o         = 1'b1;
755                    csr_restore_mret_id_o = 1'b1;
756                    if (nmi_mode_q) begin
                       -33-  
757                      nmi_mode_d          = 1'b0; // exit NMI mode
                         ==>
758                    end
                       MISSING_ELSE
                       ==>
759                  end else if (dret_insn) begin
                              -34-  
760                    pc_mux_o              = PC_DRET;
                       ==>
761                    pc_set_o              = 1'b1;
762                    pc_set_spec_o         = 1'b1;
763                    debug_mode_d          = 1'b0;
764                    csr_restore_dret_id_o = 1'b1;
765                  end else if (wfi_insn) begin
                              -35-  
766                    ctrl_fsm_ns           = WAIT_SLEEP;
                       ==>
767                  end else if (csr_pipe_flush && handle_irq) begin
                              -36-  
768                    // start handling IRQs when doing CSR-related pipeline flushes
769                    ctrl_fsm_ns           = IRQ_TAKEN;
                       ==>
770                  end
                     MISSING_ELSE
                     ==>
771                end // exc_req_q
772        
773                // Entering debug mode due to either single step or debug_req. Ensure
774                // registers are set for exception but then enter debug handler rather
775                // than exception handler [Debug Spec v0.13.2, p.44]
776                // Leave all other signals as is to ensure CSRs and PC get set as if
777                // core was entering exception handler, entry to debug mode will then
778                // see the appropriate state and setup dpc correctly.
779                // If an EBREAK instruction is causing us to enter debug mode on the
780                // same cycle as a debug_req or single step, honor the EBREAK and
781                // proceed to DBG_TAKEN_ID.
782                if (enter_debug_mode_prio_q && !(ebrk_insn_prio && ebreak_into_debug)) begin
                   -37-  
783                  ctrl_fsm_ns = DBG_TAKEN_IF;
                     ==>
784                end
                   MISSING_ELSE
                   ==>
785              end // FLUSH
786        
787              default: begin
788                instr_req_o = 1'b0;
                   ==>

Branches:

-1-           -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- -12- -13- -14- -15- -16- -17- -18- -19- -20- -21- -22- -23- -24- -25- -26- -27-                  -28- -29- -30- -31- -32- -33- -34- -35- -36- -37- Status      
RESET         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Covered     
BOOT_SET      -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
WAIT_SLEEP    -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
SLEEP         1   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
SLEEP         0   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FIRST_FETCH   -   1   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FIRST_FETCH   -   0   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FIRST_FETCH   -   -   1   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FIRST_FETCH   -   -   0   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FIRST_FETCH   -   -   -   1   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FIRST_FETCH   -   -   -   0   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   1   1   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   1   0   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   0   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   1   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   0   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   1   1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   1   0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   0   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   -   -    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   -   -    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   -   -    -    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   -   -    -    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   -   -    -    -    1    1    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   -   -    -    -    1    0    1    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   -   -    -    -    1    0    0    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DECODE        -   -   -   -   -   -   -   -   -    -    -    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    -    -    1    1    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    -    -    1    0    1    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    -    -    1    0    0    1    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    -    -    1    0    0    0    1    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    -    -    1    0    0    0    0    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DBG_TAKEN_IF  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    1    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DBG_TAKEN_IF  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    0    1    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DBG_TAKEN_IF  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    0    0    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DBG_TAKEN_ID  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
DBG_TAKEN_ID  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    1    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    0    -    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    1    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    -                     -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    instr_fetch_err_prio  1    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    instr_fetch_err_prio  0    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    illegal_insn_prio     -    1    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    illegal_insn_prio     -    0    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    ecall_insn_prio       -    -    1    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    ecall_insn_prio       -    -    0    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    ebrk_insn_prio        -    -    -    1    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    ebrk_insn_prio        -    -    -    0    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    store_err_prio        -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    load_err_prio         -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    default               -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -                     -    -    -    -    1    1    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -                     -    -    -    -    1    0    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -                     -    -    -    -    0    -    1    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -                     -    -    -    -    0    -    0    1    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -                     -    -    -    -    0    -    0    0    1    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -                     -    -    -    -    0    -    0    0    0    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    1    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    0    Not Covered 
default       -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -                     -    -    -    -    -    -    -    -    -    -    Covered     


823            if (!rst_ni) begin
               -1-  
824              ctrl_fsm_cs             <= RESET;
                 ==>
825              nmi_mode_q              <= 1'b0;
826              do_single_step_q        <= 1'b0;
827              debug_mode_q            <= 1'b0;
828              enter_debug_mode_prio_q <= 1'b0;
829              load_err_q              <= 1'b0;
830              store_err_q             <= 1'b0;
831              exc_req_q               <= 1'b0;
832              illegal_insn_q          <= 1'b0;
833            end else begin
834              ctrl_fsm_cs             <= ctrl_fsm_ns;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


894              if (!rst_ni) begin
                 -1-  
895                exception_req_pending   <= 1'b0;
                   ==>
896                exception_req_accepted  <= 1'b0;
897                expect_exception_pc_set <= 1'b0;
898                seen_exception_pc_set   <= 1'b0;
899              end else begin
900                // Keep `exception_req_pending` asserted once an exception_req is seen until it is done
901                exception_req_pending <= (exception_req_pending | exception_req) & ~exception_req_done;
                   ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


282              if (instr_fetch_err) begin
                 -1-  
283                instr_fetch_err_prio = 1'b1;
                   ==>
284              end else if (illegal_insn_q) begin
                          -2-  
285                illegal_insn_prio = 1'b1;
                   ==>
286              end else if (ecall_insn) begin
                          -3-  
287                ecall_insn_prio = 1'b1;
                   ==>
288              end else if (ebrk_insn) begin
                          -4-  
289                ebrk_insn_prio = 1'b1;
                   ==>
290              end else if (store_err_q) begin
                          -5-  
291                store_err_prio = 1'b1;
                   ==>
292              end else if (load_err_q) begin
                          -6-  
293                load_err_prio  = 1'b1;
                   ==>
294              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- -5- -6- Status      
1   -   -   -   -   -   Not Covered 
0   1   -   -   -   -   Not Covered 
0   0   1   -   -   -   Not Covered 
0   0   0   1   -   -   Not Covered 
0   0   0   0   1   -   Not Covered 
0   0   0   0   0   1   Not Covered 
0   0   0   0   0   0   Covered     


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_controller
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       9     9         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            9     9         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                                     Attempts Real Successes Failures Incomplete 
AlwaysInstrClearOnMispredict             3        0              0        0          
IbexCtrlStateValid                       3        0              0        0          
IbexDontSkipExceptionReq                 3        0              0        0          
IbexExceptionPrioOnehot                  3        0              0        0          
IbexNoDoubleExceptionReq                 3        0              0        0          
IbexNoDoubleSpecialReqPCSet              3        0              0        0          
IbexNoPCSetOnSpecialReqIfNotExpected     3        0              0        0          
IbexSetExceptionPCOnSpecialReqIfExpected 3        0              0        0          
IbexSpecImpliesSetPC                     3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.id_stage_i.controller_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.40  30.04   3.33   0.00   8.60   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.40  30.04   3.33   0.00   8.60   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME            
  8.40  30.04   3.33   0.00   8.60   0.00 ibex_controller 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 17.45  36.36  22.73   0.00  28.17   0.00 id_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_load_store_unit
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.62  28.30   0.00   0.00  14.81   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_load_store_unit.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                
  8.62  28.30   0.00   0.00  14.81   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.load_store_unit_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_load_store_unit

             Line No.   Total   Covered  Percent
TOTAL                      159       45    28.30
ALWAYS            115       29        4    13.79
ALWAYS            172        6        2    33.33
ALWAYS            187        4        2    50.00
ALWAYS            196       10        5    50.00
ALWAYS            212        4        2    50.00
ALWAYS            221        6        2    33.33
ALWAYS            236       14        3    21.43
ALWAYS            275       14        3    21.43
ALWAYS            314        5        2    40.00
ALWAYS            333       58       15    25.86
ALWAYS            456        9        5    55.56

114                       always_comb begin
115        1/1              unique case (lsu_type_i) // Data type 00 Word, 01 Half word, 11,10 byte
116                           2'b00: begin // Writing a word
117        1/1                  if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
118        1/1                    unique case (data_offset)
119        0/1     ==>              2'b00:   data_be = 4'b1111;
120        0/1     ==>              2'b01:   data_be = 4'b1110;
121        0/1     ==>              2'b10:   data_be = 4'b1100;
122        0/1     ==>              2'b11:   data_be = 4'b1000;
123        1/1                      default: data_be = 4'b1111;
124                               endcase // case (data_offset)
125                             end else begin // second part of misaligned transaction
126        0/1     ==>            unique case (data_offset)
127        0/1     ==>              2'b00:   data_be = 4'b0000; // this is not used, but included for completeness
128        0/1     ==>              2'b01:   data_be = 4'b0001;
129        0/1     ==>              2'b10:   data_be = 4'b0011;
130        0/1     ==>              2'b11:   data_be = 4'b0111;
131        0/1     ==>              default: data_be = 4'b1111;
132                               endcase // case (data_offset)
133                             end
134                           end
135                     
136                           2'b01: begin // Writing a half word
137        0/1     ==>          if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
138        0/1     ==>            unique case (data_offset)
139        0/1     ==>              2'b00:   data_be = 4'b0011;
140        0/1     ==>              2'b01:   data_be = 4'b0110;
141        0/1     ==>              2'b10:   data_be = 4'b1100;
142        0/1     ==>              2'b11:   data_be = 4'b1000;
143        0/1     ==>              default: data_be = 4'b1111;
144                               endcase // case (data_offset)
145                             end else begin // second part of misaligned transaction
146        0/1     ==>            data_be = 4'b0001;
147                             end
148                           end
149                     
150                           2'b10,
151                           2'b11: begin // Writing a byte
152        0/1     ==>          unique case (data_offset)
153        0/1     ==>            2'b00:   data_be = 4'b0001;
154        0/1     ==>            2'b01:   data_be = 4'b0010;
155        0/1     ==>            2'b10:   data_be = 4'b0100;
156        0/1     ==>            2'b11:   data_be = 4'b1000;
157        0/1     ==>            default: data_be = 4'b1111;
158                             endcase // case (data_offset)
159                           end
160                     
161        0/1     ==>        default:     data_be = 4'b1111;
162                         endcase // case (lsu_type_i)
163                       end
164                     
165                       /////////////////////
166                       // WData alignment //
167                       /////////////////////
168                     
169                       // prepare data to be written to the memory
170                       // we handle misaligned accesses, half word and byte accesses here
171                       always_comb begin
172        1/1              unique case (data_offset)
173        0/1     ==>        2'b00:   data_wdata =  lsu_wdata_i[31:0];
174        0/1     ==>        2'b01:   data_wdata = {lsu_wdata_i[23:0], lsu_wdata_i[31:24]};
175        0/1     ==>        2'b10:   data_wdata = {lsu_wdata_i[15:0], lsu_wdata_i[31:16]};
176        0/1     ==>        2'b11:   data_wdata = {lsu_wdata_i[ 7:0], lsu_wdata_i[31: 8]};
177        1/1                default: data_wdata =  lsu_wdata_i[31:0];
178                         endcase // case (data_offset)
179                       end
180                     
181                       /////////////////////
182                       // RData alignment //
183                       /////////////////////
184                     
185                       // register for unaligned rdata
186                       always_ff @(posedge clk_i or negedge rst_ni) begin
187        1/1              if (!rst_ni) begin
188        1/1                rdata_q <= '0;
189        0/1     ==>      end else if (rdata_update) begin
190        0/1     ==>        rdata_q <= data_rdata_i[31:8];
191                         end
                   ==>  MISSING_ELSE
192                       end
193                     
194                       // registers for transaction control
195                       always_ff @(posedge clk_i or negedge rst_ni) begin
196        1/1              if (!rst_ni) begin
197        1/1                rdata_offset_q  <= 2'h0;
198        1/1                data_type_q     <= 2'h0;
199        1/1                data_sign_ext_q <= 1'b0;
200        1/1                data_we_q       <= 1'b0;
201        0/1     ==>      end else if (ctrl_update) begin
202        0/1     ==>        rdata_offset_q  <= data_offset;
203        0/1     ==>        data_type_q     <= lsu_type_i;
204        0/1     ==>        data_sign_ext_q <= lsu_sign_ext_i;
205        0/1     ==>        data_we_q       <= lsu_we_i;
206                         end
                   ==>  MISSING_ELSE
207                       end
208                     
209                       // Store last address for mtval + AGU for misaligned transactions.
210                       // Do not update in case of errors, mtval needs the (first) failing address
211                       always_ff @(posedge clk_i or negedge rst_ni) begin
212        1/1              if (!rst_ni) begin
213        1/1                addr_last_q <= '0;
214        0/1     ==>      end else if (addr_update) begin
215        0/1     ==>        addr_last_q <= data_addr;
216                         end
                   ==>  MISSING_ELSE
217                       end
218                     
219                       // take care of misaligned words
220                       always_comb begin
221        1/1              unique case (rdata_offset_q)
222        1/1                2'b00:   rdata_w_ext =  data_rdata_i[31:0];
223        0/1     ==>        2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};
224        0/1     ==>        2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};
225        0/1     ==>        2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};
226        0/1     ==>        default: rdata_w_ext =  data_rdata_i[31:0];
227                         endcase
228                       end
229                     
230                       ////////////////////
231                       // Sign extension //
232                       ////////////////////
233                     
234                       // sign extension for half words
235                       always_comb begin
236        1/1              unique case (rdata_offset_q)
237                           2'b00: begin
238        1/1                  if (!data_sign_ext_q) begin
239        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
240                             end else begin
241        0/1     ==>            rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};
242                             end
243                           end
244                     
245                           2'b01: begin
246        0/1     ==>          if (!data_sign_ext_q) begin
247        0/1     ==>            rdata_h_ext = {16'h0000, data_rdata_i[23:8]};
248                             end else begin
249        0/1     ==>            rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};
250                             end
251                           end
252                     
253                           2'b10: begin
254        0/1     ==>          if (!data_sign_ext_q) begin
255        0/1     ==>            rdata_h_ext = {16'h0000, data_rdata_i[31:16]};
256                             end else begin
257        0/1     ==>            rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};
258                             end
259                           end
260                     
261                           2'b11: begin
262        0/1     ==>          if (!data_sign_ext_q) begin
263        0/1     ==>            rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};
264                             end else begin
265        0/1     ==>            rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};
266                             end
267                           end
268                     
269        0/1     ==>        default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
270                         endcase // case (rdata_offset_q)
271                       end
272                     
273                       // sign extension for bytes
274                       always_comb begin
275        1/1              unique case (rdata_offset_q)
276                           2'b00: begin
277        1/1                  if (!data_sign_ext_q) begin
278        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
279                             end else begin
280        0/1     ==>            rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};
281                             end
282                           end
283                     
284                           2'b01: begin
285        0/1     ==>          if (!data_sign_ext_q) begin
286        0/1     ==>            rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};
287                             end else begin
288        0/1     ==>            rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};
289                             end
290                           end
291                     
292                           2'b10: begin
293        0/1     ==>          if (!data_sign_ext_q) begin
294        0/1     ==>            rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};
295                             end else begin
296        0/1     ==>            rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};
297                             end
298                           end
299                     
300                           2'b11: begin
301        0/1     ==>          if (!data_sign_ext_q) begin
302        0/1     ==>            rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};
303                             end else begin
304        0/1     ==>            rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};
305                             end
306                           end
307                     
308        0/1     ==>        default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
309                         endcase // case (rdata_offset_q)
310                       end
311                     
312                       // select word, half word or byte sign extended version
313                       always_comb begin
314        1/1              unique case (data_type_q)
315        1/1                2'b00:       data_rdata_ext = rdata_w_ext;
316        0/1     ==>        2'b01:       data_rdata_ext = rdata_h_ext;
317        0/1     ==>        2'b10,2'b11: data_rdata_ext = rdata_b_ext;
318        0/1     ==>        default:     data_rdata_ext = rdata_w_ext;
319                         endcase // case (data_type_q)
320                       end
321                     
322                       /////////////
323                       // LSU FSM //
324                       /////////////
325                     
326                       // check for misaligned accesses that need to be split into two word-aligned accesses
327                       assign split_misaligned_access =
328                           ((lsu_type_i == 2'b00) && (data_offset != 2'b00)) || // misaligned word access
329                           ((lsu_type_i == 2'b01) && (data_offset == 2'b11));   // misaligned half-word access
330                     
331                       // FSM
332                       always_comb begin
333        1/1              ls_fsm_ns       = ls_fsm_cs;
334                     
335        1/1              data_req_o          = 1'b0;
336        1/1              addr_incr_req_o     = 1'b0;
337        1/1              handle_misaligned_d = handle_misaligned_q;
338        1/1              pmp_err_d           = pmp_err_q;
339        1/1              lsu_err_d           = lsu_err_q;
340                     
341        1/1              addr_update         = 1'b0;
342        1/1              ctrl_update         = 1'b0;
343        1/1              rdata_update        = 1'b0;
344                     
345        1/1              perf_load_o         = 1'b0;
346        1/1              perf_store_o        = 1'b0;
347                     
348        1/1              unique case (ls_fsm_cs)
349                     
350                           IDLE: begin
351        1/1                  pmp_err_d = 1'b0;
352        1/1                  if (lsu_req_i) begin
353        0/1     ==>            data_req_o   = 1'b1;
354        0/1     ==>            pmp_err_d    = data_pmp_err_i;
355        0/1     ==>            lsu_err_d    = 1'b0;
356        0/1     ==>            perf_load_o  = ~lsu_we_i;
357        0/1     ==>            perf_store_o = lsu_we_i;
358                     
359        0/1     ==>            if (data_gnt_i) begin
360        0/1     ==>              ctrl_update         = 1'b1;
361        0/1     ==>              addr_update         = 1'b1;
362        0/1     ==>              handle_misaligned_d = split_misaligned_access;
363        0/1     ==>              ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : IDLE;
364                               end else begin
365        0/1     ==>              ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;
366                               end
367                             end
                        MISSING_ELSE
368                           end
369                     
370                           WAIT_GNT_MIS: begin
371        0/1     ==>          data_req_o = 1'b1;
372                             // data_pmp_err_i is valid during the address phase of a request. An error will block the
373                             // external request and so a data_gnt_i might never be signalled. The registered version
374                             // pmp_err_q is only updated for new address phases and so can be used in WAIT_GNT* and
375                             // WAIT_RVALID* states
376        0/1     ==>          if (data_gnt_i || pmp_err_q) begin
377        0/1     ==>            addr_update         = 1'b1;
378        0/1     ==>            ctrl_update         = 1'b1;
379        0/1     ==>            handle_misaligned_d = 1'b1;
380        0/1     ==>            ls_fsm_ns           = WAIT_RVALID_MIS;
381                             end
                   ==>  MISSING_ELSE
382                           end
383                     
384                           WAIT_RVALID_MIS: begin
385                             // push out second request
386        0/1     ==>          data_req_o = 1'b1;
387                             // tell ID/EX stage to update the address
388        0/1     ==>          addr_incr_req_o = 1'b1;
389                     
390                             // first part rvalid is received, or gets a PMP error
391        0/1     ==>          if (data_rvalid_i || pmp_err_q) begin
392                               // Update the PMP error for the second part
393        0/1     ==>            pmp_err_d = data_pmp_err_i;
394                               // Record the error status of the first part
395        0/1     ==>            lsu_err_d = data_err_i | pmp_err_q;
396                               // Capture the first rdata for loads
397        0/1     ==>            rdata_update = ~data_we_q;
398                               // If already granted, wait for second rvalid
399        0/1     ==>            ls_fsm_ns = data_gnt_i ? IDLE : WAIT_GNT;
400                               // Update the address for the second part, if no error
401        0/1     ==>            addr_update = data_gnt_i & ~(data_err_i | pmp_err_q);
402                               // clear handle_misaligned if second request is granted
403        0/1     ==>            handle_misaligned_d = ~data_gnt_i;
404                             end else begin
405                               // first part rvalid is NOT received
406        0/1     ==>            if (data_gnt_i) begin
407                                 // second grant is received
408        0/1     ==>              ls_fsm_ns = WAIT_RVALID_MIS_GNTS_DONE;
409        0/1     ==>              handle_misaligned_d = 1'b0;
410                               end
                   ==>  MISSING_ELSE
411                             end
412                           end
413                     
414                           WAIT_GNT: begin
415                             // tell ID/EX stage to update the address
416        0/1     ==>          addr_incr_req_o = handle_misaligned_q;
417        0/1     ==>          data_req_o      = 1'b1;
418        0/1     ==>          if (data_gnt_i || pmp_err_q) begin
419        0/1     ==>            ctrl_update         = 1'b1;
420                               // Update the address, unless there was an error
421        0/1     ==>            addr_update         = ~lsu_err_q;
422        0/1     ==>            ls_fsm_ns           = IDLE;
423        0/1     ==>            handle_misaligned_d = 1'b0;
424                             end
                   ==>  MISSING_ELSE
425                           end
426                     
427                           WAIT_RVALID_MIS_GNTS_DONE: begin
428                             // tell ID/EX stage to update the address (to make sure the
429                             // second address can be captured correctly for mtval and PMP checking)
430        0/1     ==>          addr_incr_req_o = 1'b1;
431                             // Wait for the first rvalid, second request is already granted
432        0/1     ==>          if (data_rvalid_i) begin
433                               // Update the pmp error for the second part
434        0/1     ==>            pmp_err_d = data_pmp_err_i;
435                               // The first part cannot see a PMP error in this state
436        0/1     ==>            lsu_err_d = data_err_i;
437                               // Now we can update the address for the second part if no error
438        0/1     ==>            addr_update = ~data_err_i;
439                               // Capture the first rdata for loads
440        0/1     ==>            rdata_update = ~data_we_q;
441                               // Wait for second rvalid
442        0/1     ==>            ls_fsm_ns = IDLE;
443                             end
                   ==>  MISSING_ELSE
444                           end
445                     
446                           default: begin
447        1/1                  ls_fsm_ns = IDLE;
448                           end
449                         endcase
450                       end
451                     
452                       assign lsu_req_done_o = (lsu_req_i | (ls_fsm_cs != IDLE)) & (ls_fsm_ns == IDLE);
453                     
454                       // registers for FSM
455                       always_ff @(posedge clk_i or negedge rst_ni) begin
456        1/1              if (!rst_ni) begin
457        1/1                ls_fsm_cs           <= IDLE;
458        1/1                handle_misaligned_q <= '0;
459        1/1                pmp_err_q           <= '0;
460        1/1                lsu_err_q           <= '0;
461                         end else begin
462        0/1     ==>        ls_fsm_cs           <= ls_fsm_ns;
463        0/1     ==>        handle_misaligned_q <= handle_misaligned_d;
464        0/1     ==>        pmp_err_q           <= pmp_err_d;
465        0/1     ==>        lsu_err_q           <= lsu_err_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_load_store_unit

               Total   Covered  Percent
Conditions         24        0     0.00
Logical            24        0     0.00
Non-Logical         0        0
Event               0        0

 LINE       363
 EXPRESSION (split_misaligned_access ? WAIT_RVALID_MIS : IDLE)
             -----------1-----------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       365
 EXPRESSION (split_misaligned_access ? WAIT_GNT_MIS : WAIT_GNT)
             -----------1-----------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       376
 EXPRESSION (data_gnt_i || pmp_err_q)
             -----1----    ----2----

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       391
 EXPRESSION (data_rvalid_i || pmp_err_q)
             ------1------    ----2----

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       399
 EXPRESSION (data_gnt_i ? IDLE : WAIT_GNT)
             -----1----

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       418
 EXPRESSION (data_gnt_i || pmp_err_q)
             -----1----    ----2----

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       327
 EXPRESSION (((lsu_type_i == 2'b0) && (data_offset != 2'b0)) || ((lsu_type_i == 2'b1) && (data_offset == 2'b11)))
             -----------------------1-----------------------    ------------------------2-----------------------

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       327
 SUB-EXPRESSION ((lsu_type_i == 2'b0) && (data_offset != 2'b0))
                 ----------1---------    ----------2----------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       327
 SUB-EXPRESSION ((lsu_type_i == 2'b1) && (data_offset == 2'b11))
                 ----------1---------    -----------2----------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_load_store_unit
                Total Covered Percent 
Totals          61    0       0.00    
Total Bits      1126  0       0.00    
Total Bits 0->1 563   0       0.00    
Total Bits 1->0 563   0       0.00    

                            
Ports          29  0 0.00   
Port Bits      500 0 0.00   
Port Bits 0->1 250 0 0.00   
Port Bits 1->0 250 0 0.00   

                              
Signals          32  0 0.00   
Signal Bits      626 0 0.00   
Signal Bits 0->1 313 0 0.00   
Signal Bits 1->0 313 0 0.00   

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                   No     No          No          INPUT     
rst_ni                  No     No          No          INPUT     
data_req_o              No     No          No          OUTPUT    
data_gnt_i              No     No          No          INPUT     
data_rvalid_i           No     No          No          INPUT     
data_err_i              No     No          No          INPUT     
data_pmp_err_i          No     No          No          INPUT     
data_addr_o[31:0]       No     No          No          OUTPUT    
data_we_o               No     No          No          OUTPUT    
data_be_o[3:0]          No     No          No          OUTPUT    
data_wdata_o[31:0]      No     No          No          OUTPUT    
data_rdata_i[31:0]      No     No          No          INPUT     
lsu_we_i                No     No          No          INPUT     
lsu_type_i[1:0]         No     No          No          INPUT     
lsu_wdata_i[31:0]       No     No          No          INPUT     
lsu_sign_ext_i          No     No          No          INPUT     
lsu_rdata_o[31:0]       No     No          No          OUTPUT    
lsu_rdata_valid_o       No     No          No          OUTPUT    
lsu_req_i               No     No          No          INPUT     
adder_result_ex_i[31:0] No     No          No          INPUT     
addr_incr_req_o         No     No          No          OUTPUT    
addr_last_o[31:0]       No     No          No          OUTPUT    
lsu_req_done_o          No     No          No          OUTPUT    
lsu_resp_valid_o        No     No          No          OUTPUT    
load_err_o              No     No          No          OUTPUT    
store_err_o             No     No          No          OUTPUT    
busy_o                  No     No          No          OUTPUT    
perf_load_o             No     No          No          OUTPUT    
perf_store_o            No     No          No          OUTPUT    

Signal Details
                               Toggle Toggle 1->0 Toggle 0->1 
data_addr[31:0]                No     No          No          
data_addr_w_aligned[31:0]      No     No          No          
addr_last_q[31:0]              No     No          No          
addr_update                    No     No          No          
ctrl_update                    No     No          No          
rdata_update                   No     No          No          
rdata_q[31:8]                  No     No          No          
rdata_offset_q[1:0]            No     No          No          
data_type_q[1:0]               No     No          No          
data_sign_ext_q                No     No          No          
data_we_q                      No     No          No          
data_offset[1:0]               No     No          No          
data_be[3:0]                   No     No          No          
data_wdata[31:0]               No     No          No          
data_rdata_ext[31:0]           No     No          No          
rdata_w_ext[31:0]              No     No          No          
rdata_h_ext[31:0]              No     No          No          
rdata_b_ext[31:0]              No     No          No          
split_misaligned_access        No     No          No          
handle_misaligned_q            No     No          No          
handle_misaligned_d            No     No          No          
pmp_err_q                      No     No          No          
pmp_err_d                      No     No          No          
lsu_err_q                      No     No          No          
lsu_err_d                      No     No          No          
data_or_pmp_err                No     No          No          
ls_fsm_cs[2:0]                 No     No          No          
ls_fsm_ns[2:0]                 No     No          No          
fcov_ls_error_exception        No     No          No          
unused_fcov_ls_error_exception No     No          No          
fcov_ls_pmp_exception          No     No          No          
unused_fcov_ls_pmp_exception   No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_load_store_unit
         Line No. Total Covered Percent 
Branches          81    12      14.81   
CASE     115      22    1       4.55    
CASE     172      5     1       20.00   
IF       187      3     1       33.33   
IF       196      3     1       33.33   
IF       212      3     1       33.33   
CASE     221      5     1       20.00   
CASE     236      9     1       11.11   
CASE     275      9     1       11.11   
CASE     314      4     1       25.00   
CASE     348      16    2       12.50   
IF       456      2     1       50.00   


115            unique case (lsu_type_i) // Data type 00 Word, 01 Half word, 11,10 byte
                      -1-  
116              2'b00: begin // Writing a word
117                if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
                   -2-  
118                  unique case (data_offset)
                            -3-  
119                    2'b00:   data_be = 4'b1111;
                       ==>
120                    2'b01:   data_be = 4'b1110;
                       ==>
121                    2'b10:   data_be = 4'b1100;
                       ==>
122                    2'b11:   data_be = 4'b1000;
                       ==>
123                    default: data_be = 4'b1111;
                       ==>
124                  endcase // case (data_offset)
125                end else begin // second part of misaligned transaction
126                  unique case (data_offset)
                            -4-  
127                    2'b00:   data_be = 4'b0000; // this is not used, but included for completeness
                       ==>
128                    2'b01:   data_be = 4'b0001;
                       ==>
129                    2'b10:   data_be = 4'b0011;
                       ==>
130                    2'b11:   data_be = 4'b0111;
                       ==>
131                    default: data_be = 4'b1111;
                       ==>
132                  endcase // case (data_offset)
133                end
134              end
135        
136              2'b01: begin // Writing a half word
137                if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
                   -5-  
138                  unique case (data_offset)
                            -6-  
139                    2'b00:   data_be = 4'b0011;
                       ==>
140                    2'b01:   data_be = 4'b0110;
                       ==>
141                    2'b10:   data_be = 4'b1100;
                       ==>
142                    2'b11:   data_be = 4'b1000;
                       ==>
143                    default: data_be = 4'b1111;
                       ==>
144                  endcase // case (data_offset)
145                end else begin // second part of misaligned transaction
146                  data_be = 4'b0001;
                     ==>
147                end
148              end
149        
150              2'b10,
151              2'b11: begin // Writing a byte
152                unique case (data_offset)
                          -7-  
153                  2'b00:   data_be = 4'b0001;
                     ==>
154                  2'b01:   data_be = 4'b0010;
                     ==>
155                  2'b10:   data_be = 4'b0100;
                     ==>
156                  2'b11:   data_be = 4'b1000;
                     ==>
157                  default: data_be = 4'b1111;
                     ==>
158                endcase // case (data_offset)
159              end
160        
161              default:     data_be = 4'b1111;
                 ==>

Branches:

-1-          -2- -3-     -4-     -5- -6-     -7-     Status      
2'b00        1   2'b00   -       -   -       -       Not Covered 
2'b00        1   2'b01   -       -   -       -       Not Covered 
2'b00        1   2'b10   -       -   -       -       Not Covered 
2'b00        1   2'b11   -       -   -       -       Not Covered 
2'b00        1   default -       -   -       -       Covered     
2'b00        0   -       2'b00   -   -       -       Not Covered 
2'b00        0   -       2'b01   -   -       -       Not Covered 
2'b00        0   -       2'b10   -   -       -       Not Covered 
2'b00        0   -       2'b11   -   -       -       Not Covered 
2'b00        0   -       default -   -       -       Not Covered 
2'b01        -   -       -       1   2'b00   -       Not Covered 
2'b01        -   -       -       1   2'b01   -       Not Covered 
2'b01        -   -       -       1   2'b10   -       Not Covered 
2'b01        -   -       -       1   2'b11   -       Not Covered 
2'b01        -   -       -       1   default -       Not Covered 
2'b01        -   -       -       0   -       -       Not Covered 
2'b10 2'b11  -   -       -       -   -       2'b00   Not Covered 
2'b10 2'b11  -   -       -       -   -       2'b01   Not Covered 
2'b10 2'b11  -   -       -       -   -       2'b10   Not Covered 
2'b10 2'b11  -   -       -       -   -       2'b11   Not Covered 
2'b10 2'b11  -   -       -       -   -       default Not Covered 
default      -   -       -       -   -       -       Not Covered 


172            unique case (data_offset)
                      -1-  
173              2'b00:   data_wdata =  lsu_wdata_i[31:0];
                 ==>
174              2'b01:   data_wdata = {lsu_wdata_i[23:0], lsu_wdata_i[31:24]};
                 ==>
175              2'b10:   data_wdata = {lsu_wdata_i[15:0], lsu_wdata_i[31:16]};
                 ==>
176              2'b11:   data_wdata = {lsu_wdata_i[ 7:0], lsu_wdata_i[31: 8]};
                 ==>
177              default: data_wdata =  lsu_wdata_i[31:0];
                 ==>

Branches:

-1-     Status      
2'b00   Not Covered 
2'b01   Not Covered 
2'b10   Not Covered 
2'b11   Not Covered 
default Covered     


187            if (!rst_ni) begin
               -1-  
188              rdata_q <= '0;
                 ==>
189            end else if (rdata_update) begin
                        -2-  
190              rdata_q <= data_rdata_i[31:8];
                 ==>
191            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


196            if (!rst_ni) begin
               -1-  
197              rdata_offset_q  <= 2'h0;
                 ==>
198              data_type_q     <= 2'h0;
199              data_sign_ext_q <= 1'b0;
200              data_we_q       <= 1'b0;
201            end else if (ctrl_update) begin
                        -2-  
202              rdata_offset_q  <= data_offset;
                 ==>
203              data_type_q     <= lsu_type_i;
204              data_sign_ext_q <= lsu_sign_ext_i;
205              data_we_q       <= lsu_we_i;
206            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


212            if (!rst_ni) begin
               -1-  
213              addr_last_q <= '0;
                 ==>
214            end else if (addr_update) begin
                        -2-  
215              addr_last_q <= data_addr;
                 ==>
216            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


221            unique case (rdata_offset_q)
                      -1-  
222              2'b00:   rdata_w_ext =  data_rdata_i[31:0];
                 ==>
223              2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};
                 ==>
224              2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};
                 ==>
225              2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};
                 ==>
226              default: rdata_w_ext =  data_rdata_i[31:0];
                 ==>

Branches:

-1-     Status      
2'b00   Covered     
2'b01   Not Covered 
2'b10   Not Covered 
2'b11   Not Covered 
default Not Covered 


236            unique case (rdata_offset_q)
                      -1-  
237              2'b00: begin
238                if (!data_sign_ext_q) begin
                   -2-  
239                  rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
                     ==>
240                end else begin
241                  rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};
                     ==>
242                end
243              end
244        
245              2'b01: begin
246                if (!data_sign_ext_q) begin
                   -3-  
247                  rdata_h_ext = {16'h0000, data_rdata_i[23:8]};
                     ==>
248                end else begin
249                  rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};
                     ==>
250                end
251              end
252        
253              2'b10: begin
254                if (!data_sign_ext_q) begin
                   -4-  
255                  rdata_h_ext = {16'h0000, data_rdata_i[31:16]};
                     ==>
256                end else begin
257                  rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};
                     ==>
258                end
259              end
260        
261              2'b11: begin
262                if (!data_sign_ext_q) begin
                   -5-  
263                  rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};
                     ==>
264                end else begin
265                  rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};
                     ==>
266                end
267              end
268        
269              default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
                 ==>

Branches:

-1-     -2- -3- -4- -5- Status      
2'b00   1   -   -   -   Covered     
2'b00   0   -   -   -   Not Covered 
2'b01   -   1   -   -   Not Covered 
2'b01   -   0   -   -   Not Covered 
2'b10   -   -   1   -   Not Covered 
2'b10   -   -   0   -   Not Covered 
2'b11   -   -   -   1   Not Covered 
2'b11   -   -   -   0   Not Covered 
default -   -   -   -   Not Covered 


275            unique case (rdata_offset_q)
                      -1-  
276              2'b00: begin
277                if (!data_sign_ext_q) begin
                   -2-  
278                  rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
                     ==>
279                end else begin
280                  rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};
                     ==>
281                end
282              end
283        
284              2'b01: begin
285                if (!data_sign_ext_q) begin
                   -3-  
286                  rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};
                     ==>
287                end else begin
288                  rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};
                     ==>
289                end
290              end
291        
292              2'b10: begin
293                if (!data_sign_ext_q) begin
                   -4-  
294                  rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};
                     ==>
295                end else begin
296                  rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};
                     ==>
297                end
298              end
299        
300              2'b11: begin
301                if (!data_sign_ext_q) begin
                   -5-  
302                  rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};
                     ==>
303                end else begin
304                  rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};
                     ==>
305                end
306              end
307        
308              default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
                 ==>

Branches:

-1-     -2- -3- -4- -5- Status      
2'b00   1   -   -   -   Covered     
2'b00   0   -   -   -   Not Covered 
2'b01   -   1   -   -   Not Covered 
2'b01   -   0   -   -   Not Covered 
2'b10   -   -   1   -   Not Covered 
2'b10   -   -   0   -   Not Covered 
2'b11   -   -   -   1   Not Covered 
2'b11   -   -   -   0   Not Covered 
default -   -   -   -   Not Covered 


314            unique case (data_type_q)
                      -1-  
315              2'b00:       data_rdata_ext = rdata_w_ext;
                 ==>
316              2'b01:       data_rdata_ext = rdata_h_ext;
                 ==>
317              2'b10,2'b11: data_rdata_ext = rdata_b_ext;
                 ==>
318              default:     data_rdata_ext = rdata_w_ext;
                 ==>

Branches:

-1-          Status      
2'b00        Covered     
2'b01        Not Covered 
2'b10 2'b11  Not Covered 
default      Not Covered 


348            unique case (ls_fsm_cs)
                      -1-  
349        
350              IDLE: begin
351                pmp_err_d = 1'b0;
352                if (lsu_req_i) begin
                   -2-  
353                  data_req_o   = 1'b1;
354                  pmp_err_d    = data_pmp_err_i;
355                  lsu_err_d    = 1'b0;
356                  perf_load_o  = ~lsu_we_i;
357                  perf_store_o = lsu_we_i;
358        
359                  if (data_gnt_i) begin
                     -3-  
360                    ctrl_update         = 1'b1;
361                    addr_update         = 1'b1;
362                    handle_misaligned_d = split_misaligned_access;
363                    ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : IDLE;
                                                                     -4-  
                                                                     ==>  
                                                                     ==>  
364                  end else begin
365                    ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;
                                                                     -5-  
                                                                     ==>  
                                                                     ==>  
366                  end
367                end
                   MISSING_ELSE
                   ==>
368              end
369        
370              WAIT_GNT_MIS: begin
371                data_req_o = 1'b1;
372                // data_pmp_err_i is valid during the address phase of a request. An error will block the
373                // external request and so a data_gnt_i might never be signalled. The registered version
374                // pmp_err_q is only updated for new address phases and so can be used in WAIT_GNT* and
375                // WAIT_RVALID* states
376                if (data_gnt_i || pmp_err_q) begin
                   -6-  
377                  addr_update         = 1'b1;
                     ==>
378                  ctrl_update         = 1'b1;
379                  handle_misaligned_d = 1'b1;
380                  ls_fsm_ns           = WAIT_RVALID_MIS;
381                end
                   MISSING_ELSE
                   ==>
382              end
383        
384              WAIT_RVALID_MIS: begin
385                // push out second request
386                data_req_o = 1'b1;
387                // tell ID/EX stage to update the address
388                addr_incr_req_o = 1'b1;
389        
390                // first part rvalid is received, or gets a PMP error
391                if (data_rvalid_i || pmp_err_q) begin
                   -7-  
392                  // Update the PMP error for the second part
393                  pmp_err_d = data_pmp_err_i;
394                  // Record the error status of the first part
395                  lsu_err_d = data_err_i | pmp_err_q;
396                  // Capture the first rdata for loads
397                  rdata_update = ~data_we_q;
398                  // If already granted, wait for second rvalid
399                  ls_fsm_ns = data_gnt_i ? IDLE : WAIT_GNT;
                                            -8-  
                                            ==>  
                                            ==>  
400                  // Update the address for the second part, if no error
401                  addr_update = data_gnt_i & ~(data_err_i | pmp_err_q);
402                  // clear handle_misaligned if second request is granted
403                  handle_misaligned_d = ~data_gnt_i;
404                end else begin
405                  // first part rvalid is NOT received
406                  if (data_gnt_i) begin
                     -9-  
407                    // second grant is received
408                    ls_fsm_ns = WAIT_RVALID_MIS_GNTS_DONE;
                       ==>
409                    handle_misaligned_d = 1'b0;
410                  end
                     MISSING_ELSE
                     ==>
411                end
412              end
413        
414              WAIT_GNT: begin
415                // tell ID/EX stage to update the address
416                addr_incr_req_o = handle_misaligned_q;
417                data_req_o      = 1'b1;
418                if (data_gnt_i || pmp_err_q) begin
                   -10-  
419                  ctrl_update         = 1'b1;
                     ==>
420                  // Update the address, unless there was an error
421                  addr_update         = ~lsu_err_q;
422                  ls_fsm_ns           = IDLE;
423                  handle_misaligned_d = 1'b0;
424                end
                   MISSING_ELSE
                   ==>
425              end
426        
427              WAIT_RVALID_MIS_GNTS_DONE: begin
428                // tell ID/EX stage to update the address (to make sure the
429                // second address can be captured correctly for mtval and PMP checking)
430                addr_incr_req_o = 1'b1;
431                // Wait for the first rvalid, second request is already granted
432                if (data_rvalid_i) begin
                   -11-  
433                  // Update the pmp error for the second part
434                  pmp_err_d = data_pmp_err_i;
                     ==>
435                  // The first part cannot see a PMP error in this state
436                  lsu_err_d = data_err_i;
437                  // Now we can update the address for the second part if no error
438                  addr_update = ~data_err_i;
439                  // Capture the first rdata for loads
440                  rdata_update = ~data_we_q;
441                  // Wait for second rvalid
442                  ls_fsm_ns = IDLE;
443                end
                   MISSING_ELSE
                   ==>
444              end
445        
446              default: begin
447                ls_fsm_ns = IDLE;
                   ==>

Branches:

-1-                        -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- Status      
IDLE                       1   1   1   -   -   -   -   -   -    -    Not Covered 
IDLE                       1   1   0   -   -   -   -   -   -    -    Not Covered 
IDLE                       1   0   -   1   -   -   -   -   -    -    Not Covered 
IDLE                       1   0   -   0   -   -   -   -   -    -    Not Covered 
IDLE                       0   -   -   -   -   -   -   -   -    -    Covered     
WAIT_GNT_MIS               -   -   -   -   1   -   -   -   -    -    Not Covered 
WAIT_GNT_MIS               -   -   -   -   0   -   -   -   -    -    Not Covered 
WAIT_RVALID_MIS            -   -   -   -   -   1   1   -   -    -    Not Covered 
WAIT_RVALID_MIS            -   -   -   -   -   1   0   -   -    -    Not Covered 
WAIT_RVALID_MIS            -   -   -   -   -   0   -   1   -    -    Not Covered 
WAIT_RVALID_MIS            -   -   -   -   -   0   -   0   -    -    Not Covered 
WAIT_GNT                   -   -   -   -   -   -   -   -   1    -    Not Covered 
WAIT_GNT                   -   -   -   -   -   -   -   -   0    -    Not Covered 
WAIT_RVALID_MIS_GNTS_DONE  -   -   -   -   -   -   -   -   -    1    Not Covered 
WAIT_RVALID_MIS_GNTS_DONE  -   -   -   -   -   -   -   -   -    0    Not Covered 
default                    -   -   -   -   -   -   -   -   -    -    Covered     


456            if (!rst_ni) begin
               -1-  
457              ls_fsm_cs           <= IDLE;
                 ==>
458              handle_misaligned_q <= '0;
459              pmp_err_q           <= '0;
460              lsu_err_q           <= '0;
461            end else begin
462              ls_fsm_cs           <= ls_fsm_ns;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_load_store_unit
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       7     7         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            7     7         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                  Attempts Real Successes Failures Incomplete 
IbexDataAddrUnaligned 3        0              0        0          
IbexDataAddrUnknown   3        0              0        0          
IbexDataOffsetKnown   3        0              0        0          
IbexDataTypeKnown     3        0              0        0          
IbexDataTypeQKnown    3        0              0        0          
IbexLsuStateValid     3        0              0        0          
IbexRDataOffsetQKnown 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.load_store_unit_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.62  28.30   0.00   0.00  14.81   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.62  28.30   0.00   0.00  14.81   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                 
  8.62  28.30   0.00   0.00  14.81   0.00 ibex_load_store_unit 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME        
 20.58  43.66  14.29   0.00  28.26  16.67 u_ibex_core 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_cs_registers
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 12.83  29.73  23.08   0.00  11.34   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_cs_registers.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                             
 12.83  29.73  23.08   0.00  11.34   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_cs_registers

             Line No.   Total   Covered  Percent
TOTAL                      222       66    29.73
ALWAYS            293       84        4     4.76
ALWAYS            496      102       32    31.37
ALWAYS            714        3        2    66.67
ALWAYS            730        6        3    50.00
ALWAYS           1167        3        2    66.67
ALWAYS           1179       15       15   100.00
ALWAYS           1207        6        6   100.00
ALWAYS           1284        3        2    66.67

292                       always_comb begin
293        1/1              csr_rdata_int = '0;
294        1/1              illegal_csr   = 1'b0;
295                     
296        1/1              unique case (csr_addr_i)
297                           // mhartid: unique hardware thread id
298        0/1     ==>        CSR_MHARTID: csr_rdata_int = hart_id_i;
299                     
300                           // mstatus: always M-mode, contains IE bit
301                           CSR_MSTATUS: begin
302        0/1     ==>          csr_rdata_int                                                   = '0;
303        0/1     ==>          csr_rdata_int[CSR_MSTATUS_MIE_BIT]                              = mstatus_q.mie;
304        0/1     ==>          csr_rdata_int[CSR_MSTATUS_MPIE_BIT]                             = mstatus_q.mpie;
305        0/1     ==>          csr_rdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW] = mstatus_q.mpp;
306        0/1     ==>          csr_rdata_int[CSR_MSTATUS_MPRV_BIT]                             = mstatus_q.mprv;
307        0/1     ==>          csr_rdata_int[CSR_MSTATUS_TW_BIT]                               = mstatus_q.tw;
308                           end
309                     
310                           // misa
311        0/1     ==>        CSR_MISA: csr_rdata_int = MISA_VALUE;
312                     
313                           // interrupt enable
314                           CSR_MIE: begin
315        0/1     ==>          csr_rdata_int                                     = '0;
316        0/1     ==>          csr_rdata_int[CSR_MSIX_BIT]                       = mie_q.irq_software;
317        0/1     ==>          csr_rdata_int[CSR_MTIX_BIT]                       = mie_q.irq_timer;
318        0/1     ==>          csr_rdata_int[CSR_MEIX_BIT]                       = mie_q.irq_external;
319        0/1     ==>          csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mie_q.irq_fast;
320                           end
321                     
322                           // mcounteren: machine counter enable
323                           CSR_MCOUNTEREN: begin
324        0/1     ==>          csr_rdata_int = '0;
325        0/1     ==>          illegal_csr   = ~DbgTriggerEn;
326                           end
327                     
328        0/1     ==>        CSR_MSCRATCH: csr_rdata_int = mscratch_q;
329                     
330                           // mtvec: trap-vector base address
331        0/1     ==>        CSR_MTVEC: csr_rdata_int = mtvec_q;
332                     
333                           // mepc: exception program counter
334        0/1     ==>        CSR_MEPC: csr_rdata_int = mepc_q;
335                     
336                           // mcause: exception cause
337        0/1     ==>        CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};
338                     
339                           // mtval: trap value
340        0/1     ==>        CSR_MTVAL: csr_rdata_int = mtval_q;
341                     
342                           // mip: interrupt pending
343                           CSR_MIP: begin
344        0/1     ==>          csr_rdata_int                                     = '0;
345        0/1     ==>          csr_rdata_int[CSR_MSIX_BIT]                       = mip.irq_software;
346        0/1     ==>          csr_rdata_int[CSR_MTIX_BIT]                       = mip.irq_timer;
347        0/1     ==>          csr_rdata_int[CSR_MEIX_BIT]                       = mip.irq_external;
348        0/1     ==>          csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mip.irq_fast;
349                           end
350                     
351                           CSR_MSECCFG: begin
352        0/1     ==>          if (PMPEnable) begin
353        0/1     ==>            csr_rdata_int                       = '0;
354        0/1     ==>            csr_rdata_int[CSR_MSECCFG_MML_BIT]  = pmp_mseccfg.mml;
355        0/1     ==>            csr_rdata_int[CSR_MSECCFG_MMWP_BIT] = pmp_mseccfg.mmwp;
356        0/1     ==>            csr_rdata_int[CSR_MSECCFG_RLB_BIT]  = pmp_mseccfg.rlb;
357                             end else begin
358        0/1     ==>            illegal_csr = 1'b1;
359                             end
360                           end
361                     
362                           CSR_MSECCFGH: begin
363        0/1     ==>          if (PMPEnable) begin
364        0/1     ==>            csr_rdata_int = '0;
365                             end else begin
366        0/1     ==>            illegal_csr = 1'b1;
367                             end
368                           end
369                     
370                           // PMP registers
371        0/1     ==>        CSR_PMPCFG0:   csr_rdata_int = {pmp_cfg_rdata[3],  pmp_cfg_rdata[2],
372                                                           pmp_cfg_rdata[1],  pmp_cfg_rdata[0]};
373        0/1     ==>        CSR_PMPCFG1:   csr_rdata_int = {pmp_cfg_rdata[7],  pmp_cfg_rdata[6],
374                                                           pmp_cfg_rdata[5],  pmp_cfg_rdata[4]};
375        0/1     ==>        CSR_PMPCFG2:   csr_rdata_int = {pmp_cfg_rdata[11], pmp_cfg_rdata[10],
376                                                           pmp_cfg_rdata[9],  pmp_cfg_rdata[8]};
377        0/1     ==>        CSR_PMPCFG3:   csr_rdata_int = {pmp_cfg_rdata[15], pmp_cfg_rdata[14],
378                                                           pmp_cfg_rdata[13], pmp_cfg_rdata[12]};
379        0/1     ==>        CSR_PMPADDR0:  csr_rdata_int = pmp_addr_rdata[0];
380        0/1     ==>        CSR_PMPADDR1:  csr_rdata_int = pmp_addr_rdata[1];
381        0/1     ==>        CSR_PMPADDR2:  csr_rdata_int = pmp_addr_rdata[2];
382        0/1     ==>        CSR_PMPADDR3:  csr_rdata_int = pmp_addr_rdata[3];
383        0/1     ==>        CSR_PMPADDR4:  csr_rdata_int = pmp_addr_rdata[4];
384        0/1     ==>        CSR_PMPADDR5:  csr_rdata_int = pmp_addr_rdata[5];
385        0/1     ==>        CSR_PMPADDR6:  csr_rdata_int = pmp_addr_rdata[6];
386        0/1     ==>        CSR_PMPADDR7:  csr_rdata_int = pmp_addr_rdata[7];
387        0/1     ==>        CSR_PMPADDR8:  csr_rdata_int = pmp_addr_rdata[8];
388        0/1     ==>        CSR_PMPADDR9:  csr_rdata_int = pmp_addr_rdata[9];
389        0/1     ==>        CSR_PMPADDR10: csr_rdata_int = pmp_addr_rdata[10];
390        0/1     ==>        CSR_PMPADDR11: csr_rdata_int = pmp_addr_rdata[11];
391        0/1     ==>        CSR_PMPADDR12: csr_rdata_int = pmp_addr_rdata[12];
392        0/1     ==>        CSR_PMPADDR13: csr_rdata_int = pmp_addr_rdata[13];
393        0/1     ==>        CSR_PMPADDR14: csr_rdata_int = pmp_addr_rdata[14];
394        0/1     ==>        CSR_PMPADDR15: csr_rdata_int = pmp_addr_rdata[15];
395                     
396                           CSR_DCSR: begin
397        0/1     ==>          csr_rdata_int = dcsr_q;
398        0/1     ==>          illegal_csr = ~debug_mode_i;
399                           end
400                           CSR_DPC: begin
401        0/1     ==>          csr_rdata_int = depc_q;
402        0/1     ==>          illegal_csr = ~debug_mode_i;
403                           end
404                           CSR_DSCRATCH0: begin
405        0/1     ==>          csr_rdata_int = dscratch0_q;
406        0/1     ==>          illegal_csr = ~debug_mode_i;
407                           end
408                           CSR_DSCRATCH1: begin
409        0/1     ==>          csr_rdata_int = dscratch1_q;
410        0/1     ==>          illegal_csr = ~debug_mode_i;
411                           end
412                     
413                           // machine counter/timers
414        0/1     ==>        CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit;
415                           CSR_MHPMEVENT3,
416                           CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,
417                           CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,
418                           CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,
419                           CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,
420                           CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,
421                           CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,
422                           CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31: begin
423        0/1     ==>          csr_rdata_int = mhpmevent[mhpmcounter_idx];
424                           end
425                     
426                           CSR_MCYCLE,
427                           CSR_MINSTRET,
428                           CSR_MHPMCOUNTER3,
429                           CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
430                           CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
431                           CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
432                           CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
433                           CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
434                           CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
435                           CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
436        0/1     ==>          csr_rdata_int = mhpmcounter[mhpmcounter_idx][31:0];
437                           end
438                     
439                           CSR_MCYCLEH,
440                           CSR_MINSTRETH,
441                           CSR_MHPMCOUNTER3H,
442                           CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
443                           CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
444                           CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
445                           CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
446                           CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
447                           CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
448                           CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
449        0/1     ==>          csr_rdata_int = mhpmcounter[mhpmcounter_idx][63:32];
450                           end
451                     
452                           // Debug triggers
453                           CSR_TSELECT: begin
454        0/1     ==>          csr_rdata_int = tselect_rdata;
455        0/1     ==>          illegal_csr   = ~DbgTriggerEn;
456                           end
457                           CSR_TDATA1: begin
458        0/1     ==>          csr_rdata_int = tmatch_control_rdata;
459        0/1     ==>          illegal_csr   = ~DbgTriggerEn;
460                           end
461                           CSR_TDATA2: begin
462        0/1     ==>          csr_rdata_int = tmatch_value_rdata;
463        0/1     ==>          illegal_csr   = ~DbgTriggerEn;
464                           end
465                           CSR_TDATA3: begin
466        0/1     ==>          csr_rdata_int = '0;
467        0/1     ==>          illegal_csr   = ~DbgTriggerEn;
468                           end
469                           CSR_MCONTEXT: begin
470        0/1     ==>          csr_rdata_int = '0;
471        0/1     ==>          illegal_csr   = ~DbgTriggerEn;
472                           end
473                           CSR_SCONTEXT: begin
474        0/1     ==>          csr_rdata_int = '0;
475        0/1     ==>          illegal_csr   = ~DbgTriggerEn;
476                           end
477                     
478                           // Custom CSR for controlling CPU features
479                           CSR_CPUCTRL: begin
480        0/1     ==>          csr_rdata_int = {{32-$bits(cpu_ctrl_t){1'b0}},cpuctrl_q};
481                           end
482                     
483                           // Custom CSR for LFSR re-seeding (cannot be read)
484                           CSR_SECURESEED: begin
485        0/1     ==>          csr_rdata_int = '0;
486                           end
487                     
488                           default: begin
489        1/1                  illegal_csr = 1'b1;
490                           end
491                         endcase
492                       end
493                     
494                       // write logic
495                       always_comb begin
496        1/1              exception_pc = pc_id_i;
497                     
498        1/1              priv_lvl_d   = priv_lvl_q;
499        1/1              mstatus_en   = 1'b0;
500        1/1              mstatus_d    = mstatus_q;
501        1/1              mie_en       = 1'b0;
502        1/1              mscratch_en  = 1'b0;
503        1/1              mepc_en      = 1'b0;
504        1/1              mepc_d       = {csr_wdata_int[31:1], 1'b0};
505        1/1              mcause_en    = 1'b0;
506        1/1              mcause_d     = {csr_wdata_int[31], csr_wdata_int[4:0]};
507        1/1              mtval_en     = 1'b0;
508        1/1              mtval_d      = csr_wdata_int;
509        1/1              mtvec_en     = csr_mtvec_init_i;
510                         // mtvec.MODE set to vectored
511                         // mtvec.BASE must be 256-byte aligned
512        1/1              mtvec_d      = csr_mtvec_init_i ? {boot_addr_i[31:8], 6'b0, 2'b01} :
513                                                           {csr_wdata_int[31:8], 6'b0, 2'b01};
514        1/1              dcsr_en      = 1'b0;
515        1/1              dcsr_d       = dcsr_q;
516        1/1              depc_d       = {csr_wdata_int[31:1], 1'b0};
517        1/1              depc_en      = 1'b0;
518        1/1              dscratch0_en = 1'b0;
519        1/1              dscratch1_en = 1'b0;
520                     
521        1/1              mstack_en      = 1'b0;
522        1/1              mstack_d.mpie  = mstatus_q.mpie;
523        1/1              mstack_d.mpp   = mstatus_q.mpp;
524        1/1              mstack_epc_d   = mepc_q;
525        1/1              mstack_cause_d = mcause_q;
526                     
527        1/1              mcountinhibit_we = 1'b0;
528        1/1              mhpmcounter_we   = '0;
529        1/1              mhpmcounterh_we  = '0;
530                     
531        1/1              cpuctrl_we       = 1'b0;
532                     
533        1/1              if (csr_we_int) begin
534        0/1     ==>        unique case (csr_addr_i)
535                             // mstatus: IE bit
536                             CSR_MSTATUS: begin
537        0/1     ==>            mstatus_en = 1'b1;
538        0/1     ==>            mstatus_d    = '{
539                                   mie:  csr_wdata_int[CSR_MSTATUS_MIE_BIT],
540                                   mpie: csr_wdata_int[CSR_MSTATUS_MPIE_BIT],
541                                   mpp:  priv_lvl_e'(csr_wdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW]),
542                                   mprv: csr_wdata_int[CSR_MSTATUS_MPRV_BIT],
543                                   tw:   csr_wdata_int[CSR_MSTATUS_TW_BIT]
544                               };
545                               // Convert illegal values to M-mode
546        0/1     ==>            if ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U)) begin
547        0/1     ==>              mstatus_d.mpp = PRIV_LVL_M;
548                               end
                   ==>  MISSING_ELSE
549                             end
550                     
551                             // interrupt enable
552        0/1     ==>          CSR_MIE: mie_en = 1'b1;
553                     
554        0/1     ==>          CSR_MSCRATCH: mscratch_en = 1'b1;
555                     
556                             // mepc: exception program counter
557        0/1     ==>          CSR_MEPC: mepc_en = 1'b1;
558                     
559                             // mcause
560        0/1     ==>          CSR_MCAUSE: mcause_en = 1'b1;
561                     
562                             // mtval: trap value
563        0/1     ==>          CSR_MTVAL: mtval_en = 1'b1;
564                     
565                             // mtvec
566        0/1     ==>          CSR_MTVEC: mtvec_en = 1'b1;
567                     
568                             CSR_DCSR: begin
569        0/1     ==>            dcsr_d = csr_wdata_int;
570        0/1     ==>            dcsr_d.xdebugver = XDEBUGVER_STD;
571                               // Change to PRIV_LVL_M if software writes an unsupported value
572        0/1     ==>            if ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U)) begin
573        0/1     ==>              dcsr_d.prv = PRIV_LVL_M;
574                               end
                   ==>  MISSING_ELSE
575                     
576                               // Read-only for SW
577        0/1     ==>            dcsr_d.cause = dcsr_q.cause;
578                     
579                               // Interrupts always disabled during single stepping
580        0/1     ==>            dcsr_d.stepie = 1'b0;
581                     
582                               // currently not supported:
583        0/1     ==>            dcsr_d.nmip = 1'b0;
584        0/1     ==>            dcsr_d.mprven = 1'b0;
585        0/1     ==>            dcsr_d.stopcount = 1'b0;
586        0/1     ==>            dcsr_d.stoptime = 1'b0;
587                     
588                               // forced to be zero
589        0/1     ==>            dcsr_d.zero0 = 1'b0;
590        0/1     ==>            dcsr_d.zero1 = 1'b0;
591        0/1     ==>            dcsr_d.zero2 = 12'h0;
592        0/1     ==>            dcsr_en      = 1'b1;
593                             end
594                     
595                             // dpc: debug program counter
596        0/1     ==>          CSR_DPC: depc_en = 1'b1;
597                     
598        0/1     ==>          CSR_DSCRATCH0: dscratch0_en = 1'b1;
599        0/1     ==>          CSR_DSCRATCH1: dscratch1_en = 1'b1;
600                     
601                             // machine counter/timers
602        0/1     ==>          CSR_MCOUNTINHIBIT: mcountinhibit_we = 1'b1;
603                     
604                             CSR_MCYCLE,
605                             CSR_MINSTRET,
606                             CSR_MHPMCOUNTER3,
607                             CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
608                             CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
609                             CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
610                             CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
611                             CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
612                             CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
613                             CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
614        0/1     ==>            mhpmcounter_we[mhpmcounter_idx] = 1'b1;
615                             end
616                     
617                             CSR_MCYCLEH,
618                             CSR_MINSTRETH,
619                             CSR_MHPMCOUNTER3H,
620                             CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
621                             CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
622                             CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
623                             CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
624                             CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
625                             CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
626                             CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
627        0/1     ==>            mhpmcounterh_we[mhpmcounter_idx] = 1'b1;
628                             end
629                     
630        0/1     ==>          CSR_CPUCTRL: cpuctrl_we = 1'b1;
631                     
632        0/1     ==>          default:;
633                           endcase
634                         end
                        MISSING_ELSE
635                     
636                         // exception controller gets priority over other writes
637        1/1              unique case (1'b1)
638                     
639                           csr_save_cause_i: begin
640        0/1     ==>          unique case (1'b1)
641                               csr_save_if_i: begin
642        0/1     ==>              exception_pc = pc_if_i;
643                               end
644                               csr_save_id_i: begin
645        0/1     ==>              exception_pc = pc_id_i;
646                               end
647                               csr_save_wb_i: begin
648        0/1     ==>              exception_pc = pc_wb_i;
649                               end
650        0/1     ==>            default:;
651                             endcase
652                     
653                             // Any exception, including debug mode, causes a switch to M-mode
654        0/1     ==>          priv_lvl_d = PRIV_LVL_M;
655                     
656        0/1     ==>          if (debug_csr_save_i) begin
657                               // all interrupts are masked
658                               // do not update cause, epc, tval, epc and status
659        0/1     ==>            dcsr_d.prv   = priv_lvl_q;
660        0/1     ==>            dcsr_d.cause = debug_cause_i;
661        0/1     ==>            dcsr_en      = 1'b1;
662        0/1     ==>            depc_d       = exception_pc;
663        0/1     ==>            depc_en      = 1'b1;
664        0/1     ==>          end else if (!debug_mode_i) begin
665                               // In debug mode, "exceptions do not update any registers. That
666                               // includes cause, epc, tval, dpc and mstatus." [Debug Spec v0.13.2, p.39]
667        0/1     ==>            mtval_en       = 1'b1;
668        0/1     ==>            mtval_d        = csr_mtval_i;
669        0/1     ==>            mstatus_en     = 1'b1;
670        0/1     ==>            mstatus_d.mie  = 1'b0; // disable interrupts
671                               // save current status
672        0/1     ==>            mstatus_d.mpie = mstatus_q.mie;
673        0/1     ==>            mstatus_d.mpp  = priv_lvl_q;
674        0/1     ==>            mepc_en        = 1'b1;
675        0/1     ==>            mepc_d         = exception_pc;
676        0/1     ==>            mcause_en      = 1'b1;
677        0/1     ==>            mcause_d       = {csr_mcause_i};
678                               // save previous status for recoverable NMI
679        0/1     ==>            mstack_en      = 1'b1;
680                             end
                   ==>  MISSING_ELSE
681                           end // csr_save_cause_i
682                     
683                           csr_restore_dret_i: begin // DRET
684        0/1     ==>          priv_lvl_d = dcsr_q.prv;
685                           end // csr_restore_dret_i
686                     
687                           csr_restore_mret_i: begin // MRET
688        0/1     ==>          priv_lvl_d     = mstatus_q.mpp;
689        0/1     ==>          mstatus_en     = 1'b1;
690        0/1     ==>          mstatus_d.mie  = mstatus_q.mpie; // re-enable interrupts
691                     
692        0/1     ==>          if (nmi_mode_i) begin
693                               // when returning from an NMI restore state from mstack CSR
694        0/1     ==>            mstatus_d.mpie = mstack_q.mpie;
695        0/1     ==>            mstatus_d.mpp  = mstack_q.mpp;
696        0/1     ==>            mepc_en        = 1'b1;
697        0/1     ==>            mepc_d         = mstack_epc_q;
698        0/1     ==>            mcause_en      = 1'b1;
699        0/1     ==>            mcause_d       = mstack_cause_q;
700                             end else begin
701                               // otherwise just set mstatus.MPIE/MPP
702                               // See RISC-V Privileged Specification, version 1.11, Section 3.1.6.1
703        0/1     ==>            mstatus_d.mpie = 1'b1;
704        0/1     ==>            mstatus_d.mpp  = PRIV_LVL_U;
705                             end
706                           end // csr_restore_mret_i
707                     
708        1/1                default:;
709                         endcase
710                       end
711                     
712                       // Update current priv level
713                       always_ff @(posedge clk_i or negedge rst_ni) begin
714        1/1              if (!rst_ni) begin
715        1/1                priv_lvl_q     <= PRIV_LVL_M;
716                         end else begin
717        0/1     ==>        priv_lvl_q     <= priv_lvl_d;
718                         end
719                       end
720                     
721                       // Send current priv level to the decoder
722                       assign priv_mode_id_o = priv_lvl_q;
723                       // New instruction fetches need to account for updates to priv_lvl_q this cycle
724                       assign priv_mode_if_o = priv_lvl_d;
725                       // Load/store instructions must factor in MPRV for PMP checking
726                       assign priv_mode_lsu_o = mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q;
727                     
728                       // CSR operation logic
729                       always_comb begin
730        1/1              unique case (csr_op_i)
731        0/1     ==>        CSR_OP_WRITE: csr_wdata_int =  csr_wdata_i;
732        0/1     ==>        CSR_OP_SET:   csr_wdata_int =  csr_wdata_i | csr_rdata_o;
733        0/1     ==>        CSR_OP_CLEAR: csr_wdata_int = ~csr_wdata_i & csr_rdata_o;
734        1/1                CSR_OP_READ:  csr_wdata_int = csr_wdata_i;
735        1/1                default:      csr_wdata_int = csr_wdata_i;
736                         endcase
737                       end
738                     
739                       assign csr_wr = (csr_op_i inside {CSR_OP_WRITE, CSR_OP_SET, CSR_OP_CLEAR});
740                     
741                       // only write CSRs during one clock cycle
742                       assign csr_we_int  = csr_wr & csr_op_en_i & ~illegal_csr_insn_o;
743                     
744                       assign csr_rdata_o = csr_rdata_int;
745                     
746                       // directly output some registers
747                       assign csr_mepc_o  = mepc_q;
748                       assign csr_depc_o  = depc_q;
749                       assign csr_mtvec_o = mtvec_q;
750                     
751                       assign csr_mstatus_mie_o   = mstatus_q.mie;
752                       assign csr_mstatus_tw_o    = mstatus_q.tw;
753                       assign debug_single_step_o = dcsr_q.step;
754                       assign debug_ebreakm_o     = dcsr_q.ebreakm;
755                       assign debug_ebreaku_o     = dcsr_q.ebreaku;
756                     
757                       // Qualify incoming interrupt requests in mip CSR with mie CSR for controller and to re-enable
758                       // clock upon WFI (must be purely combinational).
759                       assign irqs_o        = mip & mie_q;
760                       assign irq_pending_o = |irqs_o;
761                     
762                       ////////////////////////
763                       // CSR instantiations //
764                       ////////////////////////
765                     
766                       // MSTATUS
767                       localparam status_t MSTATUS_RST_VAL = '{mie:  1'b0,
768                                                               mpie: 1'b1,
769                                                               mpp:  PRIV_LVL_U,
770                                                               mprv: 1'b0,
771                                                               tw:   1'b0};
772                       ibex_csr #(
773                         .Width      ($bits(status_t)),
774                         .ShadowCopy (ShadowCSR),
775                         .ResetValue ({MSTATUS_RST_VAL})
776                       ) u_mstatus_csr (
777                         .clk_i      (clk_i),
778                         .rst_ni     (rst_ni),
779                         .wr_data_i  ({mstatus_d}),
780                         .wr_en_i    (mstatus_en),
781                         .rd_data_o  (mstatus_q),
782                         .rd_error_o (mstatus_err)
783                       );
784                     
785                       // MEPC
786                       ibex_csr #(
787                         .Width      (32),
788                         .ShadowCopy (1'b0),
789                         .ResetValue ('0)
790                       ) u_mepc_csr (
791                         .clk_i      (clk_i),
792                         .rst_ni     (rst_ni),
793                         .wr_data_i  (mepc_d),
794                         .wr_en_i    (mepc_en),
795                         .rd_data_o  (mepc_q),
796                         .rd_error_o ()
797                       );
798                     
799                       // MIE
800                       assign mie_d.irq_software = csr_wdata_int[CSR_MSIX_BIT];
801                       assign mie_d.irq_timer    = csr_wdata_int[CSR_MTIX_BIT];
802                       assign mie_d.irq_external = csr_wdata_int[CSR_MEIX_BIT];
803                       assign mie_d.irq_fast     = csr_wdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW];
804                       ibex_csr #(
805                         .Width      ($bits(irqs_t)),
806                         .ShadowCopy (1'b0),
807                         .ResetValue ('0)
808                       ) u_mie_csr (
809                         .clk_i      (clk_i),
810                         .rst_ni     (rst_ni),
811                         .wr_data_i  ({mie_d}),
812                         .wr_en_i    (mie_en),
813                         .rd_data_o  (mie_q),
814                         .rd_error_o ()
815                       );
816                     
817                       // MSCRATCH
818                       ibex_csr #(
819                         .Width      (32),
820                         .ShadowCopy (1'b0),
821                         .ResetValue ('0)
822                       ) u_mscratch_csr (
823                         .clk_i      (clk_i),
824                         .rst_ni     (rst_ni),
825                         .wr_data_i  (csr_wdata_int),
826                         .wr_en_i    (mscratch_en),
827                         .rd_data_o  (mscratch_q),
828                         .rd_error_o ()
829                       );
830                     
831                       // MCAUSE
832                       ibex_csr #(
833                         .Width      (6),
834                         .ShadowCopy (1'b0),
835                         .ResetValue ('0)
836                       ) u_mcause_csr (
837                         .clk_i      (clk_i),
838                         .rst_ni     (rst_ni),
839                         .wr_data_i  (mcause_d),
840                         .wr_en_i    (mcause_en),
841                         .rd_data_o  (mcause_q),
842                         .rd_error_o ()
843                       );
844                     
845                       // MTVAL
846                       ibex_csr #(
847                         .Width      (32),
848                         .ShadowCopy (1'b0),
849                         .ResetValue ('0)
850                       ) u_mtval_csr (
851                         .clk_i      (clk_i),
852                         .rst_ni     (rst_ni),
853                         .wr_data_i  (mtval_d),
854                         .wr_en_i    (mtval_en),
855                         .rd_data_o  (mtval_q),
856                         .rd_error_o ()
857                       );
858                     
859                       // MTVEC
860                       ibex_csr #(
861                         .Width      (32),
862                         .ShadowCopy (ShadowCSR),
863                         .ResetValue (32'd1)
864                       ) u_mtvec_csr (
865                         .clk_i      (clk_i),
866                         .rst_ni     (rst_ni),
867                         .wr_data_i  (mtvec_d),
868                         .wr_en_i    (mtvec_en),
869                         .rd_data_o  (mtvec_q),
870                         .rd_error_o (mtvec_err)
871                       );
872                     
873                       // DCSR
874                       localparam dcsr_t DCSR_RESET_VAL = '{
875                           xdebugver: XDEBUGVER_STD,
876                           cause:     DBG_CAUSE_NONE, // 3'h0
877                           prv:       PRIV_LVL_M,
878                           default:   '0
879                       };
880                       ibex_csr #(
881                         .Width      ($bits(dcsr_t)),
882                         .ShadowCopy (1'b0),
883                         .ResetValue ({DCSR_RESET_VAL})
884                       ) u_dcsr_csr (
885                         .clk_i      (clk_i),
886                         .rst_ni     (rst_ni),
887                         .wr_data_i  ({dcsr_d}),
888                         .wr_en_i    (dcsr_en),
889                         .rd_data_o  (dcsr_q),
890                         .rd_error_o ()
891                       );
892                     
893                       // DEPC
894                       ibex_csr #(
895                         .Width      (32),
896                         .ShadowCopy (1'b0),
897                         .ResetValue ('0)
898                       ) u_depc_csr (
899                         .clk_i      (clk_i),
900                         .rst_ni     (rst_ni),
901                         .wr_data_i  (depc_d),
902                         .wr_en_i    (depc_en),
903                         .rd_data_o  (depc_q),
904                         .rd_error_o ()
905                       );
906                     
907                       // DSCRATCH0
908                       ibex_csr #(
909                         .Width      (32),
910                         .ShadowCopy (1'b0),
911                         .ResetValue ('0)
912                       ) u_dscratch0_csr (
913                         .clk_i      (clk_i),
914                         .rst_ni     (rst_ni),
915                         .wr_data_i  (csr_wdata_int),
916                         .wr_en_i    (dscratch0_en),
917                         .rd_data_o  (dscratch0_q),
918                         .rd_error_o ()
919                       );
920                     
921                       // DSCRATCH1
922                       ibex_csr #(
923                         .Width      (32),
924                         .ShadowCopy (1'b0),
925                         .ResetValue ('0)
926                       ) u_dscratch1_csr (
927                         .clk_i      (clk_i),
928                         .rst_ni     (rst_ni),
929                         .wr_data_i  (csr_wdata_int),
930                         .wr_en_i    (dscratch1_en),
931                         .rd_data_o  (dscratch1_q),
932                         .rd_error_o ()
933                       );
934                     
935                       // MSTACK
936                       localparam status_stk_t MSTACK_RESET_VAL = '{
937                           mpie: 1'b1,
938                           mpp:  PRIV_LVL_U
939                       };
940                       ibex_csr #(
941                         .Width      ($bits(status_stk_t)),
942                         .ShadowCopy (1'b0),
943                         .ResetValue ({MSTACK_RESET_VAL})
944                       ) u_mstack_csr (
945                         .clk_i      (clk_i),
946                         .rst_ni     (rst_ni),
947                         .wr_data_i  ({mstack_d}),
948                         .wr_en_i    (mstack_en),
949                         .rd_data_o  (mstack_q),
950                         .rd_error_o ()
951                       );
952                     
953                       // MSTACK_EPC
954                       ibex_csr #(
955                         .Width      (32),
956                         .ShadowCopy (1'b0),
957                         .ResetValue ('0)
958                       ) u_mstack_epc_csr (
959                         .clk_i      (clk_i),
960                         .rst_ni     (rst_ni),
961                         .wr_data_i  (mstack_epc_d),
962                         .wr_en_i    (mstack_en),
963                         .rd_data_o  (mstack_epc_q),
964                         .rd_error_o ()
965                       );
966                     
967                       // MSTACK_CAUSE
968                       ibex_csr #(
969                         .Width      (6),
970                         .ShadowCopy (1'b0),
971                         .ResetValue ('0)
972                       ) u_mstack_cause_csr (
973                         .clk_i      (clk_i),
974                         .rst_ni     (rst_ni),
975                         .wr_data_i  (mstack_cause_d),
976                         .wr_en_i    (mstack_en),
977                         .rd_data_o  (mstack_cause_q),
978                         .rd_error_o ()
979                       );
980                     
981                       // -----------------
982                       // PMP registers
983                       // -----------------
984                     
985                       if (PMPEnable) begin : g_pmp_registers
986                         pmp_mseccfg_t                pmp_mseccfg_q, pmp_mseccfg_d;
987                         logic                        pmp_mseccfg_we;
988                         logic                        pmp_mseccfg_err;
989                         pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
990                         logic [PMPNumRegions-1:0]    pmp_cfg_locked;
991                         pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
992                         logic [PMPAddrWidth-1:0]     pmp_addr        [PMPNumRegions];
993                         logic [PMPNumRegions-1:0]    pmp_cfg_we;
994                         logic [PMPNumRegions-1:0]    pmp_cfg_err;
995                         logic [PMPNumRegions-1:0]    pmp_addr_we;
996                         logic [PMPNumRegions-1:0]    pmp_addr_err;
997                         logic                        any_pmp_entry_locked;
998                     
999                         // Expanded / qualified register read data
1000                        for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_exp_rd_data
1001                          if (i < PMPNumRegions) begin : g_implemented_regions
1002                            // Add in zero padding for reserved fields
1003                            assign pmp_cfg_rdata[i] = {pmp_cfg[i].lock, 2'b00, pmp_cfg[i].mode,
1004                                                       pmp_cfg[i].exec, pmp_cfg[i].write, pmp_cfg[i].read};
1005                    
1006                            // Address field read data depends on the current programmed mode and the granularity
1007                            // See RISC-V Privileged Specification, version 1.11, Section 3.6.1
1008                            if (PMPGranularity == 0) begin : g_pmp_g0
1009                              // If G == 0, read data is unmodified
1010                              assign pmp_addr_rdata[i] = pmp_addr[i];
1011                    
1012                            end else if (PMPGranularity == 1) begin : g_pmp_g1
1013                              // If G == 1, bit [G-1] reads as zero in TOR or OFF mode
1014                              always_comb begin
1015                                pmp_addr_rdata[i] = pmp_addr[i];
1016                                if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin
1017                                  pmp_addr_rdata[i][PMPGranularity-1:0] = '0;
1018                                end
1019                              end
1020                    
1021                            end else begin : g_pmp_g2
1022                              // For G >= 2, bits are masked to one or zero depending on the mode
1023                              always_comb begin
1024                                // In NAPOT mode, bits [G-2:0] must read as one
1025                                pmp_addr_rdata[i] = {pmp_addr[i], {PMPGranularity-1{1'b1}}};
1026                    
1027                                if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin
1028                                  // In TOR or OFF mode, bits [G-1:0] must read as zero
1029                                  pmp_addr_rdata[i][PMPGranularity-1:0] = '0;
1030                                end
1031                              end
1032                            end
1033                    
1034                          end else begin : g_other_regions
1035                            // Non-implemented regions read as zero
1036                            assign pmp_cfg_rdata[i]  = '0;
1037                            assign pmp_addr_rdata[i] = '0;
1038                          end
1039                        end
1040                    
1041                        // Write data calculation
1042                        for (genvar i = 0; i < PMPNumRegions; i++) begin : g_pmp_csrs
1043                          // -------------------------
1044                          // Instantiate cfg registers
1045                          // -------------------------
1046                          assign pmp_cfg_we[i] = csr_we_int & ~pmp_cfg_locked[i] &
1047                                                 (csr_addr == (CSR_OFF_PMP_CFG + (i[11:0] >> 2)));
1048                    
1049                          // Select the correct WDATA (each CSR contains 4 CFG fields, each with 2 RES bits)
1050                          assign pmp_cfg_wdata[i].lock  = csr_wdata_int[(i%4)*PMP_CFG_W+7];
1051                          // NA4 mode is not selectable when G > 0, mode is treated as OFF
1052                          always_comb begin
1053                            unique case (csr_wdata_int[(i%4)*PMP_CFG_W+3+:2])
1054                              2'b00   : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;
1055                              2'b01   : pmp_cfg_wdata[i].mode = PMP_MODE_TOR;
1056                              2'b10   : pmp_cfg_wdata[i].mode = (PMPGranularity == 0) ? PMP_MODE_NA4:
1057                                                                                        PMP_MODE_OFF;
1058                              2'b11   : pmp_cfg_wdata[i].mode = PMP_MODE_NAPOT;
1059                              default : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;
1060                            endcase
1061                          end
1062                          assign pmp_cfg_wdata[i].exec  = csr_wdata_int[(i%4)*PMP_CFG_W+2];
1063                          // When MSECCFG.MML is unset, W = 1, R = 0 is a reserved combination, so force W to 0 if R ==
1064                          // 0. Otherwise allow all possible values to be written.
1065                          assign pmp_cfg_wdata[i].write = pmp_mseccfg_q.mml ? csr_wdata_int[(i%4)*PMP_CFG_W+1] :
1066                                                                              &csr_wdata_int[(i%4)*PMP_CFG_W+:2];
1067                          assign pmp_cfg_wdata[i].read  = csr_wdata_int[(i%4)*PMP_CFG_W];
1068                    
1069                          ibex_csr #(
1070                            .Width      ($bits(pmp_cfg_t)),
1071                            .ShadowCopy (ShadowCSR),
1072                            .ResetValue ('0)
1073                          ) u_pmp_cfg_csr (
1074                            .clk_i      (clk_i),
1075                            .rst_ni     (rst_ni),
1076                            .wr_data_i  ({pmp_cfg_wdata[i]}),
1077                            .wr_en_i    (pmp_cfg_we[i]),
1078                            .rd_data_o  (pmp_cfg[i]),
1079                            .rd_error_o (pmp_cfg_err[i])
1080                          );
1081                    
1082                          // MSECCFG.RLB allows the lock bit to be bypassed (allowing cfg writes when MSECCFG.RLB is
1083                          // set).
1084                          assign pmp_cfg_locked[i] = pmp_cfg[i].lock & ~pmp_mseccfg_q.rlb;
1085                    
1086                          // --------------------------
1087                          // Instantiate addr registers
1088                          // --------------------------
1089                          if (i < PMPNumRegions - 1) begin : g_lower
1090                            assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg_locked[i] &
1091                                                    (~pmp_cfg_locked[i+1] | (pmp_cfg[i+1].mode != PMP_MODE_TOR)) &
1092                                                    (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));
1093                          end else begin : g_upper
1094                            assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg_locked[i] &
1095                                                    (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));
1096                          end
1097                    
1098                          ibex_csr #(
1099                            .Width      (PMPAddrWidth),
1100                            .ShadowCopy (ShadowCSR),
1101                            .ResetValue ('0)
1102                          ) u_pmp_addr_csr (
1103                            .clk_i      (clk_i),
1104                            .rst_ni     (rst_ni),
1105                            .wr_data_i  (csr_wdata_int[31-:PMPAddrWidth]),
1106                            .wr_en_i    (pmp_addr_we[i]),
1107                            .rd_data_o  (pmp_addr[i]),
1108                            .rd_error_o (pmp_addr_err[i])
1109                          );
1110                    
1111                          assign csr_pmp_cfg_o[i]  = pmp_cfg[i];
1112                          assign csr_pmp_addr_o[i] = {pmp_addr_rdata[i], 2'b00};
1113                        end
1114                    
1115                        assign pmp_mseccfg_we = csr_we_int & (csr_addr == CSR_MSECCFG);
1116                    
1117                        // MSECCFG.MML/MSECCFG.MMWP cannot be unset once set
1118                        assign pmp_mseccfg_d.mml  = pmp_mseccfg_q.mml  ? 1'b1 : csr_wdata_int[CSR_MSECCFG_MML_BIT];
1119                        assign pmp_mseccfg_d.mmwp = pmp_mseccfg_q.mmwp ? 1'b1 : csr_wdata_int[CSR_MSECCFG_MMWP_BIT];
1120                    
1121                        // pmp_cfg_locked factors in MSECCFG.RLB so any_pmp_entry_locked will only be set if MSECCFG.RLB
1122                        // is unset
1123                        assign any_pmp_entry_locked = |pmp_cfg_locked;
1124                    
1125                        // When any PMP entry is locked (A PMP entry has the L bit set and MSECCFG.RLB is unset),
1126                        // MSECCFG.RLB cannot be set again
1127                        assign pmp_mseccfg_d.rlb = any_pmp_entry_locked ? 1'b0 : csr_wdata_int[CSR_MSECCFG_RLB_BIT];
1128                    
1129                        ibex_csr #(
1130                          .Width      ($bits(pmp_mseccfg_t)),
1131                          .ShadowCopy (ShadowCSR),
1132                          .ResetValue ('0)
1133                        ) u_pmp_mseccfg (
1134                          .clk_i      (clk_i),
1135                          .rst_ni     (rst_ni),
1136                          .wr_data_i  (pmp_mseccfg_d),
1137                          .wr_en_i    (pmp_mseccfg_we),
1138                          .rd_data_o  (pmp_mseccfg_q),
1139                          .rd_error_o (pmp_mseccfg_err)
1140                        );
1141                    
1142                        assign pmp_csr_err = (|pmp_cfg_err) | (|pmp_addr_err) | pmp_mseccfg_err;
1143                        assign pmp_mseccfg = pmp_mseccfg_q;
1144                    
1145                      end else begin : g_no_pmp_tieoffs
1146                        // Generate tieoffs when PMP is not configured
1147                        for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_rdata
1148                          assign pmp_addr_rdata[i] = '0;
1149                          assign pmp_cfg_rdata[i]  = '0;
1150                        end
1151                        for (genvar i = 0; i < PMPNumRegions; i++) begin : g_outputs
1152                          assign csr_pmp_cfg_o[i]  = pmp_cfg_t'(1'b0);
1153                          assign csr_pmp_addr_o[i] = '0;
1154                        end
1155                        assign pmp_csr_err = 1'b0;
1156                        assign pmp_mseccfg = '0;
1157                      end
1158                    
1159                      assign csr_pmp_mseccfg_o = pmp_mseccfg;
1160                    
1161                      //////////////////////////
1162                      //  Performance monitor //
1163                      //////////////////////////
1164                    
1165                      // update enable signals
1166                      always_comb begin : mcountinhibit_update
1167       1/1              if (mcountinhibit_we == 1'b1) begin
1168                          // bit 1 must always be 0
1169       0/1     ==>        mcountinhibit_d = {csr_wdata_int[MHPMCounterNum+2:2], 1'b0, csr_wdata_int[0]};
1170                        end else begin
1171       1/1                mcountinhibit_d = mcountinhibit_q;
1172                        end
1173                      end
1174                    
1175                      // event selection (hardwired) & control
1176                      always_comb begin : gen_mhpmcounter_incr
1177                    
1178                        // Assign inactive counters (first to prevent latch inference)
1179       1/1              for (int unsigned i=0; i<32; i++) begin : gen_mhpmcounter_incr_inactive
1180       1/1                mhpmcounter_incr[i] = 1'b0;
1181                        end
1182                    
1183                        // When adding or altering performance counter meanings and default
1184                        // mappings please update dv/verilator/pcount/cpp/ibex_pcounts.cc
1185                        // appropriately.
1186                        //
1187                        // active counters
1188       1/1              mhpmcounter_incr[0]  = 1'b1;                   // mcycle
1189       1/1              mhpmcounter_incr[1]  = 1'b0;                   // reserved
1190       1/1              mhpmcounter_incr[2]  = instr_ret_i;            // minstret
1191       1/1              mhpmcounter_incr[3]  = dside_wait_i;           // cycles waiting for data memory
1192       1/1              mhpmcounter_incr[4]  = iside_wait_i;           // cycles waiting for instr fetches
1193       1/1              mhpmcounter_incr[5]  = mem_load_i;             // num of loads
1194       1/1              mhpmcounter_incr[6]  = mem_store_i;            // num of stores
1195       1/1              mhpmcounter_incr[7]  = jump_i;                 // num of jumps (unconditional)
1196       1/1              mhpmcounter_incr[8]  = branch_i;               // num of branches (conditional)
1197       1/1              mhpmcounter_incr[9]  = branch_taken_i;         // num of taken branches (conditional)
1198       1/1              mhpmcounter_incr[10] = instr_ret_compressed_i; // num of compressed instr
1199       1/1              mhpmcounter_incr[11] = mul_wait_i;             // cycles waiting for multiply
1200       1/1              mhpmcounter_incr[12] = div_wait_i;             // cycles waiting for divide
1201                      end
1202                    
1203                      // event selector (hardwired, 0 means no event)
1204                      always_comb begin : gen_mhpmevent
1205                    
1206                        // activate all
1207       1/1              for (int i=0; i<32; i++) begin : gen_mhpmevent_active
1208       1/1                mhpmevent[i]    =   '0;
1209       1/1                mhpmevent[i][i] = 1'b1;
1210                        end
1211                    
1212                        // deactivate
1213       1/1              mhpmevent[1] = '0; // not existing, reserved
1214       1/1              for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mhpmevent_inactive
1215       1/1                mhpmevent[i] = '0;
1216                        end
1217                      end
1218                    
1219                      // mcycle
1220                      ibex_counter #(
1221                        .CounterWidth(64)
1222                      ) mcycle_counter_i (
1223                        .clk_i(clk_i),
1224                        .rst_ni(rst_ni),
1225                        .counter_inc_i(mhpmcounter_incr[0] & ~mcountinhibit[0]),
1226                        .counterh_we_i(mhpmcounterh_we[0]),
1227                        .counter_we_i(mhpmcounter_we[0]),
1228                        .counter_val_i(csr_wdata_int),
1229                        .counter_val_o(mhpmcounter[0])
1230                      );
1231                    
1232                      // minstret
1233                      ibex_counter #(
1234                        .CounterWidth(64)
1235                      ) minstret_counter_i (
1236                        .clk_i(clk_i),
1237                        .rst_ni(rst_ni),
1238                        .counter_inc_i(mhpmcounter_incr[2] & ~mcountinhibit[2]),
1239                        .counterh_we_i(mhpmcounterh_we[2]),
1240                        .counter_we_i(mhpmcounter_we[2]),
1241                        .counter_val_i(csr_wdata_int),
1242                        .counter_val_o(mhpmcounter[2])
1243                      );
1244                    
1245                      // reserved:
1246                      assign mhpmcounter[1]            = '0;
1247                      assign unused_mhpmcounter_we_1   = mhpmcounter_we[1];
1248                      assign unused_mhpmcounterh_we_1  = mhpmcounterh_we[1];
1249                      assign unused_mhpmcounter_incr_1 = mhpmcounter_incr[1];
1250                    
1251                      for (genvar cnt=0; cnt < 29; cnt++) begin : gen_cntrs
1252                        if (cnt < MHPMCounterNum) begin : gen_imp
1253                          ibex_counter #(
1254                            .CounterWidth(MHPMCounterWidth)
1255                          ) mcounters_variable_i (
1256                            .clk_i(clk_i),
1257                            .rst_ni(rst_ni),
1258                            .counter_inc_i(mhpmcounter_incr[cnt+3] & ~mcountinhibit[cnt+3]),
1259                            .counterh_we_i(mhpmcounterh_we[cnt+3]),
1260                            .counter_we_i(mhpmcounter_we[cnt+3]),
1261                            .counter_val_i(csr_wdata_int),
1262                            .counter_val_o(mhpmcounter[cnt+3])
1263                          );
1264                        end else begin : gen_unimp
1265                          assign mhpmcounter[cnt+3] = '0;
1266                        end
1267                      end
1268                    
1269                      if(MHPMCounterNum < 29) begin : g_mcountinhibit_reduced
1270                        logic [29-MHPMCounterNum-1:0] unused_mhphcounter_we;
1271                        logic [29-MHPMCounterNum-1:0] unused_mhphcounterh_we;
1272                        logic [29-MHPMCounterNum-1:0] unused_mhphcounter_incr;
1273                    
1274                        assign mcountinhibit = {{29-MHPMCounterNum{1'b1}}, mcountinhibit_q};
1275                        // Lint tieoffs for unused bits
1276                        assign unused_mhphcounter_we   = mhpmcounter_we[31:MHPMCounterNum+3];
1277                        assign unused_mhphcounterh_we  = mhpmcounterh_we[31:MHPMCounterNum+3];
1278                        assign unused_mhphcounter_incr = mhpmcounter_incr[31:MHPMCounterNum+3];
1279                      end else begin : g_mcountinhibit_full
1280                        assign mcountinhibit = mcountinhibit_q;
1281                      end
1282                    
1283                      always_ff @(posedge clk_i or negedge rst_ni) begin
1284       1/1              if (!rst_ni) begin
1285       1/1                mcountinhibit_q <= '0;
1286                        end else begin
1287       0/1     ==>        mcountinhibit_q <= mcountinhibit_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_cs_registers

               Total   Covered  Percent
Conditions         13        3    23.08
Logical            13        3    23.08
Non-Logical         0        0
Event               0        0

 LINE       512
 EXPRESSION (csr_mtvec_init_i ? ({boot_addr_i[31:8], 6'b0, 2'b1}) : ({csr_wdata_int[31:8], 6'b0, 2'b1}))
             --------1-------

-1- Status
 0  Covered
 1  Covered

 LINE       546
 EXPRESSION ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U))
             --------------1--------------    --------------2--------------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       572
 EXPRESSION ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U))
             -------------1------------    -------------2------------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       282
 EXPRESSION ((csr_addr[11:10] == 2'b11) && csr_wr)
             -------------1------------    ---2--

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       726
 EXPRESSION (mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q)
             -------1------

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_cs_registers
                Total Covered Percent 
Totals          208   0       0.00    
Total Bits      3134  0       0.00    
Total Bits 0->1 1567  0       0.00    
Total Bits 1->0 1567  0       0.00    

                            
Ports          69  0 0.00   
Port Bits      986 0 0.00   
Port Bits 0->1 493 0 0.00   
Port Bits 1->0 493 0 0.00   

                               
Signals          139  0 0.00   
Signal Bits      2148 0 0.00   
Signal Bits 0->1 1074 0 0.00   
Signal Bits 1->0 1074 0 0.00   

Port Details
                         Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                    No     No          No          INPUT     
rst_ni                   No     No          No          INPUT     
hart_id_i[31:0]          No     No          No          INPUT     
priv_mode_id_o[1:0]      No     No          No          OUTPUT    
priv_mode_if_o[1:0]      No     No          No          OUTPUT    
priv_mode_lsu_o[1:0]     No     No          No          OUTPUT    
csr_mstatus_tw_o         No     No          No          OUTPUT    
csr_mtvec_o[31:0]        No     No          No          OUTPUT    
csr_mtvec_init_i         No     No          No          INPUT     
boot_addr_i[31:0]        No     No          No          INPUT     
csr_access_i             No     No          No          INPUT     
csr_addr_i[11:0]         No     No          No          INPUT     
csr_wdata_i[31:0]        No     No          No          INPUT     
csr_op_i[1:0]            No     No          No          INPUT     
csr_op_en_i              No     No          No          INPUT     
csr_rdata_o[31:0]        No     No          No          OUTPUT    
irq_software_i           No     No          No          INPUT     
irq_timer_i              No     No          No          INPUT     
irq_external_i           No     No          No          INPUT     
irq_fast_i[14:0]         No     No          No          INPUT     
nmi_mode_i               No     No          No          INPUT     
irq_pending_o            No     No          No          OUTPUT    
irqs_o.irq_fast[14:0]    No     No          No          OUTPUT    
irqs_o.irq_external      No     No          No          OUTPUT    
irqs_o.irq_timer         No     No          No          OUTPUT    
irqs_o.irq_software      No     No          No          OUTPUT    
csr_mstatus_mie_o        No     No          No          OUTPUT    
csr_mepc_o[31:0]         No     No          No          OUTPUT    
csr_pmp_mseccfg_o.mml    No     No          No          OUTPUT    
csr_pmp_mseccfg_o.mmwp   No     No          No          OUTPUT    
csr_pmp_mseccfg_o.rlb    No     No          No          OUTPUT    
debug_mode_i             No     No          No          INPUT     
debug_cause_i[2:0]       No     No          No          INPUT     
debug_csr_save_i         No     No          No          INPUT     
csr_depc_o[31:0]         No     No          No          OUTPUT    
debug_single_step_o      No     No          No          OUTPUT    
debug_ebreakm_o          No     No          No          OUTPUT    
debug_ebreaku_o          No     No          No          OUTPUT    
trigger_match_o          No     No          No          OUTPUT    
pc_if_i[31:0]            No     No          No          INPUT     
pc_id_i[31:0]            No     No          No          INPUT     
pc_wb_i[31:0]            No     No          No          INPUT     
data_ind_timing_o        No     No          No          OUTPUT    
dummy_instr_en_o         No     No          No          OUTPUT    
dummy_instr_mask_o[2:0]  No     No          No          OUTPUT    
dummy_instr_seed_en_o    No     No          No          OUTPUT    
dummy_instr_seed_o[31:0] No     No          No          OUTPUT    
icache_enable_o          No     No          No          OUTPUT    
csr_shadow_err_o         No     No          No          OUTPUT    
csr_save_if_i            No     No          No          INPUT     
csr_save_id_i            No     No          No          INPUT     
csr_save_wb_i            No     No          No          INPUT     
csr_restore_mret_i       No     No          No          INPUT     
csr_restore_dret_i       No     No          No          INPUT     
csr_save_cause_i         No     No          No          INPUT     
csr_mcause_i[5:0]        No     No          No          INPUT     
csr_mtval_i[31:0]        No     No          No          INPUT     
illegal_csr_insn_o       No     No          No          OUTPUT    
instr_ret_i              No     No          No          INPUT     
instr_ret_compressed_i   No     No          No          INPUT     
iside_wait_i             No     No          No          INPUT     
jump_i                   No     No          No          INPUT     
branch_i                 No     No          No          INPUT     
branch_taken_i           No     No          No          INPUT     
mem_load_i               No     No          No          INPUT     
mem_store_i              No     No          No          INPUT     
dside_wait_i             No     No          No          INPUT     
mul_wait_i               No     No          No          INPUT     
div_wait_i               No     No          No          INPUT     

Signal Details
                                                      Toggle Toggle 1->0 Toggle 0->1 
exception_pc[31:0]                                    No     No          No          
priv_lvl_q[1:0]                                       No     No          No          
priv_lvl_d[1:0]                                       No     No          No          
mstatus_q.tw                                          No     No          No          
mstatus_q.mprv                                        No     No          No          
mstatus_q.mpp[1:0]                                    No     No          No          
mstatus_q.mpie                                        No     No          No          
mstatus_q.mie                                         No     No          No          
mstatus_d.tw                                          No     No          No          
mstatus_d.mprv                                        No     No          No          
mstatus_d.mpp[1:0]                                    No     No          No          
mstatus_d.mpie                                        No     No          No          
mstatus_d.mie                                         No     No          No          
mstatus_err                                           No     No          No          
mstatus_en                                            No     No          No          
mie_q.irq_fast[14:0]                                  No     No          No          
mie_q.irq_external                                    No     No          No          
mie_q.irq_timer                                       No     No          No          
mie_q.irq_software                                    No     No          No          
mie_d.irq_fast[14:0]                                  No     No          No          
mie_d.irq_external                                    No     No          No          
mie_d.irq_timer                                       No     No          No          
mie_d.irq_software                                    No     No          No          
mie_en                                                No     No          No          
mscratch_q[31:0]                                      No     No          No          
mscratch_en                                           No     No          No          
mepc_q[31:0]                                          No     No          No          
mepc_d[31:0]                                          No     No          No          
mepc_en                                               No     No          No          
mcause_q[5:0]                                         No     No          No          
mcause_d[5:0]                                         No     No          No          
mcause_en                                             No     No          No          
mtval_q[31:0]                                         No     No          No          
mtval_d[31:0]                                         No     No          No          
mtval_en                                              No     No          No          
mtvec_q[31:0]                                         No     No          No          
mtvec_d[31:0]                                         No     No          No          
mtvec_err                                             No     No          No          
mtvec_en                                              No     No          No          
mip.irq_fast[14:0]                                    No     No          No          
mip.irq_external                                      No     No          No          
mip.irq_timer                                         No     No          No          
mip.irq_software                                      No     No          No          
dcsr_q.prv[1:0]                                       No     No          No          
dcsr_q.step                                           No     No          No          
dcsr_q.nmip                                           No     No          No          
dcsr_q.mprven                                         No     No          No          
dcsr_q.zero0                                          No     No          No          
dcsr_q.cause[2:0]                                     No     No          No          
dcsr_q.stoptime                                       No     No          No          
dcsr_q.stopcount                                      No     No          No          
dcsr_q.stepie                                         No     No          No          
dcsr_q.ebreaku                                        No     No          No          
dcsr_q.ebreaks                                        No     No          No          
dcsr_q.zero1                                          No     No          No          
dcsr_q.ebreakm                                        No     No          No          
dcsr_q.zero2[11:0]                                    No     No          No          
dcsr_q.xdebugver[3:0]                                 No     No          No          
dcsr_d.prv[1:0]                                       No     No          No          
dcsr_d.step                                           No     No          No          
dcsr_d.nmip                                           No     No          No          
dcsr_d.mprven                                         No     No          No          
dcsr_d.zero0                                          No     No          No          
dcsr_d.cause[2:0]                                     No     No          No          
dcsr_d.stoptime                                       No     No          No          
dcsr_d.stopcount                                      No     No          No          
dcsr_d.stepie                                         No     No          No          
dcsr_d.ebreaku                                        No     No          No          
dcsr_d.ebreaks                                        No     No          No          
dcsr_d.zero1                                          No     No          No          
dcsr_d.ebreakm                                        No     No          No          
dcsr_d.zero2[11:0]                                    No     No          No          
dcsr_d.xdebugver[3:0]                                 No     No          No          
dcsr_en                                               No     No          No          
depc_q[31:0]                                          No     No          No          
depc_d[31:0]                                          No     No          No          
depc_en                                               No     No          No          
dscratch0_q[31:0]                                     No     No          No          
dscratch1_q[31:0]                                     No     No          No          
dscratch0_en                                          No     No          No          
dscratch1_en                                          No     No          No          
mstack_q.mpp[1:0]                                     No     No          No          
mstack_q.mpie                                         No     No          No          
mstack_d.mpp[1:0]                                     No     No          No          
mstack_d.mpie                                         No     No          No          
mstack_en                                             No     No          No          
mstack_epc_q[31:0]                                    No     No          No          
mstack_epc_d[31:0]                                    No     No          No          
mstack_cause_q[5:0]                                   No     No          No          
mstack_cause_d[5:0]                                   No     No          No          
pmp_csr_err                                           No     No          No          
pmp_mseccfg.mml                                       No     No          No          
pmp_mseccfg.mmwp                                      No     No          No          
pmp_mseccfg.rlb                                       No     No          No          
mcountinhibit[31:0]                                   No     No          No          
mcountinhibit_d[2:0]                                  No     No          No          
mcountinhibit_q[2:0]                                  No     No          No          
mcountinhibit_we                                      No     No          No          
mhpmcounter_we[31:0]                                  No     No          No          
mhpmcounterh_we[31:0]                                 No     No          No          
mhpmcounter_incr[31:0]                                No     No          No          
mhpmcounter_idx[4:0]                                  No     No          No          
unused_mhpmcounter_we_1                               No     No          No          
unused_mhpmcounterh_we_1                              No     No          No          
unused_mhpmcounter_incr_1                             No     No          No          
tselect_rdata[31:0]                                   No     No          No          
tmatch_control_rdata[31:0]                            No     No          No          
tmatch_value_rdata[31:0]                              No     No          No          
cpuctrl_q.icache_enable                               No     No          No          
cpuctrl_q.data_ind_timing                             No     No          No          
cpuctrl_q.dummy_instr_en                              No     No          No          
cpuctrl_q.dummy_instr_mask[2:0]                       No     No          No          
cpuctrl_d.icache_enable                               No     No          No          
cpuctrl_d.data_ind_timing                             No     No          No          
cpuctrl_d.dummy_instr_en                              No     No          No          
cpuctrl_d.dummy_instr_mask[2:0]                       No     No          No          
cpuctrl_wdata.icache_enable                           No     No          No          
cpuctrl_wdata.data_ind_timing                         No     No          No          
cpuctrl_wdata.dummy_instr_en                          No     No          No          
cpuctrl_wdata.dummy_instr_mask[2:0]                   No     No          No          
cpuctrl_we                                            No     No          No          
cpuctrl_err                                           No     No          No          
csr_wdata_int[31:0]                                   No     No          No          
csr_rdata_int[31:0]                                   No     No          No          
csr_we_int                                            No     No          No          
csr_wr                                                No     No          No          
illegal_csr                                           No     No          No          
illegal_csr_priv                                      No     No          No          
illegal_csr_write                                     No     No          No          
unused_boot_addr[7:0]                                 No     No          No          
unused_csr_addr[2:0]                                  No     No          No          
csr_addr[11:0]                                        No     No          No          
g_mcountinhibit_reduced.unused_mhphcounter_we[28:0]   No     No          No          
g_mcountinhibit_reduced.unused_mhphcounterh_we[28:0]  No     No          No          
g_mcountinhibit_reduced.unused_mhphcounter_incr[28:0] No     No          No          
gen_no_dit.unused_dit                                 No     No          No          
gen_no_dummy.unused_dummy_en                          No     No          No          
gen_no_dummy.unused_dummy_mask[2:0]                   No     No          No          
gen_no_icache.unused_icen                             No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_cs_registers
         Line No. Total Covered Percent 
Branches          97    11      11.34   
TERNARY  726      2     1       50.00   
CASE     296      52    1       1.92    
TERNARY  512      2     2       100.00  
IF       533      19    1       5.26    
CASE     637      11    1       9.09    
IF       714      2     1       50.00   
CASE     730      5     2       40.00   
IF       1167     2     1       50.00   
IF       1284     2     1       50.00   


726          assign priv_mode_lsu_o = mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q;
                                                     -1-  
                                                     ==>  
                                                     ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


296            unique case (csr_addr_i)
                      -1-  
297              // mhartid: unique hardware thread id
298              CSR_MHARTID: csr_rdata_int = hart_id_i;
                 ==>
299        
300              // mstatus: always M-mode, contains IE bit
301              CSR_MSTATUS: begin
302                csr_rdata_int                                                   = '0;
                   ==>
303                csr_rdata_int[CSR_MSTATUS_MIE_BIT]                              = mstatus_q.mie;
304                csr_rdata_int[CSR_MSTATUS_MPIE_BIT]                             = mstatus_q.mpie;
305                csr_rdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW] = mstatus_q.mpp;
306                csr_rdata_int[CSR_MSTATUS_MPRV_BIT]                             = mstatus_q.mprv;
307                csr_rdata_int[CSR_MSTATUS_TW_BIT]                               = mstatus_q.tw;
308              end
309        
310              // misa
311              CSR_MISA: csr_rdata_int = MISA_VALUE;
                 ==>
312        
313              // interrupt enable
314              CSR_MIE: begin
315                csr_rdata_int                                     = '0;
                   ==>
316                csr_rdata_int[CSR_MSIX_BIT]                       = mie_q.irq_software;
317                csr_rdata_int[CSR_MTIX_BIT]                       = mie_q.irq_timer;
318                csr_rdata_int[CSR_MEIX_BIT]                       = mie_q.irq_external;
319                csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mie_q.irq_fast;
320              end
321        
322              // mcounteren: machine counter enable
323              CSR_MCOUNTEREN: begin
324                csr_rdata_int = '0;
                   ==>
325                illegal_csr   = ~DbgTriggerEn;
326              end
327        
328              CSR_MSCRATCH: csr_rdata_int = mscratch_q;
                 ==>
329        
330              // mtvec: trap-vector base address
331              CSR_MTVEC: csr_rdata_int = mtvec_q;
                 ==>
332        
333              // mepc: exception program counter
334              CSR_MEPC: csr_rdata_int = mepc_q;
                 ==>
335        
336              // mcause: exception cause
337              CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};
                 ==>
338        
339              // mtval: trap value
340              CSR_MTVAL: csr_rdata_int = mtval_q;
                 ==>
341        
342              // mip: interrupt pending
343              CSR_MIP: begin
344                csr_rdata_int                                     = '0;
                   ==>
345                csr_rdata_int[CSR_MSIX_BIT]                       = mip.irq_software;
346                csr_rdata_int[CSR_MTIX_BIT]                       = mip.irq_timer;
347                csr_rdata_int[CSR_MEIX_BIT]                       = mip.irq_external;
348                csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mip.irq_fast;
349              end
350        
351              CSR_MSECCFG: begin
352                if (PMPEnable) begin
                   -2-  
353                  csr_rdata_int                       = '0;
                     ==>
354                  csr_rdata_int[CSR_MSECCFG_MML_BIT]  = pmp_mseccfg.mml;
355                  csr_rdata_int[CSR_MSECCFG_MMWP_BIT] = pmp_mseccfg.mmwp;
356                  csr_rdata_int[CSR_MSECCFG_RLB_BIT]  = pmp_mseccfg.rlb;
357                end else begin
358                  illegal_csr = 1'b1;
                     ==>
359                end
360              end
361        
362              CSR_MSECCFGH: begin
363                if (PMPEnable) begin
                   -3-  
364                  csr_rdata_int = '0;
                     ==>
365                end else begin
366                  illegal_csr = 1'b1;
                     ==>
367                end
368              end
369        
370              // PMP registers
371              CSR_PMPCFG0:   csr_rdata_int = {pmp_cfg_rdata[3],  pmp_cfg_rdata[2],
                 ==>
372                                              pmp_cfg_rdata[1],  pmp_cfg_rdata[0]};
373              CSR_PMPCFG1:   csr_rdata_int = {pmp_cfg_rdata[7],  pmp_cfg_rdata[6],
                 ==>
374                                              pmp_cfg_rdata[5],  pmp_cfg_rdata[4]};
375              CSR_PMPCFG2:   csr_rdata_int = {pmp_cfg_rdata[11], pmp_cfg_rdata[10],
                 ==>
376                                              pmp_cfg_rdata[9],  pmp_cfg_rdata[8]};
377              CSR_PMPCFG3:   csr_rdata_int = {pmp_cfg_rdata[15], pmp_cfg_rdata[14],
                 ==>
378                                              pmp_cfg_rdata[13], pmp_cfg_rdata[12]};
379              CSR_PMPADDR0:  csr_rdata_int = pmp_addr_rdata[0];
                 ==>
380              CSR_PMPADDR1:  csr_rdata_int = pmp_addr_rdata[1];
                 ==>
381              CSR_PMPADDR2:  csr_rdata_int = pmp_addr_rdata[2];
                 ==>
382              CSR_PMPADDR3:  csr_rdata_int = pmp_addr_rdata[3];
                 ==>
383              CSR_PMPADDR4:  csr_rdata_int = pmp_addr_rdata[4];
                 ==>
384              CSR_PMPADDR5:  csr_rdata_int = pmp_addr_rdata[5];
                 ==>
385              CSR_PMPADDR6:  csr_rdata_int = pmp_addr_rdata[6];
                 ==>
386              CSR_PMPADDR7:  csr_rdata_int = pmp_addr_rdata[7];
                 ==>
387              CSR_PMPADDR8:  csr_rdata_int = pmp_addr_rdata[8];
                 ==>
388              CSR_PMPADDR9:  csr_rdata_int = pmp_addr_rdata[9];
                 ==>
389              CSR_PMPADDR10: csr_rdata_int = pmp_addr_rdata[10];
                 ==>
390              CSR_PMPADDR11: csr_rdata_int = pmp_addr_rdata[11];
                 ==>
391              CSR_PMPADDR12: csr_rdata_int = pmp_addr_rdata[12];
                 ==>
392              CSR_PMPADDR13: csr_rdata_int = pmp_addr_rdata[13];
                 ==>
393              CSR_PMPADDR14: csr_rdata_int = pmp_addr_rdata[14];
                 ==>
394              CSR_PMPADDR15: csr_rdata_int = pmp_addr_rdata[15];
                 ==>
395        
396              CSR_DCSR: begin
397                csr_rdata_int = dcsr_q;
                   ==>
398                illegal_csr = ~debug_mode_i;
399              end
400              CSR_DPC: begin
401                csr_rdata_int = depc_q;
                   ==>
402                illegal_csr = ~debug_mode_i;
403              end
404              CSR_DSCRATCH0: begin
405                csr_rdata_int = dscratch0_q;
                   ==>
406                illegal_csr = ~debug_mode_i;
407              end
408              CSR_DSCRATCH1: begin
409                csr_rdata_int = dscratch1_q;
                   ==>
410                illegal_csr = ~debug_mode_i;
411              end
412        
413              // machine counter/timers
414              CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit;
                 ==>
415              CSR_MHPMEVENT3,
416              CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,
417              CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,
418              CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,
419              CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,
420              CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,
421              CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,
422              CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31: begin
423                csr_rdata_int = mhpmevent[mhpmcounter_idx];
                   ==>
424              end
425        
426              CSR_MCYCLE,
427              CSR_MINSTRET,
428              CSR_MHPMCOUNTER3,
429              CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
430              CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
431              CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
432              CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
433              CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
434              CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
435              CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
436                csr_rdata_int = mhpmcounter[mhpmcounter_idx][31:0];
                   ==>
437              end
438        
439              CSR_MCYCLEH,
440              CSR_MINSTRETH,
441              CSR_MHPMCOUNTER3H,
442              CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
443              CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
444              CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
445              CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
446              CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
447              CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
448              CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
449                csr_rdata_int = mhpmcounter[mhpmcounter_idx][63:32];
                   ==>
450              end
451        
452              // Debug triggers
453              CSR_TSELECT: begin
454                csr_rdata_int = tselect_rdata;
                   ==>
455                illegal_csr   = ~DbgTriggerEn;
456              end
457              CSR_TDATA1: begin
458                csr_rdata_int = tmatch_control_rdata;
                   ==>
459                illegal_csr   = ~DbgTriggerEn;
460              end
461              CSR_TDATA2: begin
462                csr_rdata_int = tmatch_value_rdata;
                   ==>
463                illegal_csr   = ~DbgTriggerEn;
464              end
465              CSR_TDATA3: begin
466                csr_rdata_int = '0;
                   ==>
467                illegal_csr   = ~DbgTriggerEn;
468              end
469              CSR_MCONTEXT: begin
470                csr_rdata_int = '0;
                   ==>
471                illegal_csr   = ~DbgTriggerEn;
472              end
473              CSR_SCONTEXT: begin
474                csr_rdata_int = '0;
                   ==>
475                illegal_csr   = ~DbgTriggerEn;
476              end
477        
478              // Custom CSR for controlling CPU features
479              CSR_CPUCTRL: begin
480                csr_rdata_int = {{32-$bits(cpu_ctrl_t){1'b0}},cpuctrl_q};
                   ==>
481              end
482        
483              // Custom CSR for LFSR re-seeding (cannot be read)
484              CSR_SECURESEED: begin
485                csr_rdata_int = '0;
                   ==>
486              end
487        
488              default: begin
489                illegal_csr = 1'b1;
                   ==>

Branches:

-1-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -2- -3- Status      
CSR_MHARTID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
CSR_MISA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   -   Not Covered 
CSR_MIE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Not Covered 
CSR_MCOUNTEREN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -   -   Not Covered 
CSR_MSCRATCH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_MTVEC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -   -   Not Covered 
CSR_MEPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   -   Not Covered 
CSR_MCAUSE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -   -   Not Covered 
CSR_MTVAL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -   -   Not Covered 
CSR_MIP                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Not Covered 
CSR_MSECCFG                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1   -   Not Covered 
CSR_MSECCFG                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             0   -   Not Covered 
CSR_MSECCFGH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   1   Not Covered 
CSR_MSECCFGH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   0   Not Covered 
CSR_PMPCFG0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
CSR_PMPCFG1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
CSR_PMPCFG2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
CSR_PMPCFG3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
CSR_PMPADDR0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR9                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_PMPADDR10                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
CSR_PMPADDR11                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
CSR_PMPADDR12                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
CSR_PMPADDR13                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
CSR_PMPADDR14                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
CSR_PMPADDR15                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   -   Not Covered 
CSR_DPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Not Covered 
CSR_DSCRATCH0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
CSR_DSCRATCH1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
CSR_MCOUNTINHIBIT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -   -   Not Covered 
CASEITEM-39: CSR_MHPMEVENT3 CSR_MHPMEVENT4 CSR_MHPMEVENT5 CSR_MHPMEVENT6 CSR_MHPMEVENT7 CSR_MHPMEVENT8 CSR_MHPMEVENT9 CSR_MHPMEVENT10 CSR_MHPMEVENT11 CSR_MHPMEVENT12 CSR_MHPMEVENT13 CSR_MHPMEVENT14 CSR_MHPMEVENT15 CSR_MHPMEVENT16 CSR_MHPMEVENT17 CSR_MHPMEVENT18 CSR_MHPMEVENT19 CSR_MHPMEVENT20 CSR_MHPMEVENT21 CSR_MHPMEVENT22 CSR_MHPMEVENT23 CSR_MHPMEVENT24 CSR_MHPMEVENT25 CSR_MHPMEVENT26 CSR_MHPMEVENT27 CSR_MHPMEVENT28 CSR_MHPMEVENT29 CSR_MHPMEVENT30 CSR_MHPMEVENT31                                                                                                                   -   -   Not Covered 
CASEITEM-40: CSR_MCYCLE CSR_MINSTRET CSR_MHPMCOUNTER3 CSR_MHPMCOUNTER4 CSR_MHPMCOUNTER5 CSR_MHPMCOUNTER6 CSR_MHPMCOUNTER7 CSR_MHPMCOUNTER8 CSR_MHPMCOUNTER9 CSR_MHPMCOUNTER10 CSR_MHPMCOUNTER11 CSR_MHPMCOUNTER12 CSR_MHPMCOUNTER13 CSR_MHPMCOUNTER14 CSR_MHPMCOUNTER15 CSR_MHPMCOUNTER16 CSR_MHPMCOUNTER17 CSR_MHPMCOUNTER18 CSR_MHPMCOUNTER19 CSR_MHPMCOUNTER20 CSR_MHPMCOUNTER21 CSR_MHPMCOUNTER22 CSR_MHPMCOUNTER23 CSR_MHPMCOUNTER24 CSR_MHPMCOUNTER25 CSR_MHPMCOUNTER26 CSR_MHPMCOUNTER27 CSR_MHPMCOUNTER28 CSR_MHPMCOUNTER29 CSR_MHPMCOUNTER30 CSR_MHPMCOUNTER31                                 -   -   Not Covered 
CASEITEM-41: CSR_MCYCLEH CSR_MINSTRETH CSR_MHPMCOUNTER3H CSR_MHPMCOUNTER4H CSR_MHPMCOUNTER5H CSR_MHPMCOUNTER6H CSR_MHPMCOUNTER7H CSR_MHPMCOUNTER8H CSR_MHPMCOUNTER9H CSR_MHPMCOUNTER10H CSR_MHPMCOUNTER11H CSR_MHPMCOUNTER12H CSR_MHPMCOUNTER13H CSR_MHPMCOUNTER14H CSR_MHPMCOUNTER15H CSR_MHPMCOUNTER16H CSR_MHPMCOUNTER17H CSR_MHPMCOUNTER18H CSR_MHPMCOUNTER19H CSR_MHPMCOUNTER20H CSR_MHPMCOUNTER21H CSR_MHPMCOUNTER22H CSR_MHPMCOUNTER23H CSR_MHPMCOUNTER24H CSR_MHPMCOUNTER25H CSR_MHPMCOUNTER26H CSR_MHPMCOUNTER27H CSR_MHPMCOUNTER28H CSR_MHPMCOUNTER29H CSR_MHPMCOUNTER30H CSR_MHPMCOUNTER31H  -   -   Not Covered 
CSR_TSELECT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
CSR_TDATA1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -   -   Not Covered 
CSR_TDATA2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -   -   Not Covered 
CSR_TDATA3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -   -   Not Covered 
CSR_MCONTEXT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_SCONTEXT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
CSR_CPUCTRL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
CSR_SECURESEED                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -   -   Not Covered 
default                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Covered     


512            mtvec_d      = csr_mtvec_init_i ? {boot_addr_i[31:8], 6'b0, 2'b01} :
                                               -1-  
                                               ==>  
                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


533            if (csr_we_int) begin
               -1-  
534              unique case (csr_addr_i)
                        -2-  
535                // mstatus: IE bit
536                CSR_MSTATUS: begin
537                  mstatus_en = 1'b1;
538                  mstatus_d    = '{
539                      mie:  csr_wdata_int[CSR_MSTATUS_MIE_BIT],
540                      mpie: csr_wdata_int[CSR_MSTATUS_MPIE_BIT],
541                      mpp:  priv_lvl_e'(csr_wdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW]),
542                      mprv: csr_wdata_int[CSR_MSTATUS_MPRV_BIT],
543                      tw:   csr_wdata_int[CSR_MSTATUS_TW_BIT]
544                  };
545                  // Convert illegal values to M-mode
546                  if ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U)) begin
                     -3-  
547                    mstatus_d.mpp = PRIV_LVL_M;
                       ==>
548                  end
                     MISSING_ELSE
                     ==>
549                end
550        
551                // interrupt enable
552                CSR_MIE: mie_en = 1'b1;
                   ==>
553        
554                CSR_MSCRATCH: mscratch_en = 1'b1;
                   ==>
555        
556                // mepc: exception program counter
557                CSR_MEPC: mepc_en = 1'b1;
                   ==>
558        
559                // mcause
560                CSR_MCAUSE: mcause_en = 1'b1;
                   ==>
561        
562                // mtval: trap value
563                CSR_MTVAL: mtval_en = 1'b1;
                   ==>
564        
565                // mtvec
566                CSR_MTVEC: mtvec_en = 1'b1;
                   ==>
567        
568                CSR_DCSR: begin
569                  dcsr_d = csr_wdata_int;
570                  dcsr_d.xdebugver = XDEBUGVER_STD;
571                  // Change to PRIV_LVL_M if software writes an unsupported value
572                  if ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U)) begin
                     -4-  
573                    dcsr_d.prv = PRIV_LVL_M;
                       ==>
574                  end
                     MISSING_ELSE
                     ==>
575        
576                  // Read-only for SW
577                  dcsr_d.cause = dcsr_q.cause;
578        
579                  // Interrupts always disabled during single stepping
580                  dcsr_d.stepie = 1'b0;
581        
582                  // currently not supported:
583                  dcsr_d.nmip = 1'b0;
584                  dcsr_d.mprven = 1'b0;
585                  dcsr_d.stopcount = 1'b0;
586                  dcsr_d.stoptime = 1'b0;
587        
588                  // forced to be zero
589                  dcsr_d.zero0 = 1'b0;
590                  dcsr_d.zero1 = 1'b0;
591                  dcsr_d.zero2 = 12'h0;
592                  dcsr_en      = 1'b1;
593                end
594        
595                // dpc: debug program counter
596                CSR_DPC: depc_en = 1'b1;
                   ==>
597        
598                CSR_DSCRATCH0: dscratch0_en = 1'b1;
                   ==>
599                CSR_DSCRATCH1: dscratch1_en = 1'b1;
                   ==>
600        
601                // machine counter/timers
602                CSR_MCOUNTINHIBIT: mcountinhibit_we = 1'b1;
                   ==>
603        
604                CSR_MCYCLE,
605                CSR_MINSTRET,
606                CSR_MHPMCOUNTER3,
607                CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
608                CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
609                CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
610                CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
611                CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
612                CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
613                CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
614                  mhpmcounter_we[mhpmcounter_idx] = 1'b1;
                     ==>
615                end
616        
617                CSR_MCYCLEH,
618                CSR_MINSTRETH,
619                CSR_MHPMCOUNTER3H,
620                CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
621                CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
622                CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
623                CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
624                CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
625                CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
626                CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
627                  mhpmcounterh_we[mhpmcounter_idx] = 1'b1;
                     ==>
628                end
629        
630                CSR_CPUCTRL: cpuctrl_we = 1'b1;
                   ==>
631        
632                default:;
                   ==>
633              endcase
634            end
               MISSING_ELSE
               ==>

Branches:

-1- -2-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -3- -4- Status      
1   CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1   -   Not Covered 
1   CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             0   -   Not Covered 
1   CSR_MIE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Not Covered 
1   CSR_MSCRATCH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Not Covered 
1   CSR_MEPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   -   Not Covered 
1   CSR_MCAUSE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -   -   Not Covered 
1   CSR_MTVAL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -   -   Not Covered 
1   CSR_MTVEC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -   -   Not Covered 
1   CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   1   Not Covered 
1   CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   0   Not Covered 
1   CSR_DPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Not Covered 
1   CSR_DSCRATCH0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
1   CSR_DSCRATCH1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Not Covered 
1   CSR_MCOUNTINHIBIT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -   -   Not Covered 
1   CASEITEM-13: CSR_MCYCLE CSR_MINSTRET CSR_MHPMCOUNTER3 CSR_MHPMCOUNTER4 CSR_MHPMCOUNTER5 CSR_MHPMCOUNTER6 CSR_MHPMCOUNTER7 CSR_MHPMCOUNTER8 CSR_MHPMCOUNTER9 CSR_MHPMCOUNTER10 CSR_MHPMCOUNTER11 CSR_MHPMCOUNTER12 CSR_MHPMCOUNTER13 CSR_MHPMCOUNTER14 CSR_MHPMCOUNTER15 CSR_MHPMCOUNTER16 CSR_MHPMCOUNTER17 CSR_MHPMCOUNTER18 CSR_MHPMCOUNTER19 CSR_MHPMCOUNTER20 CSR_MHPMCOUNTER21 CSR_MHPMCOUNTER22 CSR_MHPMCOUNTER23 CSR_MHPMCOUNTER24 CSR_MHPMCOUNTER25 CSR_MHPMCOUNTER26 CSR_MHPMCOUNTER27 CSR_MHPMCOUNTER28 CSR_MHPMCOUNTER29 CSR_MHPMCOUNTER30 CSR_MHPMCOUNTER31                                 -   -   Not Covered 
1   CASEITEM-14: CSR_MCYCLEH CSR_MINSTRETH CSR_MHPMCOUNTER3H CSR_MHPMCOUNTER4H CSR_MHPMCOUNTER5H CSR_MHPMCOUNTER6H CSR_MHPMCOUNTER7H CSR_MHPMCOUNTER8H CSR_MHPMCOUNTER9H CSR_MHPMCOUNTER10H CSR_MHPMCOUNTER11H CSR_MHPMCOUNTER12H CSR_MHPMCOUNTER13H CSR_MHPMCOUNTER14H CSR_MHPMCOUNTER15H CSR_MHPMCOUNTER16H CSR_MHPMCOUNTER17H CSR_MHPMCOUNTER18H CSR_MHPMCOUNTER19H CSR_MHPMCOUNTER20H CSR_MHPMCOUNTER21H CSR_MHPMCOUNTER22H CSR_MHPMCOUNTER23H CSR_MHPMCOUNTER24H CSR_MHPMCOUNTER25H CSR_MHPMCOUNTER26H CSR_MHPMCOUNTER27H CSR_MHPMCOUNTER28H CSR_MHPMCOUNTER29H CSR_MHPMCOUNTER30H CSR_MHPMCOUNTER31H  -   -   Not Covered 
1   CSR_CPUCTRL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -   -   Not Covered 
1   default                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Not Covered 
0   -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -   -   Covered     


637            unique case (1'b1)
                      -1-  
638        
639              csr_save_cause_i: begin
640                unique case (1'b1)
                          -2-  
641                  csr_save_if_i: begin
642                    exception_pc = pc_if_i;
                       ==>
643                  end
644                  csr_save_id_i: begin
645                    exception_pc = pc_id_i;
                       ==>
646                  end
647                  csr_save_wb_i: begin
648                    exception_pc = pc_wb_i;
                       ==>
649                  end
650                  default:;
                     ==>
651                endcase
652        
653                // Any exception, including debug mode, causes a switch to M-mode
654                priv_lvl_d = PRIV_LVL_M;
655        
656                if (debug_csr_save_i) begin
                   -3-  
657                  // all interrupts are masked
658                  // do not update cause, epc, tval, epc and status
659                  dcsr_d.prv   = priv_lvl_q;
                     ==>
660                  dcsr_d.cause = debug_cause_i;
661                  dcsr_en      = 1'b1;
662                  depc_d       = exception_pc;
663                  depc_en      = 1'b1;
664                end else if (!debug_mode_i) begin
                            -4-  
665                  // In debug mode, "exceptions do not update any registers. That
666                  // includes cause, epc, tval, dpc and mstatus." [Debug Spec v0.13.2, p.39]
667                  mtval_en       = 1'b1;
                     ==>
668                  mtval_d        = csr_mtval_i;
669                  mstatus_en     = 1'b1;
670                  mstatus_d.mie  = 1'b0; // disable interrupts
671                  // save current status
672                  mstatus_d.mpie = mstatus_q.mie;
673                  mstatus_d.mpp  = priv_lvl_q;
674                  mepc_en        = 1'b1;
675                  mepc_d         = exception_pc;
676                  mcause_en      = 1'b1;
677                  mcause_d       = {csr_mcause_i};
678                  // save previous status for recoverable NMI
679                  mstack_en      = 1'b1;
680                end
                   MISSING_ELSE
                   ==>
681              end // csr_save_cause_i
682        
683              csr_restore_dret_i: begin // DRET
684                priv_lvl_d = dcsr_q.prv;
                   ==>
685              end // csr_restore_dret_i
686        
687              csr_restore_mret_i: begin // MRET
688                priv_lvl_d     = mstatus_q.mpp;
689                mstatus_en     = 1'b1;
690                mstatus_d.mie  = mstatus_q.mpie; // re-enable interrupts
691        
692                if (nmi_mode_i) begin
                   -5-  
693                  // when returning from an NMI restore state from mstack CSR
694                  mstatus_d.mpie = mstack_q.mpie;
                     ==>
695                  mstatus_d.mpp  = mstack_q.mpp;
696                  mepc_en        = 1'b1;
697                  mepc_d         = mstack_epc_q;
698                  mcause_en      = 1'b1;
699                  mcause_d       = mstack_cause_q;
700                end else begin
701                  // otherwise just set mstatus.MPIE/MPP
702                  // See RISC-V Privileged Specification, version 1.11, Section 3.1.6.1
703                  mstatus_d.mpie = 1'b1;
                     ==>
704                  mstatus_d.mpp  = PRIV_LVL_U;
705                end
706              end // csr_restore_mret_i
707        
708              default:;
                 ==>

Branches:

-1-                 -2-            -3- -4- -5- Status      
csr_save_cause_i    csr_save_if_i  -   -   -   Not Covered 
csr_save_cause_i    csr_save_id_i  -   -   -   Not Covered 
csr_save_cause_i    csr_save_wb_i  -   -   -   Not Covered 
csr_save_cause_i    default        -   -   -   Not Covered 
csr_save_cause_i    -              1   -   -   Not Covered 
csr_save_cause_i    -              0   1   -   Not Covered 
csr_save_cause_i    -              0   0   -   Not Covered 
csr_restore_dret_i  -              -   -   -   Not Covered 
csr_restore_mret_i  -              -   -   1   Not Covered 
csr_restore_mret_i  -              -   -   0   Not Covered 
default             -              -   -   -   Covered     


714            if (!rst_ni) begin
               -1-  
715              priv_lvl_q     <= PRIV_LVL_M;
                 ==>
716            end else begin
717              priv_lvl_q     <= priv_lvl_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


730            unique case (csr_op_i)
                      -1-  
731              CSR_OP_WRITE: csr_wdata_int =  csr_wdata_i;
                 ==>
732              CSR_OP_SET:   csr_wdata_int =  csr_wdata_i | csr_rdata_o;
                 ==>
733              CSR_OP_CLEAR: csr_wdata_int = ~csr_wdata_i & csr_rdata_o;
                 ==>
734              CSR_OP_READ:  csr_wdata_int = csr_wdata_i;
                 ==>
735              default:      csr_wdata_int = csr_wdata_i;
                 ==>

Branches:

-1-           Status      
CSR_OP_WRITE  Not Covered 
CSR_OP_SET    Not Covered 
CSR_OP_CLEAR  Not Covered 
CSR_OP_READ   Covered     
default       Covered     


1167           if (mcountinhibit_we == 1'b1) begin
               -1-  
1168             // bit 1 must always be 0
1169             mcountinhibit_d = {csr_wdata_int[MHPMCounterNum+2:2], 1'b0, csr_wdata_int[0]};
                 ==>
1170           end else begin
1171             mcountinhibit_d = mcountinhibit_q;
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


1284           if (!rst_ni) begin
               -1-  
1285             mcountinhibit_q <= '0;
                 ==>
1286           end else begin
1287             mcountinhibit_q <= mcountinhibit_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_cs_registers
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                      Attempts Real Successes Failures Incomplete 
IbexCsrOpEnRequiresAccess 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 12.83  29.73  23.08   0.00  11.34   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 16.35  37.50  23.08   0.00  21.15   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME              
 12.83  29.73  23.08   0.00  11.34   0.00 ibex_cs_registers 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME        
 20.58  43.66  14.29   0.00  28.26  16.67 u_ibex_core 


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME               
 43.49  73.33 --       0.00  57.14 --     mcycle_counter_i   
 36.51  66.67 --       0.00  42.86 --     minstret_counter_i 
 20.83  50.00 --       0.00  33.33   0.00 u_cpuctrl_csr      
 20.83  50.00 --       0.00  33.33   0.00 u_dcsr_csr         
 20.83  50.00 --       0.00  33.33   0.00 u_depc_csr         
 20.83  50.00 --       0.00  33.33   0.00 u_dscratch0_csr    
 20.83  50.00 --       0.00  33.33   0.00 u_dscratch1_csr    
 20.83  50.00 --       0.00  33.33   0.00 u_mcause_csr       
 20.83  50.00 --       0.00  33.33   0.00 u_mepc_csr         
 20.83  50.00 --       0.00  33.33   0.00 u_mie_csr          
 20.83  50.00 --       0.00  33.33   0.00 u_mscratch_csr     
 20.83  50.00 --       0.00  33.33   0.00 u_mstack_cause_csr 
 20.83  50.00 --       0.00  33.33   0.00 u_mstack_csr       
 20.83  50.00 --       0.00  33.33   0.00 u_mstack_epc_csr   
 20.83  50.00 --       0.00  33.33   0.00 u_mstatus_csr      
 20.83  50.00 --       0.00  33.33   0.00 u_mtval_csr        
 20.83  50.00 --       0.00  33.33   0.00 u_mtvec_csr        



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_if_stage
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 13.39  28.57 --       0.00  25.00   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_if_stage.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                         
 13.39  28.57 --       0.00  25.00   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.if_stage_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_if_stage

             Line No.   Total   Covered  Percent
TOTAL                       28        8    28.57
ALWAYS            165        6        2    33.33
ALWAYS            181        8        2    25.00
ALWAYS            389        5        3    60.00
ALWAYS            406        9        1    11.11

164                       always_comb begin : exc_pc_mux
165        1/1              unique case (exc_pc_mux_i)
166        0/1     ==>        EXC_PC_EXC:     exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
167        1/1                EXC_PC_IRQ:     exc_pc = { csr_mtvec_i[31:8], 1'b0, irq_id[4:0], 2'b00 };
168        0/1     ==>        EXC_PC_DBD:     exc_pc = DmHaltAddr;
169        0/1     ==>        EXC_PC_DBG_EXC: exc_pc = DmExceptionAddr;
170        0/1     ==>        default:        exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
171                         endcase
172                       end
173                     
174                       // The Branch predictor can provide a new PC which is internal to if_stage. Only override the mux
175                       // select to choose this if the core isn't already trying to set a PC.
176                       assign pc_mux_internal =
177                         (BranchPredictor && predict_branch_taken && !pc_set_i) ? PC_BP : pc_mux_i;
178                     
179                       // fetch address selection mux
180                       always_comb begin : fetch_addr_mux
181        1/1              unique case (pc_mux_internal)
182        1/1                PC_BOOT: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
183        0/1     ==>        PC_JUMP: fetch_addr_n = branch_target_ex_i;
184        0/1     ==>        PC_EXC:  fetch_addr_n = exc_pc;                       // set PC to exception handler
185        0/1     ==>        PC_ERET: fetch_addr_n = csr_mepc_i;                   // restore PC when returning from EXC
186        0/1     ==>        PC_DRET: fetch_addr_n = csr_depc_i;
187                           // Without branch predictor will never get pc_mux_internal == PC_BP. We still handle no branch
188                           // predictor case here to ensure redundant mux logic isn't synthesised.
189        0/1     ==>        PC_BP:   fetch_addr_n = BranchPredictor ? predict_branch_pc : { boot_addr_i[31:8], 8'h80 };
190        0/1     ==>        default: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
191                         endcase
192                       end
193                     
194                       // tell CS register file to initialize mtvec on boot
195                       assign csr_mtvec_init_o = (pc_mux_i == PC_BOOT) & pc_set_i;
196                     
197                       if (ICache) begin : gen_icache
198                         // Full I-Cache option
199                         ibex_icache #(
200                           .BranchPredictor (BranchPredictor),
201                           .ICacheECC       (ICacheECC),
202                           .BusSizeECC      (BusSizeECC),
203                           .TagSizeECC      (TagSizeECC),
204                           .LineSizeECC     (LineSizeECC)
205                         ) icache_i (
206                             .clk_i               ( clk_i                      ),
207                             .rst_ni              ( rst_ni                     ),
208                     
209                             .req_i               ( req_i                      ),
210                     
211                             .branch_i            ( branch_req                 ),
212                             .branch_spec_i       ( branch_spec                ),
213                             .predicted_branch_i  ( predicted_branch           ),
214                             .branch_mispredict_i ( nt_branch_mispredict_i     ),
215                             .addr_i              ( {fetch_addr_n[31:1], 1'b0} ),
216                     
217                             .ready_i             ( fetch_ready                ),
218                             .valid_o             ( fetch_valid                ),
219                             .rdata_o             ( fetch_rdata                ),
220                             .addr_o              ( fetch_addr                 ),
221                             .err_o               ( fetch_err                  ),
222                             .err_plus2_o         ( fetch_err_plus2            ),
223                     
224                             .instr_req_o         ( instr_req_o                ),
225                             .instr_addr_o        ( instr_addr_o               ),
226                             .instr_gnt_i         ( instr_gnt_i                ),
227                             .instr_rvalid_i      ( instr_rvalid_i             ),
228                             .instr_rdata_i       ( instr_rdata_i              ),
229                             .instr_err_i         ( instr_err_i                ),
230                             .instr_pmp_err_i     ( instr_pmp_err_i            ),
231                     
232                             .ic_tag_req_o        ( ic_tag_req_o               ),
233                             .ic_tag_write_o      ( ic_tag_write_o             ),
234                             .ic_tag_addr_o       ( ic_tag_addr_o              ),
235                             .ic_tag_wdata_o      ( ic_tag_wdata_o             ),
236                             .ic_tag_rdata_i      ( ic_tag_rdata_i             ),
237                             .ic_data_req_o       ( ic_data_req_o              ),
238                             .ic_data_write_o     ( ic_data_write_o            ),
239                             .ic_data_addr_o      ( ic_data_addr_o             ),
240                             .ic_data_wdata_o     ( ic_data_wdata_o            ),
241                             .ic_data_rdata_i     ( ic_data_rdata_i            ),
242                     
243                             .icache_enable_i     ( icache_enable_i            ),
244                             .icache_inval_i      ( icache_inval_i             ),
245                             .busy_o              ( prefetch_busy              )
246                         );
247                       end else begin : gen_prefetch_buffer
248                         // prefetch buffer, caches a fixed number of instructions
249                         ibex_prefetch_buffer #(
250                           .BranchPredictor (BranchPredictor)
251                         ) prefetch_buffer_i (
252                             .clk_i               ( clk_i                      ),
253                             .rst_ni              ( rst_ni                     ),
254                     
255                             .req_i               ( req_i                      ),
256                     
257                             .branch_i            ( branch_req                 ),
258                             .branch_spec_i       ( branch_spec                ),
259                             .predicted_branch_i  ( predicted_branch           ),
260                             .branch_mispredict_i ( nt_branch_mispredict_i     ),
261                             .addr_i              ( {fetch_addr_n[31:1], 1'b0} ),
262                     
263                             .ready_i             ( fetch_ready                ),
264                             .valid_o             ( fetch_valid                ),
265                             .rdata_o             ( fetch_rdata                ),
266                             .addr_o              ( fetch_addr                 ),
267                             .err_o               ( fetch_err                  ),
268                             .err_plus2_o         ( fetch_err_plus2            ),
269                     
270                             .instr_req_o         ( instr_req_o                ),
271                             .instr_addr_o        ( instr_addr_o               ),
272                             .instr_gnt_i         ( instr_gnt_i                ),
273                             .instr_rvalid_i      ( instr_rvalid_i             ),
274                             .instr_rdata_i       ( instr_rdata_i              ),
275                             .instr_err_i         ( instr_err_i                ),
276                             .instr_pmp_err_i     ( instr_pmp_err_i            ),
277                     
278                             .busy_o              ( prefetch_busy              )
279                         );
280                         // ICache tieoffs
281                         logic                   unused_icen, unused_icinv;
282                         logic [TagSizeECC-1:0]  unused_tag_ram_input [IC_NUM_WAYS];
283                         logic [LineSizeECC-1:0] unused_data_ram_input [IC_NUM_WAYS];
284                         assign unused_icen           = icache_enable_i;
285                         assign unused_icinv          = icache_inval_i;
286                         assign unused_tag_ram_input  = ic_tag_rdata_i;
287                         assign unused_data_ram_input = ic_data_rdata_i;
288                         assign ic_tag_req_o          = 'b0;
289                         assign ic_tag_write_o        = 'b0;
290                         assign ic_tag_addr_o         = 'b0;
291                         assign ic_tag_wdata_o        = 'b0;
292                         assign ic_data_req_o         = 'b0;
293                         assign ic_data_write_o       = 'b0;
294                         assign ic_data_addr_o        = 'b0;
295                         assign ic_data_wdata_o       = 'b0;
296                       end
297                     
298                       assign unused_fetch_addr_n0 = fetch_addr_n[0];
299                     
300                       assign branch_req  = pc_set_i | predict_branch_taken;
301                       assign branch_spec = pc_set_spec_i | predict_branch_taken;
302                     
303                       assign pc_if_o     = if_instr_addr;
304                       assign if_busy_o   = prefetch_busy;
305                     
306                       // compressed instruction decoding, or more precisely compressed instruction
307                       // expander
308                       //
309                       // since it does not matter where we decompress instructions, we do it here
310                       // to ease timing closure
311                       logic [31:0] instr_decompressed;
312                       logic        illegal_c_insn;
313                       logic        instr_is_compressed;
314                     
315                       ibex_compressed_decoder compressed_decoder_i (
316                           .clk_i           ( clk_i                    ),
317                           .rst_ni          ( rst_ni                   ),
318                           .valid_i         ( fetch_valid & ~fetch_err ),
319                           .instr_i         ( if_instr_rdata           ),
320                           .instr_o         ( instr_decompressed       ),
321                           .is_compressed_o ( instr_is_compressed      ),
322                           .illegal_instr_o ( illegal_c_insn           )
323                       );
324                     
325                       // Dummy instruction insertion
326                       if (DummyInstructions) begin : gen_dummy_instr
327                         logic        insert_dummy_instr;
328                         logic [31:0] dummy_instr_data;
329                     
330                         ibex_dummy_instr dummy_instr_i (
331                           .clk_i                 ( clk_i                 ),
332                           .rst_ni                ( rst_ni                ),
333                           .dummy_instr_en_i      ( dummy_instr_en_i      ),
334                           .dummy_instr_mask_i    ( dummy_instr_mask_i    ),
335                           .dummy_instr_seed_en_i ( dummy_instr_seed_en_i ),
336                           .dummy_instr_seed_i    ( dummy_instr_seed_i    ),
337                           .fetch_valid_i         ( fetch_valid           ),
338                           .id_in_ready_i         ( id_in_ready_i         ),
339                           .insert_dummy_instr_o  ( insert_dummy_instr    ),
340                           .dummy_instr_data_o    ( dummy_instr_data      )
341                         );
342                     
343                         // Mux between actual instructions and dummy instructions
344                         assign instr_out               = insert_dummy_instr ? dummy_instr_data : instr_decompressed;
345                         assign instr_is_compressed_out = insert_dummy_instr ? 1'b0 : instr_is_compressed;
346                         assign illegal_c_instr_out     = insert_dummy_instr ? 1'b0 : illegal_c_insn;
347                         assign instr_err_out           = insert_dummy_instr ? 1'b0 : if_instr_err;
348                     
349                         // Stall the IF stage if we insert a dummy instruction. The dummy will execute between whatever
350                         // is currently in the ID stage and whatever is valid from the prefetch buffer this cycle. The
351                         // PC of the dummy instruction will match whatever is next from the prefetch buffer.
352                         assign stall_dummy_instr = insert_dummy_instr;
353                     
354                         // Register the dummy instruction indication into the ID stage
355                         always_ff @(posedge clk_i or negedge rst_ni) begin
356                           if (!rst_ni) begin
357                             dummy_instr_id_o <= 1'b0;
358                           end else if (if_id_pipe_reg_we) begin
359                             dummy_instr_id_o <= insert_dummy_instr;
360                           end
361                         end
362                     
363                       end else begin : gen_no_dummy_instr
364                         logic        unused_dummy_en;
365                         logic [2:0]  unused_dummy_mask;
366                         logic        unused_dummy_seed_en;
367                         logic [31:0] unused_dummy_seed;
368                     
369                         assign unused_dummy_en         = dummy_instr_en_i;
370                         assign unused_dummy_mask       = dummy_instr_mask_i;
371                         assign unused_dummy_seed_en    = dummy_instr_seed_en_i;
372                         assign unused_dummy_seed       = dummy_instr_seed_i;
373                         assign instr_out               = instr_decompressed;
374                         assign instr_is_compressed_out = instr_is_compressed;
375                         assign illegal_c_instr_out     = illegal_c_insn;
376                         assign instr_err_out           = if_instr_err;
377                         assign stall_dummy_instr       = 1'b0;
378                         assign dummy_instr_id_o        = 1'b0;
379                       end
380                     
381                       // The ID stage becomes valid as soon as any instruction is registered in the ID stage flops.
382                       // Note that the current instruction is squashed by the incoming pc_set_i signal.
383                       // Valid is held until it is explicitly cleared (due to an instruction completing or an exception)
384                       assign instr_valid_id_d = (if_instr_valid & id_in_ready_i & ~pc_set_i) |
385                                                 (instr_valid_id_q & ~instr_valid_clear_i);
386                       assign instr_new_id_d   = if_instr_valid & id_in_ready_i;
387                     
388                       always_ff @(posedge clk_i or negedge rst_ni) begin
389        1/1              if (!rst_ni) begin
390        1/1                instr_valid_id_q <= 1'b0;
391        1/1                instr_new_id_q   <= 1'b0;
392                         end else begin
393        0/1     ==>        instr_valid_id_q <= instr_valid_id_d;
394        0/1     ==>        instr_new_id_q   <= instr_new_id_d;
395                         end
396                       end
397                     
398                       assign instr_valid_id_o = instr_valid_id_q;
399                       // Signal when a new instruction enters the ID stage (only used for RVFI signalling).
400                       assign instr_new_id_o   = instr_new_id_q;
401                     
402                       // IF-ID pipeline registers, frozen when the ID stage is stalled
403                       assign if_id_pipe_reg_we = instr_new_id_d;
404                     
405                       always_ff @(posedge clk_i) begin
406        1/1              if (if_id_pipe_reg_we) begin
407        0/1     ==>        instr_rdata_id_o         <= instr_out;
408                           // To reduce fan-out and help timing from the instr_rdata_id flops they are replicated.
409        0/1     ==>        instr_rdata_alu_id_o     <= instr_out;
410        0/1     ==>        instr_fetch_err_o        <= instr_err_out;
411        0/1     ==>        instr_fetch_err_plus2_o  <= fetch_err_plus2;
412        0/1     ==>        instr_rdata_c_id_o       <= if_instr_rdata[15:0];
413        0/1     ==>        instr_is_compressed_id_o <= instr_is_compressed_out;
414        0/1     ==>        illegal_c_insn_id_o      <= illegal_c_instr_out;
415        0/1     ==>        pc_id_o                  <= pc_if_o;
416                         end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_if_stage
                Total Covered Percent 
Totals          96    0       0.00    
Total Bits      1852  0       0.00    
Total Bits 0->1 926   0       0.00    
Total Bits 1->0 926   0       0.00    

                             
Ports          53   0 0.00   
Port Bits      1100 0 0.00   
Port Bits 0->1 550  0 0.00   
Port Bits 1->0 550  0 0.00   

                              
Signals          43  0 0.00   
Signal Bits      752 0 0.00   
Signal Bits 0->1 376 0 0.00   
Signal Bits 1->0 376 0 0.00   

Port Details
                           Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                      No     No          No          INPUT     
rst_ni                     No     No          No          INPUT     
boot_addr_i[31:0]          No     No          No          INPUT     
req_i                      No     No          No          INPUT     
instr_req_o                No     No          No          OUTPUT    
instr_addr_o[31:0]         No     No          No          OUTPUT    
instr_gnt_i                No     No          No          INPUT     
instr_rvalid_i             No     No          No          INPUT     
instr_rdata_i[31:0]        No     No          No          INPUT     
instr_err_i                No     No          No          INPUT     
instr_pmp_err_i            No     No          No          INPUT     
ic_tag_req_o[1:0]          No     No          No          OUTPUT    
ic_tag_write_o             No     No          No          OUTPUT    
ic_tag_addr_o[7:0]         No     No          No          OUTPUT    
ic_tag_wdata_o[21:0]       No     No          No          OUTPUT    
ic_data_req_o[1:0]         No     No          No          OUTPUT    
ic_data_write_o            No     No          No          OUTPUT    
ic_data_addr_o[7:0]        No     No          No          OUTPUT    
ic_data_wdata_o[63:0]      No     No          No          OUTPUT    
instr_valid_id_o           No     No          No          OUTPUT    
instr_new_id_o             No     No          No          OUTPUT    
instr_rdata_id_o[31:0]     No     No          No          OUTPUT    
instr_rdata_alu_id_o[31:0] No     No          No          OUTPUT    
instr_rdata_c_id_o[15:0]   No     No          No          OUTPUT    
instr_is_compressed_id_o   No     No          No          OUTPUT    
instr_bp_taken_o           No     No          No          OUTPUT    
instr_fetch_err_o          No     No          No          OUTPUT    
instr_fetch_err_plus2_o    No     No          No          OUTPUT    
illegal_c_insn_id_o        No     No          No          OUTPUT    
dummy_instr_id_o           No     No          No          OUTPUT    
pc_if_o[31:0]              No     No          No          OUTPUT    
pc_id_o[31:0]              No     No          No          OUTPUT    
instr_valid_clear_i        No     No          No          INPUT     
pc_set_i                   No     No          No          INPUT     
pc_set_spec_i              No     No          No          INPUT     
pc_mux_i[2:0]              No     No          No          INPUT     
nt_branch_mispredict_i     No     No          No          INPUT     
exc_pc_mux_i[1:0]          No     No          No          INPUT     
exc_cause[5:0]             No     No          No          INPUT     
dummy_instr_en_i           No     No          No          INPUT     
dummy_instr_mask_i[2:0]    No     No          No          INPUT     
dummy_instr_seed_en_i      No     No          No          INPUT     
dummy_instr_seed_i[31:0]   No     No          No          INPUT     
icache_enable_i            No     No          No          INPUT     
icache_inval_i             No     No          No          INPUT     
branch_target_ex_i[31:0]   No     No          No          INPUT     
csr_mepc_i[31:0]           No     No          No          INPUT     
csr_depc_i[31:0]           No     No          No          INPUT     
csr_mtvec_i[31:0]          No     No          No          INPUT     
csr_mtvec_init_o           No     No          No          OUTPUT    
id_in_ready_i              No     No          No          INPUT     
pc_mismatch_alert_o        No     No          No          OUTPUT    
if_busy_o                  No     No          No          OUTPUT    

Signal Details
                                           Toggle Toggle 1->0 Toggle 0->1 
instr_valid_id_d                           No     No          No          
instr_valid_id_q                           No     No          No          
instr_new_id_d                             No     No          No          
instr_new_id_q                             No     No          No          
prefetch_busy                              No     No          No          
branch_req                                 No     No          No          
branch_spec                                No     No          No          
predicted_branch                           No     No          No          
fetch_addr_n[31:0]                         No     No          No          
unused_fetch_addr_n0                       No     No          No          
fetch_valid                                No     No          No          
fetch_ready                                No     No          No          
fetch_rdata[31:0]                          No     No          No          
fetch_addr[31:0]                           No     No          No          
fetch_err                                  No     No          No          
fetch_err_plus2                            No     No          No          
if_instr_valid                             No     No          No          
if_instr_rdata[31:0]                       No     No          No          
if_instr_addr[31:0]                        No     No          No          
if_instr_err                               No     No          No          
exc_pc[31:0]                               No     No          No          
irq_id[5:0]                                No     No          No          
unused_irq_bit                             No     No          No          
if_id_pipe_reg_we                          No     No          No          
stall_dummy_instr                          No     No          No          
instr_out[31:0]                            No     No          No          
instr_is_compressed_out                    No     No          No          
illegal_c_instr_out                        No     No          No          
instr_err_out                              No     No          No          
predict_branch_taken                       No     No          No          
predict_branch_pc[31:0]                    No     No          No          
pc_mux_internal[2:0]                       No     No          No          
unused_boot_addr[7:0]                      No     No          No          
unused_csr_mtvec[7:0]                      No     No          No          
instr_decompressed[31:0]                   No     No          No          
illegal_c_insn                             No     No          No          
instr_is_compressed                        No     No          No          
gen_prefetch_buffer.unused_icen            No     No          No          
gen_prefetch_buffer.unused_icinv           No     No          No          
gen_no_dummy_instr.unused_dummy_en         No     No          No          
gen_no_dummy_instr.unused_dummy_mask[2:0]  No     No          No          
gen_no_dummy_instr.unused_dummy_seed_en    No     No          No          
gen_no_dummy_instr.unused_dummy_seed[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_if_stage
         Line No. Total Covered Percent 
Branches          16    4       25.00   
CASE     165      5     1       20.00   
CASE     181      7     1       14.29   
IF       389      2     1       50.00   
IF       406      2     1       50.00   


165            unique case (exc_pc_mux_i)
                      -1-  
166              EXC_PC_EXC:     exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
                 ==>
167              EXC_PC_IRQ:     exc_pc = { csr_mtvec_i[31:8], 1'b0, irq_id[4:0], 2'b00 };
                 ==>
168              EXC_PC_DBD:     exc_pc = DmHaltAddr;
                 ==>
169              EXC_PC_DBG_EXC: exc_pc = DmExceptionAddr;
                 ==>
170              default:        exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
                 ==>

Branches:

-1-             Status      
EXC_PC_EXC      Not Covered 
EXC_PC_IRQ      Covered     
EXC_PC_DBD      Not Covered 
EXC_PC_DBG_EXC  Not Covered 
default         Not Covered 


181            unique case (pc_mux_internal)
                      -1-  
182              PC_BOOT: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
                 ==>
183              PC_JUMP: fetch_addr_n = branch_target_ex_i;
                 ==>
184              PC_EXC:  fetch_addr_n = exc_pc;                       // set PC to exception handler
                 ==>
185              PC_ERET: fetch_addr_n = csr_mepc_i;                   // restore PC when returning from EXC
                 ==>
186              PC_DRET: fetch_addr_n = csr_depc_i;
                 ==>
187              // Without branch predictor will never get pc_mux_internal == PC_BP. We still handle no branch
188              // predictor case here to ensure redundant mux logic isn't synthesised.
189              PC_BP:   fetch_addr_n = BranchPredictor ? predict_branch_pc : { boot_addr_i[31:8], 8'h80 };
                 ==>
190              default: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
                 ==>

Branches:

-1-      Status      
PC_BOOT  Covered     
PC_JUMP  Not Covered 
PC_EXC   Not Covered 
PC_ERET  Not Covered 
PC_DRET  Not Covered 
PC_BP    Not Covered 
default  Not Covered 


389            if (!rst_ni) begin
               -1-  
390              instr_valid_id_q <= 1'b0;
                 ==>
391              instr_new_id_q   <= 1'b0;
392            end else begin
393              instr_valid_id_q <= instr_valid_id_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


406            if (if_id_pipe_reg_we) begin
               -1-    
407              instr_rdata_id_o         <= instr_out;
                 ==>
408              // To reduce fan-out and help timing from the instr_rdata_id flops they are replicated.
409              instr_rdata_alu_id_o     <= instr_out;
410              instr_fetch_err_o        <= instr_err_out;
411              instr_fetch_err_plus2_o  <= fetch_err_plus2;
412              instr_rdata_c_id_o       <= if_instr_rdata[15:0];
413              instr_is_compressed_id_o <= instr_is_compressed_out;
414              illegal_c_insn_id_o      <= illegal_c_instr_out;
415              pc_id_o                  <= pc_if_o;
416            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_if_stage
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       5     5         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            5     5         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                                         Attempts Real Successes Failures Incomplete 
IbexBootAddrUnaligned                        3        0              0        0          
IbexExcPcMuxKnown                            3        0              0        0          
IbexInstrAddrUnaligned                       3        0              0        0          
IbexInstrAddrUnknown                         3        0              0        0          
g_no_branch_predictor_asserts.IbexPcMuxValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.if_stage_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 13.39  28.57 --       0.00  25.00   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 21.85  26.19  52.27   0.00  30.77   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME          
 13.39  28.57 --       0.00  25.00   0.00 ibex_if_stage 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME        
 20.58  43.66  14.29   0.00  28.26  16.67 u_ibex_core 


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                  
  2.35   6.90 --       0.00   2.50   0.00 compressed_decoder_i                  
 31.12  52.50  52.27   0.00  50.82   0.00 gen_prefetch_buffer.prefetch_buffer_i 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_multdiv_fast
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 13.62  39.02   7.14   0.00  21.95   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_multdiv_fast.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                                    
 13.62  39.02   7.14   0.00  21.95   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.ex_block_i.gen_multdiv_fast.multdiv_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_multdiv_fast

             Line No.   Total   Covered  Percent
TOTAL                      123       48    39.02
ALWAYS             99       12        6    50.00
ALWAYS            278       50       18    36.00
ALWAYS            363        4        2    50.00
ALWAYS            392        3        3   100.00
ALWAYS            406       54       19    35.19

98                        always_ff @(posedge clk_i or negedge rst_ni) begin
99         1/1              if (!rst_ni) begin
100        1/1                div_counter_q    <= '0;
101        1/1                md_state_q       <= MD_IDLE;
102        1/1                op_numerator_q   <= '0;
103        1/1                op_quotient_q    <= '0;
104        1/1                div_by_zero_q    <= '0;
105        0/1     ==>      end else if (div_en_internal) begin
106        0/1     ==>        div_counter_q    <= div_counter_d;
107        0/1     ==>        op_numerator_q   <= op_numerator_d;
108        0/1     ==>        op_quotient_q    <= op_quotient_d;
109        0/1     ==>        md_state_q       <= md_state_d;
110        0/1     ==>        div_by_zero_q    <= div_by_zero_d;
111                         end
                   ==>  MISSING_ELSE
112                       end
113                     
114                       `ASSERT_KNOWN(DivEnKnown, div_en_internal)
115                       `ASSERT_KNOWN(MultEnKnown, mult_en_internal)
116                       `ASSERT_KNOWN(MultDivEnKnown, multdiv_en)
117                     
118                       assign multdiv_en = mult_en_internal | div_en_internal;
119                     
120                       // Intermediate value register shared with ALU
121                       assign imd_val_d_o[0] = div_sel_i ? op_remainder_d : mac_res_d;
122                       assign imd_val_we_o[0] = multdiv_en;
123                     
124                       assign imd_val_d_o[1] = {2'b0, op_denominator_d};
125                       assign imd_val_we_o[1] = div_en_internal;
126                       assign op_denominator_q = imd_val_q_i[1][31:0];
127                       logic [1:0] unused_imd_val;
128                       assign unused_imd_val = imd_val_q_i[1][33:32];
129                       logic unused_mac_res_ext;
130                       assign unused_mac_res_ext = mac_res_ext[34];
131                     
132                       assign signed_mult      = (signed_mode_i != 2'b00);
133                       assign multdiv_result_o = div_sel_i ? imd_val_q_i[0][31:0] : mac_res_d[31:0];
134                     
135                       // The single cycle multiplier uses three 17 bit multipliers to compute MUL instructions in a
136                       // single cycle and MULH instructions in two cycles.
137                       if (RV32M == RV32MSingleCycle) begin : gen_mult_single_cycle
138                     
139                         typedef enum logic {
140                           MULL, MULH
141                         } mult_fsm_e;
142                         mult_fsm_e mult_state_q, mult_state_d;
143                     
144                         logic signed [33:0] mult1_res, mult2_res, mult3_res;
145                         logic [33:0]        mult1_res_uns;
146                         logic [33:32]       unused_mult1_res_uns;
147                         logic [15:0]        mult1_op_a, mult1_op_b;
148                         logic [15:0]        mult2_op_a, mult2_op_b;
149                         logic [15:0]        mult3_op_a, mult3_op_b;
150                         logic               mult1_sign_a, mult1_sign_b;
151                         logic               mult2_sign_a, mult2_sign_b;
152                         logic               mult3_sign_a, mult3_sign_b;
153                         logic [33:0]        summand1, summand2, summand3;
154                     
155                         assign mult1_res = $signed({mult1_sign_a, mult1_op_a}) * $signed({mult1_sign_b, mult1_op_b});
156                         assign mult2_res = $signed({mult2_sign_a, mult2_op_a}) * $signed({mult2_sign_b, mult2_op_b});
157                         assign mult3_res = $signed({mult3_sign_a, mult3_op_a}) * $signed({mult3_sign_b, mult3_op_b});
158                     
159                         assign mac_res_signed = $signed(summand1) + $signed(summand2) + $signed(summand3);
160                     
161                         assign mult1_res_uns  = $unsigned(mult1_res);
162                         assign mac_res_ext    = $unsigned(mac_res_signed);
163                         assign mac_res        = mac_res_ext[33:0];
164                     
165                         assign sign_a = signed_mode_i[0] & op_a_i[31];
166                         assign sign_b = signed_mode_i[1] & op_b_i[31];
167                     
168                         // The first two multipliers are only used in state 1 (MULL). We can assign them statically.
169                         // al*bl
170                         assign mult1_sign_a = 1'b0;
171                         assign mult1_sign_b = 1'b0;
172                         assign mult1_op_a = op_a_i[`OP_L];
173                         assign mult1_op_b = op_b_i[`OP_L];
174                     
175                         // al*bh
176                         assign mult2_sign_a = 1'b0;
177                         assign mult2_sign_b = sign_b;
178                         assign mult2_op_a = op_a_i[`OP_L];
179                         assign mult2_op_b = op_b_i[`OP_H];
180                     
181                         // used in MULH
182                         assign accum[17:0] = imd_val_q_i[0][33:16];
183                         assign accum[33:18] = {16{signed_mult & imd_val_q_i[0][33]}};
184                     
185                         always_comb begin
186                           // Default values == MULL
187                     
188                           // ah*bl
189                           mult3_sign_a = sign_a;
190                           mult3_sign_b = 1'b0;
191                           mult3_op_a = op_a_i[`OP_H];
192                           mult3_op_b = op_b_i[`OP_L];
193                     
194                           summand1 = {18'h0, mult1_res_uns[`OP_H]};
195                           summand2 = $unsigned(mult2_res);
196                           summand3 = $unsigned(mult3_res);
197                     
198                           // mac_res = A*B[47:16], mult1_res = A*B[15:0]
199                           mac_res_d = {2'b0, mac_res[`OP_L], mult1_res_uns[`OP_L]};
200                           mult_valid = mult_en_i;
201                           mult_state_d = MULL;
202                     
203                           mult_hold = 1'b0;
204                     
205                           unique case (mult_state_q)
206                     
207                             MULL: begin
208                               if (operator_i != MD_OP_MULL) begin
209                                 mac_res_d = mac_res;
210                                 mult_valid = 1'b0;
211                                 mult_state_d = MULH;
212                               end else begin
213                                 mult_hold = ~multdiv_ready_id_i;
214                               end
215                             end
216                     
217                             MULH: begin
218                               // ah*bh
219                               mult3_sign_a = sign_a;
220                               mult3_sign_b = sign_b;
221                               mult3_op_a = op_a_i[`OP_H];
222                               mult3_op_b = op_b_i[`OP_H];
223                               mac_res_d = mac_res;
224                     
225                               summand1 = '0;
226                               summand2 = accum;
227                               summand3 = $unsigned(mult3_res);
228                     
229                               mult_state_d = MULL;
230                               mult_valid = 1'b1;
231                     
232                               mult_hold = ~multdiv_ready_id_i;
233                             end
234                     
235                             default: begin
236                               mult_state_d = MULL;
237                             end
238                     
239                           endcase // mult_state_q
240                         end
241                     
242                         always_ff @(posedge clk_i or negedge rst_ni) begin
243                           if (!rst_ni) begin
244                             mult_state_q <= MULL;
245                           end else begin
246                             if (mult_en_internal) begin
247                               mult_state_q <= mult_state_d;
248                             end
249                           end
250                         end
251                     
252                         assign unused_mult1_res_uns = mult1_res_uns[33:32];
253                     
254                         // States must be knwon/valid.
255                         `ASSERT_KNOWN(IbexMultStateKnown, mult_state_q)
256                     
257                       // The fast multiplier uses one 17 bit multiplier to compute MUL instructions in 3 cycles
258                       // and MULH instructions in 4 cycles.
259                       end else begin : gen_mult_fast
260                         logic [15:0] mult_op_a;
261                         logic [15:0] mult_op_b;
262                     
263                         typedef enum logic [1:0] {
264                           ALBL, ALBH, AHBL, AHBH
265                         } mult_fsm_e;
266                         mult_fsm_e mult_state_q, mult_state_d;
267                     
268                         // The 2 MSBs of mac_res_ext (mac_res_ext[34:33]) are always equal since:
269                         // 1. The 2 MSBs of the multiplicants are always equal, and
270                         // 2. The 16 MSBs of the addend (accum[33:18]) are always equal.
271                         // Thus, it is safe to ignore mac_res_ext[34].
272                         assign mac_res_signed =
273                             $signed({sign_a, mult_op_a}) * $signed({sign_b, mult_op_b}) + $signed(accum);
274                         assign mac_res_ext    = $unsigned(mac_res_signed);
275                         assign mac_res        = mac_res_ext[33:0];
276                     
277                         always_comb begin
278        1/1                mult_op_a    = op_a_i[`OP_L];
279        1/1                mult_op_b    = op_b_i[`OP_L];
280        1/1                sign_a       = 1'b0;
281        1/1                sign_b       = 1'b0;
282        1/1                accum        = imd_val_q_i[0];
283        1/1                mac_res_d    = mac_res;
284        1/1                mult_state_d = mult_state_q;
285        1/1                mult_valid   = 1'b0;
286        1/1                mult_hold    = 1'b0;
287                     
288        1/1                unique case (mult_state_q)
289                     
290                             ALBL: begin
291                               // al*bl
292        1/1                    mult_op_a = op_a_i[`OP_L];
293        1/1                    mult_op_b = op_b_i[`OP_L];
294        1/1                    sign_a    = 1'b0;
295        1/1                    sign_b    = 1'b0;
296        1/1                    accum     = '0;
297        1/1                    mac_res_d = mac_res;
298        1/1                    mult_state_d = ALBH;
299                             end
300                     
301                             ALBH: begin
302                               // al*bh<<16
303        0/1     ==>            mult_op_a = op_a_i[`OP_L];
304        0/1     ==>            mult_op_b = op_b_i[`OP_H];
305        0/1     ==>            sign_a    = 1'b0;
306        0/1     ==>            sign_b    = signed_mode_i[1] & op_b_i[31];
307                               // result of AL*BL (in imd_val_q_i[0]) always unsigned with no carry
308        0/1     ==>            accum     = {18'b0, imd_val_q_i[0][31:16]};
309        0/1     ==>            if (operator_i == MD_OP_MULL) begin
310        0/1     ==>              mac_res_d = {2'b0, mac_res[`OP_L], imd_val_q_i[0][`OP_L]};
311                               end else begin
312                                 // MD_OP_MULH
313        0/1     ==>              mac_res_d = mac_res;
314                               end
315        0/1     ==>            mult_state_d = AHBL;
316                             end
317                     
318                             AHBL: begin
319                               // ah*bl<<16
320        0/1     ==>            mult_op_a = op_a_i[`OP_H];
321        0/1     ==>            mult_op_b = op_b_i[`OP_L];
322        0/1     ==>            sign_a    = signed_mode_i[0] & op_a_i[31];
323        0/1     ==>            sign_b    = 1'b0;
324        0/1     ==>            if (operator_i == MD_OP_MULL) begin
325        0/1     ==>              accum        = {18'b0, imd_val_q_i[0][31:16]};
326        0/1     ==>              mac_res_d    = {2'b0, mac_res[15:0], imd_val_q_i[0][15:0]};
327        0/1     ==>              mult_valid   = 1'b1;
328                     
329                                 // Note no state transition will occur if mult_hold is set
330        0/1     ==>              mult_state_d = ALBL;
331        0/1     ==>              mult_hold    = ~multdiv_ready_id_i;
332                               end else begin
333        0/1     ==>              accum        = imd_val_q_i[0];
334        0/1     ==>              mac_res_d    = mac_res;
335        0/1     ==>              mult_state_d = AHBH;
336                               end
337                             end
338                     
339                             AHBH: begin
340                               // only MD_OP_MULH here
341                               // ah*bh
342        0/1     ==>            mult_op_a = op_a_i[`OP_H];
343        0/1     ==>            mult_op_b = op_b_i[`OP_H];
344        0/1     ==>            sign_a    = signed_mode_i[0] & op_a_i[31];
345        0/1     ==>            sign_b    = signed_mode_i[1] & op_b_i[31];
346        0/1     ==>            accum[17: 0]  = imd_val_q_i[0][33:16];
347        0/1     ==>            accum[33:18]  = {16{signed_mult & imd_val_q_i[0][33]}};
348                               // result of AH*BL is not signed only if signed_mode_i == 2'b00
349        0/1     ==>            mac_res_d    = mac_res;
350        0/1     ==>            mult_valid   = 1'b1;
351                     
352                               // Note no state transition will occur if mult_hold is set
353        0/1     ==>            mult_state_d = ALBL;
354        0/1     ==>            mult_hold    = ~multdiv_ready_id_i;
355                             end
356                             default: begin
357        1/1                    mult_state_d = ALBL;
358                             end
359                           endcase // mult_state_q
360                         end
361                     
362                         always_ff @(posedge clk_i or negedge rst_ni) begin
363        1/1                if (!rst_ni) begin
364        1/1                  mult_state_q <= ALBL;
365                           end else begin
366        0/1     ==>          if (mult_en_internal) begin
367        0/1     ==>            mult_state_q <= mult_state_d;
368                             end
                   ==>  MISSING_ELSE
369                           end
370                         end
371                     
372                         // States must be knwon/valid.
373                         `ASSERT_KNOWN(IbexMultStateKnown, mult_state_q)
374                     
375                       end // gen_mult_fast
376                     
377                       // Divider
378                       assign res_adder_h    = alu_adder_ext_i[32:1];
379                       logic [1:0] unused_alu_adder_ext;
380                       assign unused_alu_adder_ext = {alu_adder_ext_i[33],alu_adder_ext_i[0]};
381                     
382                       assign next_remainder = is_greater_equal ? res_adder_h[31:0] : imd_val_q_i[0][31:0];
383                       assign next_quotient  = is_greater_equal ? {1'b0, op_quotient_q} | {1'b0, one_shift} :
384                                                                  {1'b0, op_quotient_q};
385                     
386                       assign one_shift      = {31'b0, 1'b1} << div_counter_q;
387                     
388                       // The adder in the ALU computes alu_operand_a_o + alu_operand_b_o which means
389                       // Remainder - Divisor. If Remainder - Divisor >= 0, is_greater_equal is equal to 1,
390                       // the next Remainder is Remainder - Divisor contained in res_adder_h and the
391                       always_comb begin
392        1/1              if ((imd_val_q_i[0][31] ^ op_denominator_q[31]) == 1'b0) begin
393        1/1                is_greater_equal = (res_adder_h[31] == 1'b0);
394                         end else begin
395        1/1                is_greater_equal = imd_val_q_i[0][31];
396                         end
397                       end
398                     
399                       assign div_sign_a      = op_a_i[31] & signed_mode_i[0];
400                       assign div_sign_b      = op_b_i[31] & signed_mode_i[1];
401                       assign div_change_sign = (div_sign_a ^ div_sign_b) & ~div_by_zero_q;
402                       assign rem_change_sign = div_sign_a;
403                     
404                     
405                       always_comb begin
406        1/1              div_counter_d    = div_counter_q - 5'h1;
407        1/1              op_remainder_d   = imd_val_q_i[0];
408        1/1              op_quotient_d    = op_quotient_q;
409        1/1              md_state_d       = md_state_q;
410        1/1              op_numerator_d   = op_numerator_q;
411        1/1              op_denominator_d = op_denominator_q;
412        1/1              alu_operand_a_o  = {32'h0  , 1'b1};
413        1/1              alu_operand_b_o  = {~op_b_i, 1'b1};
414        1/1              div_valid        = 1'b0;
415        1/1              div_hold         = 1'b0;
416        1/1              div_by_zero_d    = div_by_zero_q;
417                     
418        1/1              unique case(md_state_q)
419                           MD_IDLE: begin
420        1/1                  if (operator_i == MD_OP_DIV) begin
421                               // Check if the Denominator is 0
422                               // quotient for division by 0 is specified to be -1
423                               // Note with data-independent time option, the full divide operation will proceed as
424                               // normal and will naturally return -1
425        0/1     ==>            op_remainder_d = '1;
426        0/1     ==>            md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? MD_FINISH : MD_ABS_A;
427                               // Record that this is a div by zero to stop the sign change at the end of the
428                               // division (in data_ind_timing mode).
429        0/1     ==>            div_by_zero_d  = equal_to_zero_i;
430                             end else begin
431                               // Check if the Denominator is 0
432                               // remainder for division by 0 is specified to be the numerator (operand a)
433                               // Note with data-independent time option, the full divide operation will proceed as
434                               // normal and will naturally return operand a
435        1/1                    op_remainder_d = {2'b0, op_a_i};
436        1/1                    md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? MD_FINISH : MD_ABS_A;
437                             end
438                             // 0 - B = 0 iff B == 0
439        1/1                  alu_operand_a_o  = {32'h0  , 1'b1};
440        1/1                  alu_operand_b_o  = {~op_b_i, 1'b1};
441        1/1                  div_counter_d    = 5'd31;
442                           end
443                     
444                           MD_ABS_A: begin
445                             // quotient
446        0/1     ==>          op_quotient_d   = '0;
447                             // A abs value
448        0/1     ==>          op_numerator_d  = div_sign_a ? alu_adder_i : op_a_i;
449        0/1     ==>          md_state_d      = MD_ABS_B;
450        0/1     ==>          div_counter_d   = 5'd31;
451                             // ABS(A) = 0 - A
452        0/1     ==>          alu_operand_a_o = {32'h0  , 1'b1};
453        0/1     ==>          alu_operand_b_o = {~op_a_i, 1'b1};
454                           end
455                     
456                           MD_ABS_B: begin
457                             // remainder
458        0/1     ==>          op_remainder_d   = { 33'h0, op_numerator_q[31]};
459                             // B abs value
460        0/1     ==>          op_denominator_d = div_sign_b ? alu_adder_i : op_b_i;
461        0/1     ==>          md_state_d       = MD_COMP;
462        0/1     ==>          div_counter_d    = 5'd31;
463                             // ABS(B) = 0 - B
464        0/1     ==>          alu_operand_a_o  = {32'h0  , 1'b1};
465        0/1     ==>          alu_operand_b_o  = {~op_b_i, 1'b1};
466                           end
467                     
468                           MD_COMP: begin
469        0/1     ==>          op_remainder_d  = {1'b0, next_remainder[31:0], op_numerator_q[div_counter_d]};
470        0/1     ==>          op_quotient_d   = next_quotient[31:0];
471        0/1     ==>          md_state_d      = (div_counter_q == 5'd1) ? MD_LAST : MD_COMP;
472                             // Division
473        0/1     ==>          alu_operand_a_o = {imd_val_q_i[0][31:0], 1'b1}; // it contains the remainder
474        0/1     ==>          alu_operand_b_o = {~op_denominator_q[31:0], 1'b1};  // -denominator two's compliment
475                           end
476                     
477                           MD_LAST: begin
478        0/1     ==>          if (operator_i == MD_OP_DIV) begin
479                               // this time we save the quotient in op_remainder_d (i.e. imd_val_q_i[0]) since
480                               // we do not need anymore the remainder
481        0/1     ==>            op_remainder_d = {1'b0, next_quotient};
482                             end else begin
483                               // this time we do not save the quotient anymore since we need only the remainder
484        0/1     ==>            op_remainder_d = {2'b0, next_remainder[31:0]};
485                             end
486                             // Division
487        0/1     ==>          alu_operand_a_o  = {imd_val_q_i[0][31:0], 1'b1}; // it contains the remainder
488        0/1     ==>          alu_operand_b_o  = {~op_denominator_q[31:0], 1'b1};  // -denominator two's compliment
489                     
490        0/1     ==>          md_state_d = MD_CHANGE_SIGN;
491                           end
492                     
493                           MD_CHANGE_SIGN: begin
494        0/1     ==>          md_state_d  = MD_FINISH;
495        0/1     ==>          if (operator_i == MD_OP_DIV) begin
496        0/1     ==>            op_remainder_d = (div_change_sign) ? {2'h0, alu_adder_i} : imd_val_q_i[0];
497                             end else begin
498        0/1     ==>            op_remainder_d = (rem_change_sign) ? {2'h0, alu_adder_i} : imd_val_q_i[0];
499                             end
500                             // ABS(Quotient) = 0 - Quotient (or Remainder)
501        0/1     ==>          alu_operand_a_o  = {32'h0  , 1'b1};
502        0/1     ==>          alu_operand_b_o  = {~imd_val_q_i[0][31:0], 1'b1};
503                           end
504                     
505                           MD_FINISH: begin
506                             // Hold result until ID stage is ready to accept it
507                             // Note no state transition will occur if div_hold is set
508        0/1     ==>          md_state_d = MD_IDLE;
509        0/1     ==>          div_hold   = ~multdiv_ready_id_i;
510        0/1     ==>          div_valid   = 1'b1;
511                           end
512                     
513                           default: begin
514        1/1                  md_state_d = MD_IDLE;

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_multdiv_fast

               Total   Covered  Percent
Conditions         28        2     7.14
Logical            28        2     7.14
Non-Logical         0        0
Event               0        0

 LINE       426
 EXPRESSION ((((!data_ind_timing_i)) && equal_to_zero_i) ? MD_FINISH : MD_ABS_A)
             ---------------------1---------------------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       426
 SUB-EXPRESSION (((!data_ind_timing_i)) && equal_to_zero_i)
                 -----------1----------    -------2-------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       436
 EXPRESSION ((((!data_ind_timing_i)) && equal_to_zero_i) ? MD_FINISH : MD_ABS_A)
             ---------------------1---------------------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       436
 SUB-EXPRESSION (((!data_ind_timing_i)) && equal_to_zero_i)
                 -----------1----------    -------2-------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       448
 EXPRESSION (div_sign_a ? alu_adder_i : op_a_i)
             -----1----

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       460
 EXPRESSION (div_sign_b ? alu_adder_i : op_b_i)
             -----1----

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       471
 EXPRESSION ((div_counter_q == 5'b1) ? MD_LAST : MD_COMP)
             -----------1-----------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       496
 EXPRESSION (div_change_sign ? ({2'b0, alu_adder_i}) : imd_val_q_i[0])
             -------1-------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       498
 EXPRESSION (rem_change_sign ? ({2'b0, alu_adder_i}) : imd_val_q_i[0])
             -------1-------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       121
 EXPRESSION (div_sel_i ? op_remainder_d : mac_res_d)
             ----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       133
 EXPRESSION (div_sel_i ? imd_val_q_i[0][31:0] : mac_res_d[31:0])
             ----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       382
 EXPRESSION (is_greater_equal ? res_adder_h[31:0] : imd_val_q_i[0][31:0])
             --------1-------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       383
 EXPRESSION (is_greater_equal ? (({1'b0, op_quotient_q} | {1'b0, one_shift})) : ({1'b0, op_quotient_q}))
             --------1-------

-1- Status
 0  Not Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_multdiv_fast
                Total Covered Percent 
Totals          65    0       0.00    
Total Bits      1692  0       0.00    
Total Bits 0->1 846   0       0.00    
Total Bits 1->0 846   0       0.00    

                            
Ports          20  0 0.00   
Port Bits      488 0 0.00   
Port Bits 0->1 244 0 0.00   
Port Bits 1->0 244 0 0.00   

                               
Signals          45   0 0.00   
Signal Bits      1204 0 0.00   
Signal Bits 0->1 602  0 0.00   
Signal Bits 1->0 602  0 0.00   

Port Details
                       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                  No     No          No          INPUT     
rst_ni                 No     No          No          INPUT     
mult_en_i              No     No          No          INPUT     
div_en_i               No     No          No          INPUT     
mult_sel_i             No     No          No          INPUT     
div_sel_i              No     No          No          INPUT     
operator_i[1:0]        No     No          No          INPUT     
signed_mode_i[1:0]     No     No          No          INPUT     
op_a_i[31:0]           No     No          No          INPUT     
op_b_i[31:0]           No     No          No          INPUT     
alu_adder_ext_i[33:0]  No     No          No          INPUT     
alu_adder_i[31:0]      No     No          No          INPUT     
equal_to_zero_i        No     No          No          INPUT     
data_ind_timing_i      No     No          No          INPUT     
alu_operand_a_o[32:0]  No     No          No          OUTPUT    
alu_operand_b_o[32:0]  No     No          No          OUTPUT    
imd_val_we_o[1:0]      No     No          No          OUTPUT    
multdiv_ready_id_i     No     No          No          INPUT     
multdiv_result_o[31:0] No     No          No          OUTPUT    
valid_o                No     No          No          OUTPUT    

Signal Details
                                Toggle Toggle 1->0 Toggle 0->1 
mac_res_signed[34:0]            No     No          No          
mac_res_ext[34:0]               No     No          No          
accum[33:0]                     No     No          No          
sign_a                          No     No          No          
sign_b                          No     No          No          
mult_valid                      No     No          No          
signed_mult                     No     No          No          
mac_res_d[33:0]                 No     No          No          
op_remainder_d[33:0]            No     No          No          
mac_res[33:0]                   No     No          No          
div_sign_a                      No     No          No          
div_sign_b                      No     No          No          
is_greater_equal                No     No          No          
div_change_sign                 No     No          No          
rem_change_sign                 No     No          No          
one_shift[31:0]                 No     No          No          
op_denominator_q[31:0]          No     No          No          
op_numerator_q[31:0]            No     No          No          
op_quotient_q[31:0]             No     No          No          
op_denominator_d[31:0]          No     No          No          
op_numerator_d[31:0]            No     No          No          
op_quotient_d[31:0]             No     No          No          
next_remainder[31:0]            No     No          No          
next_quotient[32:0]             No     No          No          
res_adder_h[31:0]               No     No          No          
div_valid                       No     No          No          
div_counter_q[4:0]              No     No          No          
div_counter_d[4:0]              No     No          No          
multdiv_en                      No     No          No          
mult_hold                       No     No          No          
div_hold                        No     No          No          
div_by_zero_d                   No     No          No          
div_by_zero_q                   No     No          No          
mult_en_internal                No     No          No          
div_en_internal                 No     No          No          
md_state_q[2:0]                 No     No          No          
md_state_d[2:0]                 No     No          No          
unused_mult_sel_i               No     No          No          
unused_imd_val[1:0]             No     No          No          
unused_mac_res_ext              No     No          No          
unused_alu_adder_ext[1:0]       No     No          No          
gen_mult_fast.mult_op_a[15:0]   No     No          No          
gen_mult_fast.mult_op_b[15:0]   No     No          No          
gen_mult_fast.mult_state_q[1:0] No     No          No          
gen_mult_fast.mult_state_d[1:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_multdiv_fast
         Line No. Total Covered Percent 
Branches          41    9       21.95   
TERNARY  121      2     1       50.00   
TERNARY  133      2     1       50.00   
TERNARY  382      2     0       0.00    
TERNARY  383      2     0       0.00    
IF       99       3     1       33.33   
IF       392      2     2       100.00  
CASE     418      18    1       5.56    
CASE     288      7     2       28.57   
IF       363      3     1       33.33   


121          assign imd_val_d_o[0] = div_sel_i ? op_remainder_d : mac_res_d;
                                               -1-  
                                               ==>  
                                               ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


133          assign multdiv_result_o = div_sel_i ? imd_val_q_i[0][31:0] : mac_res_d[31:0];
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


382          assign next_remainder = is_greater_equal ? res_adder_h[31:0] : imd_val_q_i[0][31:0];
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status      
1   Not Covered 
0   Not Covered 


383          assign next_quotient  = is_greater_equal ? {1'b0, op_quotient_q} | {1'b0, one_shift} :
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status      
1   Not Covered 
0   Not Covered 


99             if (!rst_ni) begin
               -1-  
100              div_counter_q    <= '0;
                 ==>
101              md_state_q       <= MD_IDLE;
102              op_numerator_q   <= '0;
103              op_quotient_q    <= '0;
104              div_by_zero_q    <= '0;
105            end else if (div_en_internal) begin
                        -2-  
106              div_counter_q    <= div_counter_d;
                 ==>
107              op_numerator_q   <= op_numerator_d;
108              op_quotient_q    <= op_quotient_d;
109              md_state_q       <= md_state_d;
110              div_by_zero_q    <= div_by_zero_d;
111            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


392            if ((imd_val_q_i[0][31] ^ op_denominator_q[31]) == 1'b0) begin
               -1-  
393              is_greater_equal = (res_adder_h[31] == 1'b0);
                 ==>
394            end else begin
395              is_greater_equal = imd_val_q_i[0][31];
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


418            unique case(md_state_q)
                      -1-  
419              MD_IDLE: begin
420                if (operator_i == MD_OP_DIV) begin
                   -2-  
421                  // Check if the Denominator is 0
422                  // quotient for division by 0 is specified to be -1
423                  // Note with data-independent time option, the full divide operation will proceed as
424                  // normal and will naturally return -1
425                  op_remainder_d = '1;
426                  md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? MD_FINISH : MD_ABS_A;
                                                                              -3-  
                                                                              ==>  
                                                                              ==>  
427                  // Record that this is a div by zero to stop the sign change at the end of the
428                  // division (in data_ind_timing mode).
429                  div_by_zero_d  = equal_to_zero_i;
430                end else begin
431                  // Check if the Denominator is 0
432                  // remainder for division by 0 is specified to be the numerator (operand a)
433                  // Note with data-independent time option, the full divide operation will proceed as
434                  // normal and will naturally return operand a
435                  op_remainder_d = {2'b0, op_a_i};
436                  md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? MD_FINISH : MD_ABS_A;
                                                                              -4-  
                                                                              ==>  
                                                                              ==>  
437                end
438                // 0 - B = 0 iff B == 0
439                alu_operand_a_o  = {32'h0  , 1'b1};
440                alu_operand_b_o  = {~op_b_i, 1'b1};
441                div_counter_d    = 5'd31;
442              end
443        
444              MD_ABS_A: begin
445                // quotient
446                op_quotient_d   = '0;
447                // A abs value
448                op_numerator_d  = div_sign_a ? alu_adder_i : op_a_i;
                                                -5-  
                                                ==>  
                                                ==>  
449                md_state_d      = MD_ABS_B;
450                div_counter_d   = 5'd31;
451                // ABS(A) = 0 - A
452                alu_operand_a_o = {32'h0  , 1'b1};
453                alu_operand_b_o = {~op_a_i, 1'b1};
454              end
455        
456              MD_ABS_B: begin
457                // remainder
458                op_remainder_d   = { 33'h0, op_numerator_q[31]};
459                // B abs value
460                op_denominator_d = div_sign_b ? alu_adder_i : op_b_i;
                                                 -6-  
                                                 ==>  
                                                 ==>  
461                md_state_d       = MD_COMP;
462                div_counter_d    = 5'd31;
463                // ABS(B) = 0 - B
464                alu_operand_a_o  = {32'h0  , 1'b1};
465                alu_operand_b_o  = {~op_b_i, 1'b1};
466              end
467        
468              MD_COMP: begin
469                op_remainder_d  = {1'b0, next_remainder[31:0], op_numerator_q[div_counter_d]};
470                op_quotient_d   = next_quotient[31:0];
471                md_state_d      = (div_counter_q == 5'd1) ? MD_LAST : MD_COMP;
                                                             -7-  
                                                             ==>  
                                                             ==>  
472                // Division
473                alu_operand_a_o = {imd_val_q_i[0][31:0], 1'b1}; // it contains the remainder
474                alu_operand_b_o = {~op_denominator_q[31:0], 1'b1};  // -denominator two's compliment
475              end
476        
477              MD_LAST: begin
478                if (operator_i == MD_OP_DIV) begin
                   -8-  
479                  // this time we save the quotient in op_remainder_d (i.e. imd_val_q_i[0]) since
480                  // we do not need anymore the remainder
481                  op_remainder_d = {1'b0, next_quotient};
                     ==>
482                end else begin
483                  // this time we do not save the quotient anymore since we need only the remainder
484                  op_remainder_d = {2'b0, next_remainder[31:0]};
                     ==>
485                end
486                // Division
487                alu_operand_a_o  = {imd_val_q_i[0][31:0], 1'b1}; // it contains the remainder
488                alu_operand_b_o  = {~op_denominator_q[31:0], 1'b1};  // -denominator two's compliment
489        
490                md_state_d = MD_CHANGE_SIGN;
491              end
492        
493              MD_CHANGE_SIGN: begin
494                md_state_d  = MD_FINISH;
495                if (operator_i == MD_OP_DIV) begin
                   -9-  
496                  op_remainder_d = (div_change_sign) ? {2'h0, alu_adder_i} : imd_val_q_i[0];
                                                        -10-  
                                                        ==>  
                                                        ==>  
497                end else begin
498                  op_remainder_d = (rem_change_sign) ? {2'h0, alu_adder_i} : imd_val_q_i[0];
                                                        -11-  
                                                        ==>  
                                                        ==>  
499                end
500                // ABS(Quotient) = 0 - Quotient (or Remainder)
501                alu_operand_a_o  = {32'h0  , 1'b1};
502                alu_operand_b_o  = {~imd_val_q_i[0][31:0], 1'b1};
503              end
504        
505              MD_FINISH: begin
506                // Hold result until ID stage is ready to accept it
507                // Note no state transition will occur if div_hold is set
508                md_state_d = MD_IDLE;
                   ==>
509                div_hold   = ~multdiv_ready_id_i;
510                div_valid   = 1'b1;
511              end
512        
513              default: begin
514                md_state_d = MD_IDLE;
                   ==>

Branches:

-1-             -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- Status      
MD_IDLE         1   1   -   -   -   -   -   -   -    -    Not Covered 
MD_IDLE         1   0   -   -   -   -   -   -   -    -    Not Covered 
MD_IDLE         0   -   1   -   -   -   -   -   -    -    Not Covered 
MD_IDLE         0   -   0   -   -   -   -   -   -    -    Not Covered 
MD_ABS_A        -   -   -   1   -   -   -   -   -    -    Not Covered 
MD_ABS_A        -   -   -   0   -   -   -   -   -    -    Not Covered 
MD_ABS_B        -   -   -   -   1   -   -   -   -    -    Not Covered 
MD_ABS_B        -   -   -   -   0   -   -   -   -    -    Not Covered 
MD_COMP         -   -   -   -   -   1   -   -   -    -    Not Covered 
MD_COMP         -   -   -   -   -   0   -   -   -    -    Not Covered 
MD_LAST         -   -   -   -   -   -   1   -   -    -    Not Covered 
MD_LAST         -   -   -   -   -   -   0   -   -    -    Not Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   1   1    -    Not Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   1   0    -    Not Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   0   -    1    Not Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   0   -    0    Not Covered 
MD_FINISH       -   -   -   -   -   -   -   -   -    -    Not Covered 
default         -   -   -   -   -   -   -   -   -    -    Covered     


288              unique case (mult_state_q)
                        -1-  
289        
290                ALBL: begin
291                  // al*bl
292                  mult_op_a = op_a_i[`OP_L];
                     ==>
293                  mult_op_b = op_b_i[`OP_L];
294                  sign_a    = 1'b0;
295                  sign_b    = 1'b0;
296                  accum     = '0;
297                  mac_res_d = mac_res;
298                  mult_state_d = ALBH;
299                end
300        
301                ALBH: begin
302                  // al*bh<<16
303                  mult_op_a = op_a_i[`OP_L];
304                  mult_op_b = op_b_i[`OP_H];
305                  sign_a    = 1'b0;
306                  sign_b    = signed_mode_i[1] & op_b_i[31];
307                  // result of AL*BL (in imd_val_q_i[0]) always unsigned with no carry
308                  accum     = {18'b0, imd_val_q_i[0][31:16]};
309                  if (operator_i == MD_OP_MULL) begin
                     -2-  
310                    mac_res_d = {2'b0, mac_res[`OP_L], imd_val_q_i[0][`OP_L]};
                       ==>
311                  end else begin
312                    // MD_OP_MULH
313                    mac_res_d = mac_res;
                       ==>
314                  end
315                  mult_state_d = AHBL;
316                end
317        
318                AHBL: begin
319                  // ah*bl<<16
320                  mult_op_a = op_a_i[`OP_H];
321                  mult_op_b = op_b_i[`OP_L];
322                  sign_a    = signed_mode_i[0] & op_a_i[31];
323                  sign_b    = 1'b0;
324                  if (operator_i == MD_OP_MULL) begin
                     -3-  
325                    accum        = {18'b0, imd_val_q_i[0][31:16]};
                       ==>
326                    mac_res_d    = {2'b0, mac_res[15:0], imd_val_q_i[0][15:0]};
327                    mult_valid   = 1'b1;
328        
329                    // Note no state transition will occur if mult_hold is set
330                    mult_state_d = ALBL;
331                    mult_hold    = ~multdiv_ready_id_i;
332                  end else begin
333                    accum        = imd_val_q_i[0];
                       ==>
334                    mac_res_d    = mac_res;
335                    mult_state_d = AHBH;
336                  end
337                end
338        
339                AHBH: begin
340                  // only MD_OP_MULH here
341                  // ah*bh
342                  mult_op_a = op_a_i[`OP_H];
                     ==>
343                  mult_op_b = op_b_i[`OP_H];
344                  sign_a    = signed_mode_i[0] & op_a_i[31];
345                  sign_b    = signed_mode_i[1] & op_b_i[31];
346                  accum[17: 0]  = imd_val_q_i[0][33:16];
347                  accum[33:18]  = {16{signed_mult & imd_val_q_i[0][33]}};
348                  // result of AH*BL is not signed only if signed_mode_i == 2'b00
349                  mac_res_d    = mac_res;
350                  mult_valid   = 1'b1;
351        
352                  // Note no state transition will occur if mult_hold is set
353                  mult_state_d = ALBL;
354                  mult_hold    = ~multdiv_ready_id_i;
355                end
356                default: begin
357                  mult_state_d = ALBL;
                     ==>

Branches:

-1-     -2- -3- Status      
ALBL    -   -   Covered     
ALBH    1   -   Not Covered 
ALBH    0   -   Not Covered 
AHBL    -   1   Not Covered 
AHBL    -   0   Not Covered 
AHBH    -   -   Not Covered 
default -   -   Covered     


363              if (!rst_ni) begin
                 -1-  
364                mult_state_q <= ALBL;
                   ==>
365              end else begin
366                if (mult_en_internal) begin
                   -2-  
367                  mult_state_q <= mult_state_d;
                     ==>
368                end
                   MISSING_ELSE
                   ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_multdiv_fast
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       5     5         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            5     5         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                             Attempts Real Successes Failures Incomplete 
DivEnKnown                       3        0              0        0          
IbexMultDivStateValid            3        0              0        0          
MultDivEnKnown                   3        0              0        0          
MultEnKnown                      3        0              0        0          
gen_mult_fast.IbexMultStateKnown 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.ex_block_i.gen_multdiv_fast.multdiv_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 13.62  39.02   7.14   0.00  21.95   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 13.62  39.02   7.14   0.00  21.95   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME              
 13.62  39.02   7.14   0.00  21.95   0.00 ibex_multdiv_fast 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 33.33 --      50.00   0.00  50.00 --     ex_block_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_id_stage
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 17.45  36.36  22.73   0.00  28.17   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_id_stage.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                         
 17.45  36.36  22.73   0.00  28.17   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.id_stage_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_id_stage

             Line No.   Total   Covered  Percent
TOTAL                       88       32    36.36
ALWAYS            305        6        2    33.33
ALWAYS            363        9        2    22.22
ALWAYS            393        4        2    50.00
ALWAYS            393        4        2    50.00
ALWAYS            412        4        3    75.00
ALWAYS            505        7        3    42.86
ALWAYS            669        3        2    66.67
ALWAYS            692        3        2    66.67
ALWAYS            747        4        2    50.00
ALWAYS            760       44       12    27.27

304                       always_comb begin : alu_operand_a_mux
305        1/1              unique case (alu_op_a_mux_sel)
306        0/1     ==>        OP_A_REG_A:  alu_operand_a = rf_rdata_a_fwd;
307        0/1     ==>        OP_A_FWD:    alu_operand_a = lsu_addr_last_i;
308        0/1     ==>        OP_A_CURRPC: alu_operand_a = pc_id_i;
309        1/1                OP_A_IMM:    alu_operand_a = imm_a;
310        0/1     ==>        default:     alu_operand_a = pc_id_i;
311                         endcase
312                       end
313                     
314                       if (BranchTargetALU) begin : g_btalu_muxes
315                         // Branch target ALU operand A mux
316                         always_comb begin : bt_operand_a_mux
317                           unique case (bt_a_mux_sel)
318                             OP_A_REG_A:  bt_a_operand_o = rf_rdata_a_fwd;
319                             OP_A_CURRPC: bt_a_operand_o = pc_id_i;
320                             default:     bt_a_operand_o = pc_id_i;
321                           endcase
322                         end
323                     
324                         // Branch target ALU operand B mux
325                         always_comb begin : bt_immediate_b_mux
326                           unique case (bt_b_mux_sel)
327                             IMM_B_I:         bt_b_operand_o = imm_i_type;
328                             IMM_B_B:         bt_b_operand_o = imm_b_type;
329                             IMM_B_J:         bt_b_operand_o = imm_j_type;
330                             IMM_B_INCR_PC:   bt_b_operand_o = instr_is_compressed_i ? 32'h2 : 32'h4;
331                             default:         bt_b_operand_o = instr_is_compressed_i ? 32'h2 : 32'h4;
332                           endcase
333                         end
334                     
335                         // Reduced main ALU immediate MUX for Operand B
336                         always_comb begin : immediate_b_mux
337                           unique case (imm_b_mux_sel)
338                             IMM_B_I:         imm_b = imm_i_type;
339                             IMM_B_S:         imm_b = imm_s_type;
340                             IMM_B_U:         imm_b = imm_u_type;
341                             IMM_B_INCR_PC:   imm_b = instr_is_compressed_i ? 32'h2 : 32'h4;
342                             IMM_B_INCR_ADDR: imm_b = 32'h4;
343                             default:         imm_b = 32'h4;
344                           endcase
345                         end
346                         `ASSERT(IbexImmBMuxSelValid, instr_valid_i |-> imm_b_mux_sel inside {
347                             IMM_B_I,
348                             IMM_B_S,
349                             IMM_B_U,
350                             IMM_B_INCR_PC,
351                             IMM_B_INCR_ADDR})
352                       end else begin : g_nobtalu
353                         op_a_sel_e  unused_a_mux_sel;
354                         imm_b_sel_e unused_b_mux_sel;
355                     
356                         assign unused_a_mux_sel = bt_a_mux_sel;
357                         assign unused_b_mux_sel = bt_b_mux_sel;
358                         assign bt_a_operand_o   = '0;
359                         assign bt_b_operand_o   = '0;
360                     
361                         // Full main ALU immediate MUX for Operand B
362                         always_comb begin : immediate_b_mux
363        1/1                unique case (imm_b_mux_sel)
364        1/1                  IMM_B_I:         imm_b = imm_i_type;
365        0/1     ==>          IMM_B_S:         imm_b = imm_s_type;
366        0/1     ==>          IMM_B_B:         imm_b = imm_b_type;
367        0/1     ==>          IMM_B_U:         imm_b = imm_u_type;
368        0/1     ==>          IMM_B_J:         imm_b = imm_j_type;
369        0/1     ==>          IMM_B_INCR_PC:   imm_b = instr_is_compressed_i ? 32'h2 : 32'h4;
370        0/1     ==>          IMM_B_INCR_ADDR: imm_b = 32'h4;
371        0/1     ==>          default:         imm_b = 32'h4;
372                           endcase
373                         end
374                         `ASSERT(IbexImmBMuxSelValid, instr_valid_i |-> imm_b_mux_sel inside {
375                             IMM_B_I,
376                             IMM_B_S,
377                             IMM_B_B,
378                             IMM_B_U,
379                             IMM_B_J,
380                             IMM_B_INCR_PC,
381                             IMM_B_INCR_ADDR})
382                       end
383                     
384                       // ALU MUX for Operand B
385                       assign alu_operand_b = (alu_op_b_mux_sel == OP_B_IMM) ? imm_b : rf_rdata_b_fwd;
386                     
387                       /////////////////////////////////////////
388                       // Multicycle Operation Stage Register //
389                       /////////////////////////////////////////
390                     
391                       for (genvar i=0; i<2; i++) begin : gen_intermediate_val_reg
392                         always_ff @(posedge clk_i or negedge rst_ni) begin : intermediate_val_reg
393        1/1                if (!rst_ni) begin
394        1/1                  imd_val_q[i] <= '0;
395        0/1     ==>        end else if (imd_val_we_ex_i[i]) begin
396        0/1     ==>          imd_val_q[i] <= imd_val_d_ex_i[i];
397                           end
                   ==>  MISSING_ELSE
***repeat 1
393        1/1                if (!rst_ni) begin
394        1/1                  imd_val_q[i] <= '0;
395        0/1     ==>        end else if (imd_val_we_ex_i[i]) begin
396        0/1     ==>          imd_val_q[i] <= imd_val_d_ex_i[i];
397                           end
                   ==>  MISSING_ELSE
398                         end
399                       end
400                     
401                       assign imd_val_q_ex_o = imd_val_q;
402                     
403                       ///////////////////////
404                       // Register File MUX //
405                       ///////////////////////
406                     
407                       // Suppress register write if there is an illegal CSR access or instruction is not executing
408                       assign rf_we_id_o = rf_we_raw & instr_executing & ~illegal_csr_insn_i;
409                     
410                       // Register file write data mux
411                       always_comb begin : rf_wdata_id_mux
412        1/1              unique case (rf_wdata_sel)
413        1/1                RF_WD_EX:  rf_wdata_id_o = result_ex_i;
414        0/1     ==>        RF_WD_CSR: rf_wdata_id_o = csr_rdata_i;
415        1/1                default:   rf_wdata_id_o = result_ex_i;
416                         endcase
417                       end
418                     
419                       /////////////
420                       // Decoder //
421                       /////////////
422                     
423                       ibex_decoder #(
424                           .RV32E           ( RV32E           ),
425                           .RV32M           ( RV32M           ),
426                           .RV32B           ( RV32B           ),
427                           .BranchTargetALU ( BranchTargetALU )
428                       ) decoder_i (
429                           .clk_i                           ( clk_i                ),
430                           .rst_ni                          ( rst_ni               ),
431                     
432                           // controller
433                           .illegal_insn_o                  ( illegal_insn_dec     ),
434                           .ebrk_insn_o                     ( ebrk_insn            ),
435                           .mret_insn_o                     ( mret_insn_dec        ),
436                           .dret_insn_o                     ( dret_insn_dec        ),
437                           .ecall_insn_o                    ( ecall_insn_dec       ),
438                           .wfi_insn_o                      ( wfi_insn_dec         ),
439                           .jump_set_o                      ( jump_set_dec         ),
440                           .branch_taken_i                  ( branch_taken         ),
441                           .icache_inval_o                  ( icache_inval_o       ),
442                     
443                           // from IF-ID pipeline register
444                           .instr_first_cycle_i             ( instr_first_cycle    ),
445                           .instr_rdata_i                   ( instr_rdata_i        ),
446                           .instr_rdata_alu_i               ( instr_rdata_alu_i    ),
447                           .illegal_c_insn_i                ( illegal_c_insn_i     ),
448                     
449                           // immediates
450                           .imm_a_mux_sel_o                 ( imm_a_mux_sel        ),
451                           .imm_b_mux_sel_o                 ( imm_b_mux_sel_dec    ),
452                           .bt_a_mux_sel_o                  ( bt_a_mux_sel         ),
453                           .bt_b_mux_sel_o                  ( bt_b_mux_sel         ),
454                     
455                           .imm_i_type_o                    ( imm_i_type           ),
456                           .imm_s_type_o                    ( imm_s_type           ),
457                           .imm_b_type_o                    ( imm_b_type           ),
458                           .imm_u_type_o                    ( imm_u_type           ),
459                           .imm_j_type_o                    ( imm_j_type           ),
460                           .zimm_rs1_type_o                 ( zimm_rs1_type        ),
461                     
462                           // register file
463                           .rf_wdata_sel_o                  ( rf_wdata_sel         ),
464                           .rf_we_o                         ( rf_we_dec            ),
465                     
466                           .rf_raddr_a_o                    ( rf_raddr_a_o         ),
467                           .rf_raddr_b_o                    ( rf_raddr_b_o         ),
468                           .rf_waddr_o                      ( rf_waddr_id_o        ),
469                           .rf_ren_a_o                      ( rf_ren_a_dec         ),
470                           .rf_ren_b_o                      ( rf_ren_b_dec         ),
471                     
472                           // ALU
473                           .alu_operator_o                  ( alu_operator         ),
474                           .alu_op_a_mux_sel_o              ( alu_op_a_mux_sel_dec ),
475                           .alu_op_b_mux_sel_o              ( alu_op_b_mux_sel_dec ),
476                           .alu_multicycle_o                ( alu_multicycle_dec   ),
477                     
478                           // MULT & DIV
479                           .mult_en_o                       ( mult_en_dec          ),
480                           .div_en_o                        ( div_en_dec           ),
481                           .mult_sel_o                      ( mult_sel_ex_o        ),
482                           .div_sel_o                       ( div_sel_ex_o         ),
483                           .multdiv_operator_o              ( multdiv_operator     ),
484                           .multdiv_signed_mode_o           ( multdiv_signed_mode  ),
485                     
486                           // CSRs
487                           .csr_access_o                    ( csr_access_o         ),
488                           .csr_op_o                        ( csr_op_o             ),
489                     
490                           // LSU
491                           .data_req_o                      ( lsu_req_dec          ),
492                           .data_we_o                       ( lsu_we               ),
493                           .data_type_o                     ( lsu_type             ),
494                           .data_sign_extension_o           ( lsu_sign_ext         ),
495                     
496                           // jump/branches
497                           .jump_in_dec_o                   ( jump_in_dec          ),
498                           .branch_in_dec_o                 ( branch_in_dec        )
499                       );
500                     
501                       /////////////////////////////////
502                       // CSR-related pipline flushes //
503                       /////////////////////////////////
504                       always_comb begin : csr_pipeline_flushes
505        1/1              csr_pipe_flush = 1'b0;
506                     
507                         // A pipeline flush is needed to let the controller react after modifying certain CSRs:
508                         // - When enabling interrupts, pending IRQs become visible to the controller only during
509                         //   the next cycle. If during that cycle the core disables interrupts again, it does not
510                         //   see any pending IRQs and consequently does not start to handle interrupts.
511                         // - When modifying debug CSRs - TODO: Check if this is really needed
512        1/1              if (csr_op_en_o == 1'b1 && (csr_op_o == CSR_OP_WRITE || csr_op_o == CSR_OP_SET)) begin
513        0/1     ==>        if (csr_num_e'(instr_rdata_i[31:20]) == CSR_MSTATUS   ||
514                               csr_num_e'(instr_rdata_i[31:20]) == CSR_MIE) begin
515        0/1     ==>          csr_pipe_flush = 1'b1;
516                           end
                   ==>  MISSING_ELSE
517        1/1              end else if (csr_op_en_o == 1'b1 && csr_op_o != CSR_OP_READ) begin
518        0/1     ==>        if (csr_num_e'(instr_rdata_i[31:20]) == CSR_DCSR      ||
519                               csr_num_e'(instr_rdata_i[31:20]) == CSR_DPC       ||
520                               csr_num_e'(instr_rdata_i[31:20]) == CSR_DSCRATCH0 ||
521                               csr_num_e'(instr_rdata_i[31:20]) == CSR_DSCRATCH1) begin
522        0/1     ==>          csr_pipe_flush = 1'b1;
523                           end
                   ==>  MISSING_ELSE
524                         end
                        MISSING_ELSE
525                       end
526                     
527                       ////////////////
528                       // Controller //
529                       ////////////////
530                     
531                       assign illegal_insn_o = instr_valid_i & (illegal_insn_dec | illegal_csr_insn_i);
532                     
533                       ibex_controller #(
534                         .WritebackStage  ( WritebackStage  ),
535                         .BranchPredictor ( BranchPredictor )
536                       ) controller_i (
537                           .clk_i                          ( clk_i                   ),
538                           .rst_ni                         ( rst_ni                  ),
539                     
540                           .ctrl_busy_o                    ( ctrl_busy_o             ),
541                     
542                           // decoder related signals
543                           .illegal_insn_i                 ( illegal_insn_o          ),
544                           .ecall_insn_i                   ( ecall_insn_dec          ),
545                           .mret_insn_i                    ( mret_insn_dec           ),
546                           .dret_insn_i                    ( dret_insn_dec           ),
547                           .wfi_insn_i                     ( wfi_insn_dec            ),
548                           .ebrk_insn_i                    ( ebrk_insn               ),
549                           .csr_pipe_flush_i               ( csr_pipe_flush          ),
550                     
551                           // from IF-ID pipeline
552                           .instr_valid_i                  ( instr_valid_i           ),
553                           .instr_i                        ( instr_rdata_i           ),
554                           .instr_compressed_i             ( instr_rdata_c_i         ),
555                           .instr_is_compressed_i          ( instr_is_compressed_i   ),
556                           .instr_bp_taken_i               ( instr_bp_taken_i        ),
557                           .instr_fetch_err_i              ( instr_fetch_err_i       ),
558                           .instr_fetch_err_plus2_i        ( instr_fetch_err_plus2_i ),
559                           .pc_id_i                        ( pc_id_i                 ),
560                     
561                           // to IF-ID pipeline
562                           .instr_valid_clear_o            ( instr_valid_clear_o     ),
563                           .id_in_ready_o                  ( id_in_ready_o           ),
564                           .controller_run_o               ( controller_run          ),
565                     
566                           // to prefetcher
567                           .instr_req_o                    ( instr_req_o             ),
568                           .pc_set_o                       ( pc_set_o                ),
569                           .pc_set_spec_o                  ( pc_set_spec_o           ),
570                           .pc_mux_o                       ( pc_mux_o                ),
571                           .nt_branch_mispredict_o         ( nt_branch_mispredict_o  ),
572                           .exc_pc_mux_o                   ( exc_pc_mux_o            ),
573                           .exc_cause_o                    ( exc_cause_o             ),
574                     
575                           // LSU
576                           .lsu_addr_last_i                ( lsu_addr_last_i         ),
577                           .load_err_i                     ( lsu_load_err_i          ),
578                           .store_err_i                    ( lsu_store_err_i         ),
579                           .wb_exception_o                 ( wb_exception            ),
580                     
581                           // jump/branch control
582                           .branch_set_i                   ( branch_set              ),
583                           .branch_set_spec_i              ( branch_set_spec         ),
584                           .branch_not_set_i               ( branch_not_set          ),
585                           .jump_set_i                     ( jump_set                ),
586                     
587                           // interrupt signals
588                           .csr_mstatus_mie_i              ( csr_mstatus_mie_i       ),
589                           .irq_pending_i                  ( irq_pending_i           ),
590                           .irqs_i                         ( irqs_i                  ),
591                           .irq_nm_i                       ( irq_nm_i                ),
592                           .nmi_mode_o                     ( nmi_mode_o              ),
593                     
594                           // CSR Controller Signals
595                           .csr_save_if_o                  ( csr_save_if_o           ),
596                           .csr_save_id_o                  ( csr_save_id_o           ),
597                           .csr_save_wb_o                  ( csr_save_wb_o           ),
598                           .csr_restore_mret_id_o          ( csr_restore_mret_id_o   ),
599                           .csr_restore_dret_id_o          ( csr_restore_dret_id_o   ),
600                           .csr_save_cause_o               ( csr_save_cause_o        ),
601                           .csr_mtval_o                    ( csr_mtval_o             ),
602                           .priv_mode_i                    ( priv_mode_i             ),
603                           .csr_mstatus_tw_i               ( csr_mstatus_tw_i        ),
604                     
605                           // Debug Signal
606                           .debug_mode_o                   ( debug_mode_o            ),
607                           .debug_cause_o                  ( debug_cause_o           ),
608                           .debug_csr_save_o               ( debug_csr_save_o        ),
609                           .debug_req_i                    ( debug_req_i             ),
610                           .debug_single_step_i            ( debug_single_step_i     ),
611                           .debug_ebreakm_i                ( debug_ebreakm_i         ),
612                           .debug_ebreaku_i                ( debug_ebreaku_i         ),
613                           .trigger_match_i                ( trigger_match_i         ),
614                     
615                           .stall_id_i                     ( stall_id                ),
616                           .stall_wb_i                     ( stall_wb                ),
617                           .flush_id_o                     ( flush_id                ),
618                           .ready_wb_i                     ( ready_wb_i              ),
619                     
620                           // Performance Counters
621                           .perf_jump_o                    ( perf_jump_o             ),
622                           .perf_tbranch_o                 ( perf_tbranch_o          )
623                       );
624                     
625                       assign multdiv_en_dec   = mult_en_dec | div_en_dec;
626                     
627                       assign lsu_req         = instr_executing ? data_req_allowed & lsu_req_dec  : 1'b0;
628                       assign mult_en_id      = instr_executing ? mult_en_dec                     : 1'b0;
629                       assign div_en_id       = instr_executing ? div_en_dec                      : 1'b0;
630                     
631                       assign lsu_req_o               = lsu_req;
632                       assign lsu_we_o                = lsu_we;
633                       assign lsu_type_o              = lsu_type;
634                       assign lsu_sign_ext_o          = lsu_sign_ext;
635                       assign lsu_wdata_o             = rf_rdata_b_fwd;
636                       // csr_op_en_o is set when CSR access should actually happen.
637                       // csv_access_o is set when CSR access instruction is present and is used to compute whether a CSR
638                       // access is illegal. A combinational loop would be created if csr_op_en_o was used along (as
639                       // asserting it for an illegal csr access would result in a flush that would need to deassert it).
640                       assign csr_op_en_o             = csr_access_o & instr_executing & instr_id_done_o;
641                     
642                       assign alu_operator_ex_o           = alu_operator;
643                       assign alu_operand_a_ex_o          = alu_operand_a;
644                       assign alu_operand_b_ex_o          = alu_operand_b;
645                     
646                       assign mult_en_ex_o                = mult_en_id;
647                       assign div_en_ex_o                 = div_en_id;
648                     
649                       assign multdiv_operator_ex_o       = multdiv_operator;
650                       assign multdiv_signed_mode_ex_o    = multdiv_signed_mode;
651                       assign multdiv_operand_a_ex_o      = rf_rdata_a_fwd;
652                       assign multdiv_operand_b_ex_o      = rf_rdata_b_fwd;
653                     
654                       ////////////////////////
655                       // Branch set control //
656                       ////////////////////////
657                     
658                       if (BranchTargetALU && !DataIndTiming) begin : g_branch_set_direct
659                         // Branch set fed straight to controller with branch target ALU
660                         // (condition pass/fail used same cycle as generated instruction request)
661                         assign branch_set_raw      = branch_set_raw_d;
662                         assign branch_set_raw_spec = branch_spec;
663                       end else begin : g_branch_set_flop
664                         // Branch set flopped without branch target ALU, or in fixed time execution mode
665                         // (condition pass/fail used next cycle where branch target is calculated)
666                         logic branch_set_raw_q;
667                     
668                         always_ff @(posedge clk_i or negedge rst_ni) begin
669        1/1                if (!rst_ni) begin
670        1/1                  branch_set_raw_q <= 1'b0;
671                           end else begin
672        0/1     ==>          branch_set_raw_q <= branch_set_raw_d;
673                           end
674                         end
675                     
676                         // Branches always take two cycles in fixed time execution mode, with or without the branch
677                         // target ALU (to avoid a path from the branch decision into the branch target ALU operand
678                         // muxing).
679                         assign branch_set_raw      = (BranchTargetALU && !data_ind_timing_i) ? branch_set_raw_d :
680                                                                                                branch_set_raw_q;
681                     
682                         // Use the speculative branch signal when BTALU is enabled
683                         assign branch_set_raw_spec = (BranchTargetALU && !data_ind_timing_i) ? branch_spec :
684                                                                                                branch_set_raw_q;
685                       end
686                     
687                       // Track whether the current instruction in ID/EX has done a branch or jump set.
688                       assign branch_jump_set_done_d = (branch_set_raw | jump_set_raw | branch_jump_set_done_q) &
689                         ~instr_valid_clear_o;
690                     
691                       always_ff @(posedge clk_i or negedge rst_ni) begin
692        1/1              if (!rst_ni) begin
693        1/1                branch_jump_set_done_q <= 1'b0;
694                         end else begin
695        0/1     ==>        branch_jump_set_done_q <= branch_jump_set_done_d;
696                         end
697                       end
698                     
699                       // the _raw signals from the state machine may be asserted for multiple cycles when
700                       // instr_executing_spec is asserted and instr_executing is not asserted. This may occur where
701                       // a memory error is seen or a there are outstanding memory accesses (indicate a load or store is
702                       // in the WB stage). The branch or jump speculatively begins the fetch but is held back from
703                       // completing until it is certain the outstanding access hasn't seen a memory error. This logic
704                       // ensures only the first cycle of a branch or jump set is sent to the controller to prevent
705                       // needless extra IF flushes and fetches.
706                       assign jump_set        = jump_set_raw        & ~branch_jump_set_done_q;
707                       assign branch_set      = branch_set_raw      & ~branch_jump_set_done_q;
708                       assign branch_set_spec = branch_set_raw_spec & ~branch_jump_set_done_q;
709                     
710                       // Branch condition is calculated in the first cycle and flopped for use in the second cycle
711                       // (only used in fixed time execution mode to determine branch destination).
712                       if (DataIndTiming) begin : g_sec_branch_taken
713                         logic branch_taken_q;
714                     
715                         always_ff @(posedge clk_i or negedge rst_ni) begin
716                           if (!rst_ni) begin
717                             branch_taken_q <= 1'b0;
718                           end else begin
719                             branch_taken_q <= branch_decision_i;
720                           end
721                         end
722                     
723                         assign branch_taken = ~data_ind_timing_i | branch_taken_q;
724                     
725                       end else begin : g_nosec_branch_taken
726                     
727                         // Signal unused without fixed time execution mode - only taken branches will trigger
728                         // branch_set_raw
729                         assign branch_taken = 1'b1;
730                     
731                       end
732                     
733                       // Holding branch_set/jump_set high for more than one cycle should not cause a functional issue.
734                       // However it could generate needless prefetch buffer flushes and instruction fetches. The ID/EX
735                       // designs ensures that this never happens for non-predicted branches.
736                       `ASSERT(NeverDoubleBranch, branch_set & ~instr_bp_taken_i |=> ~branch_set)
737                       `ASSERT(NeverDoubleJump, jump_set & ~instr_bp_taken_i |=> ~jump_set)
738                     
739                       ///////////////
740                       // ID-EX FSM //
741                       ///////////////
742                     
743                       typedef enum logic { FIRST_CYCLE, MULTI_CYCLE } id_fsm_e;
744                       id_fsm_e id_fsm_q, id_fsm_d;
745                     
746                       always_ff @(posedge clk_i or negedge rst_ni) begin : id_pipeline_reg
747        1/1              if (!rst_ni) begin
748        1/1                id_fsm_q <= FIRST_CYCLE;
749        0/1     ==>      end else if (instr_executing) begin
750        0/1     ==>        id_fsm_q <= id_fsm_d;
751                         end
                   ==>  MISSING_ELSE
752                       end
753                     
754                       // ID/EX stage can be in two states, FIRST_CYCLE and MULTI_CYCLE. An instruction enters
755                       // MULTI_CYCLE if it requires multiple cycles to complete regardless of stalls and other
756                       // considerations. An instruction may be held in FIRST_CYCLE if it's unable to begin executing
757                       // (this is controlled by instr_executing).
758                     
759                       always_comb begin
760        1/1              id_fsm_d                = id_fsm_q;
761        1/1              rf_we_raw               = rf_we_dec;
762        1/1              stall_multdiv           = 1'b0;
763        1/1              stall_jump              = 1'b0;
764        1/1              stall_branch            = 1'b0;
765        1/1              stall_alu               = 1'b0;
766        1/1              branch_set_raw_d        = 1'b0;
767        1/1              branch_spec             = 1'b0;
768        1/1              branch_not_set          = 1'b0;
769        1/1              jump_set_raw            = 1'b0;
770        1/1              perf_branch_o           = 1'b0;
771                     
772        1/1              if (instr_executing_spec) begin
773        0/1     ==>        unique case (id_fsm_q)
774                             FIRST_CYCLE: begin
775        0/1     ==>            unique case (1'b1)
776                                 lsu_req_dec: begin
777        0/1     ==>                if (!WritebackStage) begin
778                                     // LSU operation
779        0/1     ==>                  id_fsm_d    = MULTI_CYCLE;
780                                   end else begin
781        0/1     ==>                  if(~lsu_req_done_i) begin
782        0/1     ==>                    id_fsm_d  = MULTI_CYCLE;
783                                     end
                   ==>  MISSING_ELSE
784                                   end
785                                 end
786                                 multdiv_en_dec: begin
787                                   // MUL or DIV operation
788        0/1     ==>                if (~ex_valid_i) begin
789                                     // When single-cycle multiply is configured mul can finish in the first cycle so
790                                     // only enter MULTI_CYCLE state if a result isn't immediately available
791        0/1     ==>                  id_fsm_d      = MULTI_CYCLE;
792        0/1     ==>                  rf_we_raw     = 1'b0;
793        0/1     ==>                  stall_multdiv = 1'b1;
794                                   end
                   ==>  MISSING_ELSE
795                                 end
796                                 branch_in_dec: begin
797                                   // cond branch operation
798                                   // All branches take two cycles in fixed time execution mode, regardless of branch
799                                   // condition.
800        0/1     ==>                id_fsm_d         = (data_ind_timing_i || (!BranchTargetALU && branch_decision_i)) ?
801                                                          MULTI_CYCLE : FIRST_CYCLE;
802        0/1     ==>                stall_branch     = (~BranchTargetALU & branch_decision_i) | data_ind_timing_i;
803        0/1     ==>                branch_set_raw_d = (branch_decision_i | data_ind_timing_i);
804                     
805        0/1     ==>                if (BranchPredictor) begin
806        0/1     ==>                  branch_not_set = ~branch_decision_i;
807                                   end
                   ==>  MISSING_ELSE
808                     
809                                   // Speculative branch (excludes branch_decision_i)
810        0/1     ==>                branch_spec   = SpecBranch ? 1'b1 : branch_decision_i;
811        0/1     ==>                perf_branch_o = 1'b1;
812                                 end
813                                 jump_in_dec: begin
814                                   // uncond branch operation
815                                   // BTALU means jumps only need one cycle
816        0/1     ==>                id_fsm_d      = BranchTargetALU ? FIRST_CYCLE : MULTI_CYCLE;
817        0/1     ==>                stall_jump    = ~BranchTargetALU;
818        0/1     ==>                jump_set_raw  = jump_set_dec;
819                                 end
820                                 alu_multicycle_dec: begin
821        0/1     ==>                stall_alu     = 1'b1;
822        0/1     ==>                id_fsm_d      = MULTI_CYCLE;
823        0/1     ==>                rf_we_raw     = 1'b0;
824                                 end
825                                 default: begin
826        0/1     ==>                id_fsm_d      = FIRST_CYCLE;
827                                 end
828                               endcase
829                             end
830                     
831                             MULTI_CYCLE: begin
832        0/1     ==>            if(multdiv_en_dec) begin
833        0/1     ==>              rf_we_raw       = rf_we_dec & ex_valid_i;
834                               end
                   ==>  MISSING_ELSE
835                     
836        0/1     ==>            if (multicycle_done & ready_wb_i) begin
837        0/1     ==>              id_fsm_d        = FIRST_CYCLE;
838                               end else begin
839        0/1     ==>              stall_multdiv   = multdiv_en_dec;
840        0/1     ==>              stall_branch    = branch_in_dec;
841        0/1     ==>              stall_jump      = jump_in_dec;
842                               end
843                             end
844                     
845                             default: begin
846        0/1     ==>            id_fsm_d          = FIRST_CYCLE;
847                             end
848                           endcase
849                         end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_id_stage

               Total   Covered  Percent
Conditions         44       10    22.73
Logical            44       10    22.73
Non-Logical         0        0
Event               0        0

 LINE       512
 EXPRESSION ((csr_op_en_o == 1'b1) && ((csr_op_o == CSR_OP_WRITE) || (csr_op_o == CSR_OP_SET)))
             ----------1----------    ----------------------------2---------------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       512
 SUB-EXPRESSION ((csr_op_o == CSR_OP_WRITE) || (csr_op_o == CSR_OP_SET))
                 -------------1------------    ------------2-----------

-1- -2- Status
 0   0  Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       513
 EXPRESSION ((csr_num_e'(instr_rdata_i[31:20]) == CSR_MSTATUS) || (csr_num_e'(instr_rdata_i[31:20]) == CSR_MIE))
             ------------------------1------------------------    ----------------------2----------------------

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       517
 EXPRESSION ((csr_op_en_o == 1'b1) && (csr_op_o != CSR_OP_READ))
             ----------1----------    ------------2------------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       518
 EXPRESSION 
 Number  Term
      1  (csr_num_e'(instr_rdata_i[31:20]) == CSR_DCSR) || 
      2  (csr_num_e'(instr_rdata_i[31:20]) == CSR_DPC) || 
      3  (csr_num_e'(instr_rdata_i[31:20]) == CSR_DSCRATCH0) || 
      4  (csr_num_e'(instr_rdata_i[31:20]) == CSR_DSCRATCH1))

-1- -2- -3- -4- Status
 0   0   0   0  Not Covered
 0   0   0   1  Not Covered
 0   0   1   0  Not Covered
 0   1   0   0  Not Covered
 1   0   0   0  Not Covered

 LINE       800
 EXPRESSION ((data_ind_timing_i || (((!BranchTargetALU)) && branch_decision_i)) ? MULTI_CYCLE : FIRST_CYCLE)
             ---------------------------------1--------------------------------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       800
 SUB-EXPRESSION (data_ind_timing_i || (((!BranchTargetALU)) && branch_decision_i))
                 --------1--------    ---------------------2---------------------

-1- -2- Status
 0   0  Not Covered
 0   1  Not Covered
 1   0  Not Covered

 LINE       800
 SUB-EXPRESSION (((!BranchTargetALU)) && branch_decision_i)
                 ----------1---------    --------2--------

-1- -2- Status
 -   0  Not Covered
 -   1  Not Covered

 LINE       369
 EXPRESSION (instr_is_compressed_i ? 32'h00000002 : 32'h00000004)
             ----------1----------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       292
 EXPRESSION (lsu_addr_incr_req_i ? OP_A_FWD : alu_op_a_mux_sel_dec)
             ---------1---------

-1- Status
 0  Covered
 1  Not Covered

 LINE       293
 EXPRESSION (lsu_addr_incr_req_i ? OP_B_IMM : alu_op_b_mux_sel_dec)
             ---------1---------

-1- Status
 0  Covered
 1  Not Covered

 LINE       294
 EXPRESSION (lsu_addr_incr_req_i ? IMM_B_INCR_ADDR : imm_b_mux_sel_dec)
             ---------1---------

-1- Status
 0  Covered
 1  Not Covered

 LINE       301
 EXPRESSION ((imm_a_mux_sel == IMM_A_Z) ? zimm_rs1_type : '0)
             -------------1------------

-1- Status
 0  Covered
 1  Not Covered

 LINE       385
 EXPRESSION ((alu_op_b_mux_sel == OP_B_IMM) ? imm_b : rf_rdata_b_fwd)
             ---------------1--------------

-1- Status
 0  Not Covered
 1  Covered

 LINE       627
 EXPRESSION (instr_executing ? ((data_req_allowed & lsu_req_dec)) : 1'b0)
             -------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       628
 EXPRESSION (instr_executing ? mult_en_dec : 1'b0)
             -------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       629
 EXPRESSION (instr_executing ? div_en_dec : 1'b0)
             -------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       990
 EXPRESSION (lsu_req_dec ? lsu_resp_valid_i : ex_valid_i)
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_id_stage
                Total Covered Percent 
Totals          211   0       0.00    
Total Bits      2526  0       0.00    
Total Bits 0->1 1263  0       0.00    
Total Bits 1->0 1263  0       0.00    

                             
Ports          112  0 0.00   
Port Bits      1474 0 0.00   
Port Bits 0->1 737  0 0.00   
Port Bits 1->0 737  0 0.00   

                               
Signals          99   0 0.00   
Signal Bits      1052 0 0.00   
Signal Bits 0->1 526  0 0.00   
Signal Bits 1->0 526  0 0.00   

Port Details
                              Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                         No     No          No          INPUT     
rst_ni                        No     No          No          INPUT     
ctrl_busy_o                   No     No          No          OUTPUT    
illegal_insn_o                No     No          No          OUTPUT    
instr_valid_i                 No     No          No          INPUT     
instr_rdata_i[31:0]           No     No          No          INPUT     
instr_rdata_alu_i[31:0]       No     No          No          INPUT     
instr_rdata_c_i[15:0]         No     No          No          INPUT     
instr_is_compressed_i         No     No          No          INPUT     
instr_bp_taken_i              No     No          No          INPUT     
instr_req_o                   No     No          No          OUTPUT    
instr_first_cycle_id_o        No     No          No          OUTPUT    
instr_valid_clear_o           No     No          No          OUTPUT    
id_in_ready_o                 No     No          No          OUTPUT    
icache_inval_o                No     No          No          OUTPUT    
branch_decision_i             No     No          No          INPUT     
pc_set_o                      No     No          No          OUTPUT    
pc_set_spec_o                 No     No          No          OUTPUT    
pc_mux_o[2:0]                 No     No          No          OUTPUT    
nt_branch_mispredict_o        No     No          No          OUTPUT    
exc_pc_mux_o[1:0]             No     No          No          OUTPUT    
exc_cause_o[5:0]              No     No          No          OUTPUT    
illegal_c_insn_i              No     No          No          INPUT     
instr_fetch_err_i             No     No          No          INPUT     
instr_fetch_err_plus2_i       No     No          No          INPUT     
pc_id_i[31:0]                 No     No          No          INPUT     
ex_valid_i                    No     No          No          INPUT     
lsu_resp_valid_i              No     No          No          INPUT     
alu_operator_ex_o[5:0]        No     No          No          OUTPUT    
alu_operand_a_ex_o[31:0]      No     No          No          OUTPUT    
alu_operand_b_ex_o[31:0]      No     No          No          OUTPUT    
imd_val_we_ex_i[1:0]          No     No          No          INPUT     
bt_a_operand_o[31:0]          No     No          No          OUTPUT    
bt_b_operand_o[31:0]          No     No          No          OUTPUT    
mult_en_ex_o                  No     No          No          OUTPUT    
div_en_ex_o                   No     No          No          OUTPUT    
mult_sel_ex_o                 No     No          No          OUTPUT    
div_sel_ex_o                  No     No          No          OUTPUT    
multdiv_operator_ex_o[1:0]    No     No          No          OUTPUT    
multdiv_signed_mode_ex_o[1:0] No     No          No          OUTPUT    
multdiv_operand_a_ex_o[31:0]  No     No          No          OUTPUT    
multdiv_operand_b_ex_o[31:0]  No     No          No          OUTPUT    
multdiv_ready_id_o            No     No          No          OUTPUT    
csr_access_o                  No     No          No          OUTPUT    
csr_op_o[1:0]                 No     No          No          OUTPUT    
csr_op_en_o                   No     No          No          OUTPUT    
csr_save_if_o                 No     No          No          OUTPUT    
csr_save_id_o                 No     No          No          OUTPUT    
csr_save_wb_o                 No     No          No          OUTPUT    
csr_restore_mret_id_o         No     No          No          OUTPUT    
csr_restore_dret_id_o         No     No          No          OUTPUT    
csr_save_cause_o              No     No          No          OUTPUT    
csr_mtval_o[31:0]             No     No          No          OUTPUT    
priv_mode_i[1:0]              No     No          No          INPUT     
csr_mstatus_tw_i              No     No          No          INPUT     
illegal_csr_insn_i            No     No          No          INPUT     
data_ind_timing_i             No     No          No          INPUT     
lsu_req_o                     No     No          No          OUTPUT    
lsu_we_o                      No     No          No          OUTPUT    
lsu_type_o[1:0]               No     No          No          OUTPUT    
lsu_sign_ext_o                No     No          No          OUTPUT    
lsu_wdata_o[31:0]             No     No          No          OUTPUT    
lsu_req_done_i                No     No          No          INPUT     
lsu_addr_incr_req_i           No     No          No          INPUT     
lsu_addr_last_i[31:0]         No     No          No          INPUT     
csr_mstatus_mie_i             No     No          No          INPUT     
irq_pending_i                 No     No          No          INPUT     
irqs_i.irq_fast[14:0]         No     No          No          INPUT     
irqs_i.irq_external           No     No          No          INPUT     
irqs_i.irq_timer              No     No          No          INPUT     
irqs_i.irq_software           No     No          No          INPUT     
irq_nm_i                      No     No          No          INPUT     
nmi_mode_o                    No     No          No          OUTPUT    
lsu_load_err_i                No     No          No          INPUT     
lsu_store_err_i               No     No          No          INPUT     
debug_mode_o                  No     No          No          OUTPUT    
debug_cause_o[2:0]            No     No          No          OUTPUT    
debug_csr_save_o              No     No          No          OUTPUT    
debug_req_i                   No     No          No          INPUT     
debug_single_step_i           No     No          No          INPUT     
debug_ebreakm_i               No     No          No          INPUT     
debug_ebreaku_i               No     No          No          INPUT     
trigger_match_i               No     No          No          INPUT     
result_ex_i[31:0]             No     No          No          INPUT     
csr_rdata_i[31:0]             No     No          No          INPUT     
rf_raddr_a_o[4:0]             No     No          No          OUTPUT    
rf_rdata_a_i[31:0]            No     No          No          INPUT     
rf_raddr_b_o[4:0]             No     No          No          OUTPUT    
rf_rdata_b_i[31:0]            No     No          No          INPUT     
rf_ren_a_o                    No     No          No          OUTPUT    
rf_ren_b_o                    No     No          No          OUTPUT    
rf_waddr_id_o[4:0]            No     No          No          OUTPUT    
rf_wdata_id_o[31:0]           No     No          No          OUTPUT    
rf_we_id_o                    No     No          No          OUTPUT    
rf_rd_a_wb_match_o            No     No          No          OUTPUT    
rf_rd_b_wb_match_o            No     No          No          OUTPUT    
rf_waddr_wb_i[4:0]            No     No          No          INPUT     
rf_wdata_fwd_wb_i[31:0]       No     No          No          INPUT     
rf_write_wb_i                 No     No          No          INPUT     
en_wb_o                       No     No          No          OUTPUT    
instr_type_wb_o[1:0]          No     No          No          OUTPUT    
instr_perf_count_id_o         No     No          No          OUTPUT    
ready_wb_i                    No     No          No          INPUT     
outstanding_load_wb_i         No     No          No          INPUT     
outstanding_store_wb_i        No     No          No          INPUT     
perf_jump_o                   No     No          No          OUTPUT    
perf_branch_o                 No     No          No          OUTPUT    
perf_tbranch_o                No     No          No          OUTPUT    
perf_dside_wait_o             No     No          No          OUTPUT    
perf_mul_wait_o               No     No          No          OUTPUT    
perf_div_wait_o               No     No          No          OUTPUT    
instr_id_done_o               No     No          No          OUTPUT    

Signal Details
                                              Toggle Toggle 1->0 Toggle 0->1 
illegal_insn_dec                              No     No          No          
ebrk_insn                                     No     No          No          
mret_insn_dec                                 No     No          No          
dret_insn_dec                                 No     No          No          
ecall_insn_dec                                No     No          No          
wfi_insn_dec                                  No     No          No          
wb_exception                                  No     No          No          
branch_in_dec                                 No     No          No          
branch_spec                                   No     No          No          
branch_set_spec                               No     No          No          
branch_set_raw_spec                           No     No          No          
branch_set                                    No     No          No          
branch_set_raw                                No     No          No          
branch_set_raw_d                              No     No          No          
branch_jump_set_done_q                        No     No          No          
branch_jump_set_done_d                        No     No          No          
branch_not_set                                No     No          No          
branch_taken                                  No     No          No          
jump_in_dec                                   No     No          No          
jump_set_dec                                  No     No          No          
jump_set                                      No     No          No          
jump_set_raw                                  No     No          No          
instr_first_cycle                             No     No          No          
instr_executing_spec                          No     No          No          
instr_executing                               No     No          No          
instr_done                                    No     No          No          
controller_run                                No     No          No          
stall_ld_hz                                   No     No          No          
stall_mem                                     No     No          No          
stall_multdiv                                 No     No          No          
stall_branch                                  No     No          No          
stall_jump                                    No     No          No          
stall_id                                      No     No          No          
stall_wb                                      No     No          No          
flush_id                                      No     No          No          
multicycle_done                               No     No          No          
imm_i_type[31:0]                              No     No          No          
imm_s_type[31:0]                              No     No          No          
imm_b_type[31:0]                              No     No          No          
imm_u_type[31:0]                              No     No          No          
imm_j_type[31:0]                              No     No          No          
zimm_rs1_type[31:0]                           No     No          No          
imm_a[31:0]                                   No     No          No          
imm_b[31:0]                                   No     No          No          
rf_wdata_sel                                  No     No          No          
rf_we_dec                                     No     No          No          
rf_we_raw                                     No     No          No          
rf_ren_a                                      No     No          No          
rf_ren_b                                      No     No          No          
rf_ren_a_dec                                  No     No          No          
rf_ren_b_dec                                  No     No          No          
rf_rdata_a_fwd[31:0]                          No     No          No          
rf_rdata_b_fwd[31:0]                          No     No          No          
alu_operator[5:0]                             No     No          No          
alu_op_a_mux_sel[1:0]                         No     No          No          
alu_op_a_mux_sel_dec[1:0]                     No     No          No          
alu_op_b_mux_sel                              No     No          No          
alu_op_b_mux_sel_dec                          No     No          No          
alu_multicycle_dec                            No     No          No          
stall_alu                                     No     No          No          
bt_a_mux_sel[1:0]                             No     No          No          
bt_b_mux_sel[2:0]                             No     No          No          
imm_a_mux_sel                                 No     No          No          
imm_b_mux_sel[2:0]                            No     No          No          
imm_b_mux_sel_dec[2:0]                        No     No          No          
mult_en_id                                    No     No          No          
mult_en_dec                                   No     No          No          
div_en_id                                     No     No          No          
div_en_dec                                    No     No          No          
multdiv_en_dec                                No     No          No          
multdiv_operator[1:0]                         No     No          No          
multdiv_signed_mode[1:0]                      No     No          No          
lsu_we                                        No     No          No          
lsu_type[1:0]                                 No     No          No          
lsu_sign_ext                                  No     No          No          
lsu_req                                       No     No          No          
lsu_req_dec                                   No     No          No          
data_req_allowed                              No     No          No          
csr_pipe_flush                                No     No          No          
alu_operand_a[31:0]                           No     No          No          
alu_operand_b[31:0]                           No     No          No          
id_fsm_q                                      No     No          No          
id_fsm_d                                      No     No          No          
fcov_rf_rd_wb_hz                              No     No          No          
unused_fcov_rf_rd_wb_hz                       No     No          No          
fcov_branch_taken                             No     No          No          
unused_fcov_branch_taken                      No     No          No          
fcov_branch_not_taken                         No     No          No          
unused_fcov_branch_not_taken                  No     No          No          
g_nobtalu.unused_a_mux_sel[1:0]               No     No          No          
g_nobtalu.unused_b_mux_sel[2:0]               No     No          No          
g_branch_set_flop.branch_set_raw_q            No     No          No          
gen_no_stall_mem.unused_data_req_done_ex      No     No          No          
gen_no_stall_mem.unused_rf_waddr_wb[4:0]      No     No          No          
gen_no_stall_mem.unused_rf_write_wb           No     No          No          
gen_no_stall_mem.unused_outstanding_load_wb   No     No          No          
gen_no_stall_mem.unused_outstanding_store_wb  No     No          No          
gen_no_stall_mem.unused_wb_exception          No     No          No          
gen_no_stall_mem.unused_rf_wdata_fwd_wb[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_id_stage
         Line No. Total Covered Percent 
Branches          71    20      28.17   
TERNARY  292      2     1       50.00   
TERNARY  293      2     1       50.00   
TERNARY  294      2     1       50.00   
TERNARY  301      2     1       50.00   
TERNARY  385      2     1       50.00   
TERNARY  627      2     1       50.00   
TERNARY  628      2     1       50.00   
TERNARY  629      2     1       50.00   
TERNARY  990      2     1       50.00   
CASE     305      5     1       20.00   
CASE     412      3     2       66.67   
IF       512      5     1       20.00   
IF       692      2     1       50.00   
IF       747      3     1       33.33   
IF       772      18    1       5.56    
CASE     363      9     1       11.11   
IF       393      3     1       33.33   
IF       393      3     1       33.33   
IF       669      2     1       50.00   


292          assign alu_op_a_mux_sel = lsu_addr_incr_req_i ? OP_A_FWD        : alu_op_a_mux_sel_dec;
                                                           -1-  
                                                           ==>  
                                                           ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


293          assign alu_op_b_mux_sel = lsu_addr_incr_req_i ? OP_B_IMM        : alu_op_b_mux_sel_dec;
                                                           -1-  
                                                           ==>  
                                                           ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


294          assign imm_b_mux_sel    = lsu_addr_incr_req_i ? IMM_B_INCR_ADDR : imm_b_mux_sel_dec;
                                                           -1-  
                                                           ==>  
                                                           ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


301          assign imm_a = (imm_a_mux_sel == IMM_A_Z) ? zimm_rs1_type : '0;
                                                       -1-  
                                                       ==>  
                                                       ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


385          assign alu_operand_b = (alu_op_b_mux_sel == OP_B_IMM) ? imm_b : rf_rdata_b_fwd;
                                                                   -1-  
                                                                   ==>  
                                                                   ==>  

Branches:

-1- Status      
1   Covered     
0   Not Covered 


627          assign lsu_req         = instr_executing ? data_req_allowed & lsu_req_dec  : 1'b0;
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


628          assign mult_en_id      = instr_executing ? mult_en_dec                     : 1'b0;
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


629          assign div_en_id       = instr_executing ? div_en_dec                      : 1'b0;
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


990            assign multicycle_done = lsu_req_dec ? lsu_resp_valid_i : ex_valid_i;
                                                    -1-  
                                                    ==>  
                                                    ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


305            unique case (alu_op_a_mux_sel)
                      -1-  
306              OP_A_REG_A:  alu_operand_a = rf_rdata_a_fwd;
                 ==>
307              OP_A_FWD:    alu_operand_a = lsu_addr_last_i;
                 ==>
308              OP_A_CURRPC: alu_operand_a = pc_id_i;
                 ==>
309              OP_A_IMM:    alu_operand_a = imm_a;
                 ==>
310              default:     alu_operand_a = pc_id_i;
                 ==>

Branches:

-1-          Status      
OP_A_REG_A   Not Covered 
OP_A_FWD     Not Covered 
OP_A_CURRPC  Not Covered 
OP_A_IMM     Covered     
default      Not Covered 


412            unique case (rf_wdata_sel)
                      -1-  
413              RF_WD_EX:  rf_wdata_id_o = result_ex_i;
                 ==>
414              RF_WD_CSR: rf_wdata_id_o = csr_rdata_i;
                 ==>
415              default:   rf_wdata_id_o = result_ex_i;
                 ==>

Branches:

-1-        Status      
RF_WD_EX   Covered     
RF_WD_CSR  Not Covered 
default    Covered     


512            if (csr_op_en_o == 1'b1 && (csr_op_o == CSR_OP_WRITE || csr_op_o == CSR_OP_SET)) begin
               -1-  
513              if (csr_num_e'(instr_rdata_i[31:20]) == CSR_MSTATUS   ||
                 -2-  
514                  csr_num_e'(instr_rdata_i[31:20]) == CSR_MIE) begin
515                csr_pipe_flush = 1'b1;
                   ==>
516              end
                 MISSING_ELSE
                 ==>
517            end else if (csr_op_en_o == 1'b1 && csr_op_o != CSR_OP_READ) begin
                        -3-  
518              if (csr_num_e'(instr_rdata_i[31:20]) == CSR_DCSR      ||
                 -4-  
519                  csr_num_e'(instr_rdata_i[31:20]) == CSR_DPC       ||
520                  csr_num_e'(instr_rdata_i[31:20]) == CSR_DSCRATCH0 ||
521                  csr_num_e'(instr_rdata_i[31:20]) == CSR_DSCRATCH1) begin
522                csr_pipe_flush = 1'b1;
                   ==>
523              end
                 MISSING_ELSE
                 ==>
524            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- -3- -4- Status      
1   1   -   -   Not Covered 
1   0   -   -   Not Covered 
0   -   1   1   Not Covered 
0   -   1   0   Not Covered 
0   -   0   -   Covered     


692            if (!rst_ni) begin
               -1-  
693              branch_jump_set_done_q <= 1'b0;
                 ==>
694            end else begin
695              branch_jump_set_done_q <= branch_jump_set_done_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


747            if (!rst_ni) begin
               -1-  
748              id_fsm_q <= FIRST_CYCLE;
                 ==>
749            end else if (instr_executing) begin
                        -2-  
750              id_fsm_q <= id_fsm_d;
                 ==>
751            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


772            if (instr_executing_spec) begin
               -1-  
773              unique case (id_fsm_q)
                        -2-  
774                FIRST_CYCLE: begin
775                  unique case (1'b1)
                            -3-  
776                    lsu_req_dec: begin
777                      if (!WritebackStage) begin
                         -4-  
778                        // LSU operation
779                        id_fsm_d    = MULTI_CYCLE;
                           ==>
780                      end else begin
781                        if(~lsu_req_done_i) begin
                           -5-  
782                          id_fsm_d  = MULTI_CYCLE;
                             ==>
783                        end
                           MISSING_ELSE
                           ==>
784                      end
785                    end
786                    multdiv_en_dec: begin
787                      // MUL or DIV operation
788                      if (~ex_valid_i) begin
                         -6-  
789                        // When single-cycle multiply is configured mul can finish in the first cycle so
790                        // only enter MULTI_CYCLE state if a result isn't immediately available
791                        id_fsm_d      = MULTI_CYCLE;
                           ==>
792                        rf_we_raw     = 1'b0;
793                        stall_multdiv = 1'b1;
794                      end
                         MISSING_ELSE
                         ==>
795                    end
796                    branch_in_dec: begin
797                      // cond branch operation
798                      // All branches take two cycles in fixed time execution mode, regardless of branch
799                      // condition.
800                      id_fsm_d         = (data_ind_timing_i || (!BranchTargetALU && branch_decision_i)) ?
                                                                                                           -7-  
                                                                                                           ==>  
                                                                                                           ==>  
801                                             MULTI_CYCLE : FIRST_CYCLE;
802                      stall_branch     = (~BranchTargetALU & branch_decision_i) | data_ind_timing_i;
803                      branch_set_raw_d = (branch_decision_i | data_ind_timing_i);
804        
805                      if (BranchPredictor) begin
                         -8-  
806                        branch_not_set = ~branch_decision_i;
                           ==>
807                      end
                         MISSING_ELSE
                         ==>
808        
809                      // Speculative branch (excludes branch_decision_i)
810                      branch_spec   = SpecBranch ? 1'b1 : branch_decision_i;
811                      perf_branch_o = 1'b1;
812                    end
813                    jump_in_dec: begin
814                      // uncond branch operation
815                      // BTALU means jumps only need one cycle
816                      id_fsm_d      = BranchTargetALU ? FIRST_CYCLE : MULTI_CYCLE;
                         ==>
817                      stall_jump    = ~BranchTargetALU;
818                      jump_set_raw  = jump_set_dec;
819                    end
820                    alu_multicycle_dec: begin
821                      stall_alu     = 1'b1;
                         ==>
822                      id_fsm_d      = MULTI_CYCLE;
823                      rf_we_raw     = 1'b0;
824                    end
825                    default: begin
826                      id_fsm_d      = FIRST_CYCLE;
                         ==>
827                    end
828                  endcase
829                end
830        
831                MULTI_CYCLE: begin
832                  if(multdiv_en_dec) begin
                     -9-  
833                    rf_we_raw       = rf_we_dec & ex_valid_i;
                       ==>
834                  end
                     MISSING_ELSE
                     ==>
835        
836                  if (multicycle_done & ready_wb_i) begin
                     -10-  
837                    id_fsm_d        = FIRST_CYCLE;
                       ==>
838                  end else begin
839                    stall_multdiv   = multdiv_en_dec;
                       ==>
840                    stall_branch    = branch_in_dec;
841                    stall_jump      = jump_in_dec;
842                  end
843                end
844        
845                default: begin
846                  id_fsm_d          = FIRST_CYCLE;
                     ==>
847                end
848              endcase
849            end
               MISSING_ELSE
               ==>

Branches:

-1- -2-          -3-                 -4- -5- -6- -7- -8- -9- -10- Status      
1   FIRST_CYCLE  lsu_req_dec         1   -   -   -   -   -   -    Not Covered 
1   FIRST_CYCLE  lsu_req_dec         0   1   -   -   -   -   -    Not Covered 
1   FIRST_CYCLE  lsu_req_dec         0   0   -   -   -   -   -    Not Covered 
1   FIRST_CYCLE  multdiv_en_dec      -   -   1   -   -   -   -    Not Covered 
1   FIRST_CYCLE  multdiv_en_dec      -   -   0   -   -   -   -    Not Covered 
1   FIRST_CYCLE  branch_in_dec       -   -   -   1   -   -   -    Not Covered 
1   FIRST_CYCLE  branch_in_dec       -   -   -   0   -   -   -    Not Covered 
1   FIRST_CYCLE  branch_in_dec       -   -   -   -   1   -   -    Not Covered 
1   FIRST_CYCLE  branch_in_dec       -   -   -   -   0   -   -    Not Covered 
1   FIRST_CYCLE  jump_in_dec         -   -   -   -   -   -   -    Not Covered 
1   FIRST_CYCLE  alu_multicycle_dec  -   -   -   -   -   -   -    Not Covered 
1   FIRST_CYCLE  default             -   -   -   -   -   -   -    Not Covered 
1   MULTI_CYCLE  -                   -   -   -   -   -   1   -    Not Covered 
1   MULTI_CYCLE  -                   -   -   -   -   -   0   -    Not Covered 
1   MULTI_CYCLE  -                   -   -   -   -   -   -   1    Not Covered 
1   MULTI_CYCLE  -                   -   -   -   -   -   -   0    Not Covered 
1   default      -                   -   -   -   -   -   -   -    Not Covered 
0   -            -                   -   -   -   -   -   -   -    Covered     


363              unique case (imm_b_mux_sel)
                        -1-  
364                IMM_B_I:         imm_b = imm_i_type;
                   ==>
365                IMM_B_S:         imm_b = imm_s_type;
                   ==>
366                IMM_B_B:         imm_b = imm_b_type;
                   ==>
367                IMM_B_U:         imm_b = imm_u_type;
                   ==>
368                IMM_B_J:         imm_b = imm_j_type;
                   ==>
369                IMM_B_INCR_PC:   imm_b = instr_is_compressed_i ? 32'h2 : 32'h4;
                                                                  -2-  
                                                                  ==>  
                                                                  ==>  
370                IMM_B_INCR_ADDR: imm_b = 32'h4;
                   ==>
371                default:         imm_b = 32'h4;
                   ==>

Branches:

-1-              -2- Status      
IMM_B_I          -   Covered     
IMM_B_S          -   Not Covered 
IMM_B_B          -   Not Covered 
IMM_B_U          -   Not Covered 
IMM_B_J          -   Not Covered 
IMM_B_INCR_PC    1   Not Covered 
IMM_B_INCR_PC    0   Not Covered 
IMM_B_INCR_ADDR  -   Not Covered 
default          -   Not Covered 


393              if (!rst_ni) begin
                 -1-  
394                imd_val_q[i] <= '0;
                   ==>
395              end else if (imd_val_we_ex_i[i]) begin
                          -2-  
396                imd_val_q[i] <= imd_val_d_ex_i[i];
                   ==>
397              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


393              if (!rst_ni) begin
                 -1-  
394                imd_val_q[i] <= '0;
                   ==>
395              end else if (imd_val_we_ex_i[i]) begin
                          -2-  
396                imd_val_q[i] <= imd_val_d_ex_i[i];
                   ==>
397              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


669              if (!rst_ni) begin
                 -1-  
670                branch_set_raw_q <= 1'b0;
                   ==>
671              end else begin
672                branch_set_raw_q <= branch_set_raw_d;
                   ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_id_stage
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       25    25        100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            25    25        100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                                               Attempts Real Successes Failures Incomplete 
IbexAluAOpMuxSelValid                              3        0              0        0          
IbexAluOpMuxSelKnown                               3        0              0        0          
IbexAluOpMuxSelKnownKnownEnable                    3        0              0        0          
IbexBTAluAOpMuxSelKnown                            3        0              0        0          
IbexBTAluAOpMuxSelKnownKnownEnable                 3        0              0        0          
IbexBTAluAOpMuxSelValid                            3        0              0        0          
IbexBTAluBOpMuxSelKnown                            3        0              0        0          
IbexBTAluBOpMuxSelKnownKnownEnable                 3        0              0        0          
IbexBTAluBOpMuxSelValid                            3        0              0        0          
IbexBranchDecisionValid                            3        0              0        0          
IbexBranchDecisionValidKnownEnable                 3        0              0        0          
IbexDuplicateInstrMatch                            3        0              0        0          
IbexIdInstrALUKnown                                3        0              0        0          
IbexIdInstrALUKnownKnownEnable                     3        0              0        0          
IbexIdInstrKnown                                   3        0              0        0          
IbexIdInstrKnownKnownEnable                        3        0              0        0          
IbexMulticycleEnableUnique                         3        0              0        0          
IbexRegfileWdataSelValid                           3        0              0        0          
IbexWbStateKnown                                   3        0              0        0          
IllegalInsnStallMustBeMemStall                     3        0              0        0          
NeverDoubleBranch                                  3        0              0        0          
NeverDoubleJump                                    3        0              0        0          
StallIDIfMulticycle                                3        0              0        0          
g_nobtalu.IbexImmBMuxSelValid                      3        0              0        0          
gen_no_stall_mem.IbexStallIfValidInstrNotExecuting 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.id_stage_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 17.45  36.36  22.73   0.00  28.17   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
  8.11  19.83  12.21   0.00   8.53   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME          
 17.45  36.36  22.73   0.00  28.17   0.00 ibex_id_stage 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME        
 20.58  43.66  14.29   0.00  28.26  16.67 u_ibex_core 


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME         
  8.40  30.04   3.33   0.00   8.60   0.00 controller_i 
  5.80  11.06  14.81   0.00   3.10   0.00 decoder_i    



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : uvm_custom_install_verdi_recording
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.34  23.19 --     --      17.50 --     

Source File(s) : 

/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/verdi/uvm_custom_install_verdi_recorder.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                               
 20.34  23.19 --     --      17.50 --     uvm_custom_install_verdi_recording 



-------------------------------------------------------------------------------
Line Coverage for Module : uvm_custom_install_verdi_recording

             Line No.   Total   Covered  Percent
TOTAL                       69       16    23.19
INITIAL            71       69       16    23.19

70                         initial begin
71         1/1               verdi_clp = verdi_cmdline_processor::get_inst();
72         1/1               clp = uvm_cmdline_processor::get_inst();
73         1/1               pli_inst = uvm_verdi_pli::get_inst();
74         1/1               cs = uvm_coreservice_t::get();
75                      `ifdef VCS
76         1/1               env_vcs_home = getenv("VCS_HOME");
77         1/1               if (env_vcs_home!="")
78         1/1                   is_vcs_home_exist = 1;
                   ==>  MISSING_ELSE
79         1/1               env_vcs_uvm_home = getenv("VCS_UVM_HOME");
80         1/1               if (env_vcs_uvm_home!="")
81         0/1     ==>           is_vcs_uvm_home_exist = 1;
                        MISSING_ELSE
82         1/1               if (clp.get_arg_matches("+UVM_VPD_RECORD", tr_args))
83         0/1     ==>           is_vpd_record = 1;
                        MISSING_ELSE
84         1/1               env_str = getenv("SNPS_SIM_DEFAULT_GUI");
85         1/1               vc_env_str = getenv("VC_HOME");
86         1/1               if (vc_env_str!="")begin
87         0/1     ==>           sanity_file_name = {vc_env_str,"/etc/.sanity"};
88         0/1     ==>           file_handle = $fopen(sanity_file_name,"r");
89         0/1     ==>           if (file_handle!=0) begin
90         0/1     ==>               if (is_vpd_record)
91         0/1     ==>                   is_sanity_exist = 0;
92                                   else
93         0/1     ==>                   is_sanity_exist = 1;
94         0/1     ==>               $fclose(file_handle);
95                               end
                   ==>  MISSING_ELSE
96                           end
                        MISSING_ELSE
97                      `endif 
98                      
99                      `ifndef UVM_NO_VERDI_RECORD
100        1/1               if (verdi_clp.is_verdi_trace_ral()) begin
101                              uvm_root r_obj;
102        0/1     ==>           r_obj = uvm_root::get();
103        0/1     ==>           r_obj.set_report_id_verbosity("RegModel", UVM_HIGH);
104                          end
                        MISSING_ELSE
105                     `endif
106                     
107                          // Register the verdi_catcher to dump messages into FSDB
108                     `ifdef VCS
109        1/1               if ((clp.get_arg_matches("+UVM_LOG_RECORD", tr_args)&&clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args))
110                              ||(clp.get_arg_matches("+UVM_LOG_RECORD", tr_args)&&(env_str=="verdi"))
111                              ||verdi_clp.is_verdi_trace_fac()||verdi_clp.is_verdi_trace_msg()||verdi_clp.is_verdi_trace_uvm_aware()
112                              ||verdi_clp.is_verdi_trace_ral()||verdi_clp.is_verdi_trace_dht()
113                              ||(clp.get_arg_matches("+UVM_LOG_RECORD", tr_args) && verdi_clp.is_minus_gui_verdi())
114                              ||(clp.get_arg_matches("+UVM_LOG_RECORD", tr_args)&&is_sanity_exist)
115                              ||verdi_clp.is_verdi_trace_ralwave()||verdi_clp.is_verdi_trace_compwave())
116                          begin
117                     `else
118                          if ((clp.get_arg_matches("+UVM_LOG_RECORD", tr_args)&&clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args))
119                              ||verdi_clp.is_verdi_trace_fac()||verdi_clp.is_verdi_trace_msg()||verdi_clp.is_verdi_trace_uvm_aware()
120                              ||verdi_clp.is_verdi_trace_ral()||verdi_clp.is_verdi_trace_dht())
121                          begin
122                     `endif
123                            static verdi_report_catcher _verdi_catcher;
124                     
125        0/1     ==>         p = process::self();
126        0/1     ==>         if (p != null)
127        0/1     ==>             rand_state = p.get_randstate();
                   ==>  MISSING_ELSE
128        0/1     ==>         _verdi_catcher = new();
129        0/1     ==>         if (p != null)
130        0/1     ==>             p.set_randstate(rand_state);
                   ==>  MISSING_ELSE
131        0/1     ==>         uvm_report_cb::add(null,_verdi_catcher);
132        0/1     ==>         if (verdi_clp.is_verdi_trace_compwave()||verdi_clp.is_verdi_trace_dht()
133                                ||verdi_clp.is_verdi_trace_uvm_aware()) begin
134                                uvm_dhier_component dhier_comp;
135                     
136        0/1     ==>             p = process::self();
137        0/1     ==>             if (p != null)
138        0/1     ==>                 rand_state = p.get_randstate();
                   ==>  MISSING_ELSE
139        0/1     ==>             dhier_comp = new("DHIER_COMP", uvm_root::get());
140        0/1     ==>             if (p != null)
141        0/1     ==>                 p.set_randstate(rand_state);
                   ==>  MISSING_ELSE
142                            end
                   ==>  MISSING_ELSE
143                     `ifdef UVM_VERDI_RALWAVE
144                            if (verdi_clp.is_verdi_trace_ralwave()) begin
145                                if (is_vcs_uvm_home_exist)
146                                    pli_inst.dump_class_object_by_file("${VCS_UVM_HOME}/verdi/register.config");
147                                else if (is_vcs_home_exist)
148                                    pli_inst.dump_class_object_by_file("${VCS_HOME}/etc/uvm-1.2/verdi/register.config");
149                            end
150                     `endif
151                     `ifndef UVM_VERDI_NO_COMPWAVE
152                     `ifdef VCS
153        0/1     ==>         if (verdi_clp.is_verdi_trace_compwave()) begin
154        0/1     ==>             if (is_vcs_uvm_home_exist)
155        0/1     ==>                 pli_inst.dump_comp_object_by_file("${VCS_UVM_HOME}/verdi/component.config");
156        0/1     ==>             else if (is_vcs_home_exist)
157        0/1     ==>                 pli_inst.dump_comp_object_by_file("${VCS_HOME}/etc/uvm-1.2/verdi/component.config");
                   ==>  MISSING_ELSE
158                            end
                   ==>  MISSING_ELSE
159                     `endif
160                     `endif
161        0/1     ==>         if (verdi_clp.is_verdi_trace_uvm_aware()||verdi_clp.is_verdi_trace_fac()) begin
162        0/1     ==>             factory = cs.get_factory();
163                                // create new factory
164        0/1     ==>             p = process::self();
165        0/1     ==>             if (p != null)
166        0/1     ==>                 rand_state = p.get_randstate();
                   ==>  MISSING_ELSE
167        0/1     ==>             verdi_factory = new();
168        0/1     ==>             if (p != null)
169        0/1     ==>                 p.set_randstate(rand_state);
                   ==>  MISSING_ELSE
170                                // set the delegate
171        0/1     ==>             verdi_factory.delegate=factory;
172                                // enable new factory
173        0/1     ==>             cs.set_factory(verdi_factory);
174                            end
                   ==>  MISSING_ELSE
175                          end
                        MISSING_ELSE
176                     
177                          // Register the uvm_verdi_recorder to record transactions into FSDB
178                     `ifdef VCS
179        1/1               if ((clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args))
180                              ||(clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&(env_str=="verdi"))
181                              ||verdi_clp.is_verdi_trace_tlm()
182                              ||(clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&verdi_clp.is_minus_gui_verdi())
183                              ||(clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&is_sanity_exist))
184                          begin
185                     `else
186                          if ((clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args))
187                              ||verdi_clp.is_verdi_trace_tlm())
188                          begin
189                     `endif
190        0/1     ==>           p = process::self();
191        0/1     ==>           if (p != null)
192        0/1     ==>               rand_state = p.get_randstate();
                   ==>  MISSING_ELSE
193        0/1     ==>           verdi_db = new();
194        0/1     ==>           if (p != null)
195        0/1     ==>               p.set_randstate(rand_state);
                   ==>  MISSING_ELSE
196        0/1     ==>           cs.set_default_tr_database(verdi_db);
197        0/1     ==>           if (clp.get_arg_matches("+UVM_DISABLE_AUTO_COMPONENT", tr_args)) begin
198        0/2     ==>               `uvm_info("VERDI_TR_AUTO", "+UVM_DISABLE_AUTO_COMPONENT enabled but transaction recording enabled, usage model requires user to explicitly set recording_detail on components", UVM_MEDIUM)
uvm_info("VERDI_TR_AUTO", "+UVM_DISABLE_AUTO_COMPONENT enabled but transaction recording enabled, usage model requires user to explicitly set recording_detail on components", UVM_MEDIUM):
198.1                   begin 
198.2      0/1     ==>       if (uvm_report_enabled(UVM_MEDIUM,UVM_INFO,"VERDI_TR_AUTO")) 
198.3      0/1     ==>         uvm_report_info ("VERDI_TR_AUTO", "+UVM_DISABLE_AUTO_COMPONENT enabled but transaction recording enabled, usage model requires user to explicitly set recording_detail on components", UVM_MEDIUM, "/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/verdi/uvm_custom_install_verdi_recorder.sv", 198, "", 1); 
198.4                      end
                   ==>  MISSING_ELSE
199                              end
200                              else begin
201        0/2     ==>               `uvm_info("VERDI_TR_AUTO", "+UVM_TR_RECORD implicitly enables recording_details to UVM_FULL for all components. For explicit control use +UVM_DISABLE_AUTO_COMPONENT and set recording_detail on components accordingly", UVM_MEDIUM)
uvm_info("VERDI_TR_AUTO", "+UVM_TR_RECORD implicitly enables recording_details to UVM_FULL for all components. For explicit control use +UVM_DISABLE_AUTO_COMPONENT and set recording_detail on components accordingly", UVM_MEDIUM):
201.1                   begin 
201.2      0/1     ==>       if (uvm_report_enabled(UVM_MEDIUM,UVM_INFO,"VERDI_TR_AUTO")) 
201.3      0/1     ==>         uvm_report_info ("VERDI_TR_AUTO", "+UVM_TR_RECORD implicitly enables recording_details to UVM_FULL for all components. For explicit control use +UVM_DISABLE_AUTO_COMPONENT and set recording_detail on components accordingly", UVM_MEDIUM, "/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/verdi/uvm_custom_install_verdi_recorder.sv", 201, "", 1); 
201.4                      end
                   ==>  MISSING_ELSE
202        0/1     ==>               uvm_config_db#(uvm_bitstream_t)::set(uvm_root::get(), "*", "recording_detail", UVM_FULL);
203                              end
204                          end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Module : uvm_custom_install_verdi_recording
         Line No. Total Covered Percent 
Branches          40    7       17.50   
IF       77       2     1       50.00   
IF       80       2     1       50.00   
IF       82       2     1       50.00   
IF       86       4     1       25.00   
IF       100      2     1       50.00   
IF       109      19    1       5.26    
IF       179      9     1       11.11   


77              if (env_vcs_home!="")
                -1-  
78                  is_vcs_home_exist = 1;
                    ==>
                    MISSING_ELSE
                    ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


80              if (env_vcs_uvm_home!="")
                -1-  
81                  is_vcs_uvm_home_exist = 1;
                    ==>
                    MISSING_ELSE
                    ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


82              if (clp.get_arg_matches("+UVM_VPD_RECORD", tr_args))
                -1-  
83                  is_vpd_record = 1;
                    ==>
                    MISSING_ELSE
                    ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


86              if (vc_env_str!="")begin
                -1-  
87                  sanity_file_name = {vc_env_str,"/etc/.sanity"};
88                  file_handle = $fopen(sanity_file_name,"r");
89                  if (file_handle!=0) begin
                    -2-  
90                      if (is_vpd_record)
                        -3-  
91                          is_sanity_exist = 0;
                            ==>
92                      else
93                          is_sanity_exist = 1;
                            ==>
94                      $fclose(file_handle);
95                  end
                    MISSING_ELSE
                    ==>
96              end
                MISSING_ELSE
                ==>

Branches:

-1- -2- -3- Status      
1   1   1   Not Covered 
1   1   0   Not Covered 
1   0   -   Not Covered 
0   -   -   Covered     


100             if (verdi_clp.is_verdi_trace_ral()) begin
                -1-  
101                 uvm_root r_obj;
102                 r_obj = uvm_root::get();
                    ==>
103                 r_obj.set_report_id_verbosity("RegModel", UVM_HIGH);
104             end
                MISSING_ELSE
                ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


109             if ((clp.get_arg_matches("+UVM_LOG_RECORD", tr_args)&&clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args))
                -1-  
110                 ||(clp.get_arg_matches("+UVM_LOG_RECORD", tr_args)&&(env_str=="verdi"))
111                 ||verdi_clp.is_verdi_trace_fac()||verdi_clp.is_verdi_trace_msg()||verdi_clp.is_verdi_trace_uvm_aware()
112                 ||verdi_clp.is_verdi_trace_ral()||verdi_clp.is_verdi_trace_dht()
113                 ||(clp.get_arg_matches("+UVM_LOG_RECORD", tr_args) && verdi_clp.is_minus_gui_verdi())
114                 ||(clp.get_arg_matches("+UVM_LOG_RECORD", tr_args)&&is_sanity_exist)
115                 ||verdi_clp.is_verdi_trace_ralwave()||verdi_clp.is_verdi_trace_compwave())
116             begin
117        `else
118             if ((clp.get_arg_matches("+UVM_LOG_RECORD", tr_args)&&clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args))
119                 ||verdi_clp.is_verdi_trace_fac()||verdi_clp.is_verdi_trace_msg()||verdi_clp.is_verdi_trace_uvm_aware()
120                 ||verdi_clp.is_verdi_trace_ral()||verdi_clp.is_verdi_trace_dht())
121             begin
122        `endif
123               static verdi_report_catcher _verdi_catcher;
124        
125               p = process::self();
126               if (p != null)
                  -2-  
127                   rand_state = p.get_randstate();
                      ==>
                      MISSING_ELSE
                      ==>
128               _verdi_catcher = new();
129               if (p != null)
                  -3-  
130                   p.set_randstate(rand_state);
                      ==>
                      MISSING_ELSE
                      ==>
131               uvm_report_cb::add(null,_verdi_catcher);
132               if (verdi_clp.is_verdi_trace_compwave()||verdi_clp.is_verdi_trace_dht()
                  -4-  
133                   ||verdi_clp.is_verdi_trace_uvm_aware()) begin
134                   uvm_dhier_component dhier_comp;
135        
136                   p = process::self();
137                   if (p != null)
                      -5-  
138                       rand_state = p.get_randstate();
                          ==>
                          MISSING_ELSE
                          ==>
139                   dhier_comp = new("DHIER_COMP", uvm_root::get());
140                   if (p != null)
                      -6-  
141                       p.set_randstate(rand_state);
                          ==>
                          MISSING_ELSE
                          ==>
142               end
                  MISSING_ELSE
                  ==>
143        `ifdef UVM_VERDI_RALWAVE
144               if (verdi_clp.is_verdi_trace_ralwave()) begin
145                   if (is_vcs_uvm_home_exist)
146                       pli_inst.dump_class_object_by_file("${VCS_UVM_HOME}/verdi/register.config");
147                   else if (is_vcs_home_exist)
148                       pli_inst.dump_class_object_by_file("${VCS_HOME}/etc/uvm-1.2/verdi/register.config");
149               end
150        `endif
151        `ifndef UVM_VERDI_NO_COMPWAVE
152        `ifdef VCS
153               if (verdi_clp.is_verdi_trace_compwave()) begin
                  -7-  
154                   if (is_vcs_uvm_home_exist)
                      -8-  
155                       pli_inst.dump_comp_object_by_file("${VCS_UVM_HOME}/verdi/component.config");
                          ==>
156                   else if (is_vcs_home_exist)
                           -9-  
157                       pli_inst.dump_comp_object_by_file("${VCS_HOME}/etc/uvm-1.2/verdi/component.config");
                          ==>
                          MISSING_ELSE
                          ==>
158               end
                  MISSING_ELSE
                  ==>
159        `endif
160        `endif
161               if (verdi_clp.is_verdi_trace_uvm_aware()||verdi_clp.is_verdi_trace_fac()) begin
                  -10-  
162                   factory = cs.get_factory();
163                   // create new factory
164                   p = process::self();
165                   if (p != null)
                      -11-  
166                       rand_state = p.get_randstate();
                          ==>
                          MISSING_ELSE
                          ==>
167                   verdi_factory = new();
168                   if (p != null)
                      -12-  
169                       p.set_randstate(rand_state);
                          ==>
                          MISSING_ELSE
                          ==>
170                   // set the delegate
171                   verdi_factory.delegate=factory;
172                   // enable new factory
173                   cs.set_factory(verdi_factory);
174               end
                  MISSING_ELSE
                  ==>
175             end
                MISSING_ELSE
                ==>

Branches:

-1- -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- -12- Status      
1   1   -   -   -   -   -   -   -   -    -    -    Not Covered 
1   0   -   -   -   -   -   -   -   -    -    -    Not Covered 
1   -   1   -   -   -   -   -   -   -    -    -    Not Covered 
1   -   0   -   -   -   -   -   -   -    -    -    Not Covered 
1   -   -   1   1   -   -   -   -   -    -    -    Not Covered 
1   -   -   1   0   -   -   -   -   -    -    -    Not Covered 
1   -   -   1   -   1   -   -   -   -    -    -    Not Covered 
1   -   -   1   -   0   -   -   -   -    -    -    Not Covered 
1   -   -   0   -   -   -   -   -   -    -    -    Not Covered 
1   -   -   -   -   -   1   1   -   -    -    -    Not Covered 
1   -   -   -   -   -   1   0   1   -    -    -    Not Covered 
1   -   -   -   -   -   1   0   0   -    -    -    Not Covered 
1   -   -   -   -   -   0   -   -   -    -    -    Not Covered 
1   -   -   -   -   -   -   -   -   1    1    -    Not Covered 
1   -   -   -   -   -   -   -   -   1    0    -    Not Covered 
1   -   -   -   -   -   -   -   -   1    -    1    Not Covered 
1   -   -   -   -   -   -   -   -   1    -    0    Not Covered 
1   -   -   -   -   -   -   -   -   0    -    -    Not Covered 
0   -   -   -   -   -   -   -   -   -    -    -    Covered     


179             if ((clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args))
                -1-  
180                 ||(clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&(env_str=="verdi"))
181                 ||verdi_clp.is_verdi_trace_tlm()
182                 ||(clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&verdi_clp.is_minus_gui_verdi())
183                 ||(clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&is_sanity_exist))
184             begin
185        `else
186             if ((clp.get_arg_matches("+UVM_TR_RECORD", tr_args)&&clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args))
187                 ||verdi_clp.is_verdi_trace_tlm())
188             begin
189        `endif
190                 p = process::self();
191                 if (p != null)
                    -2-  
192                     rand_state = p.get_randstate();
                        ==>
                        MISSING_ELSE
                        ==>
193                 verdi_db = new();
194                 if (p != null)
                    -3-  
195                     p.set_randstate(rand_state);
                        ==>
                        MISSING_ELSE
                        ==>
196                 cs.set_default_tr_database(verdi_db);
197                 if (clp.get_arg_matches("+UVM_DISABLE_AUTO_COMPONENT", tr_args)) begin
                    -4-  
198                     `uvm_info("VERDI_TR_AUTO", "+UVM_DISABLE_AUTO_COMPONENT enabled but transaction recording enabled, usage model requires user to explicitly set recording_detail on components", UVM_MEDIUM)
                        -5-                                                                                                                                                                                           
                        ==>
                        MISSING_ELSE
                        ==>
199                 end
200                 else begin
201                     `uvm_info("VERDI_TR_AUTO", "+UVM_TR_RECORD implicitly enables recording_details to UVM_FULL for all components. For explicit control use +UVM_DISABLE_AUTO_COMPONENT and set recording_detail on components accordingly", UVM_MEDIUM)
                        -6-                                                                                                                                                                                                                                     
                        ==>
                        MISSING_ELSE
                        ==>
202                     uvm_config_db#(uvm_bitstream_t)::set(uvm_root::get(), "*", "recording_detail", UVM_FULL);
203                 end
204             end
                MISSING_ELSE
                ==>

Branches:

-1- -2- -3- -4- -5- -6- Status      
1   1   -   -   -   -   Not Covered 
1   0   -   -   -   -   Not Covered 
1   -   1   -   -   -   Not Covered 
1   -   0   -   -   -   Not Covered 
1   -   -   1   1   -   Not Covered 
1   -   -   1   0   -   Not Covered 
1   -   -   0   -   1   Not Covered 
1   -   -   0   -   0   Not Covered 
0   -   -   -   -   -   Covered     


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvm_custom_install_verdi_recording
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.34  23.19 --     --      17.50 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.34  23.19 --     --      17.50 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                               
 20.34  23.19 --     --      17.50 --     uvm_custom_install_verdi_recording 


Parent : 

none
----------------


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_core
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.58  43.66  14.29   0.00  28.26  16.67 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_core.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                              
 20.58  43.66  14.29   0.00  28.26  16.67 tb_top.DUT.u_ibex_top.u_ibex_core 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_core

             Line No.   Total   Covered  Percent
TOTAL                      142       62    43.66
ALWAYS           1165       72       24    33.33
ALWAYS           1255        5        3    60.00
ALWAYS           1266        3        2    66.67
ALWAYS           1274        7        4    57.14
ALWAYS           1286        5        2    40.00
ALWAYS           1295        3        2    66.67
ALWAYS           1305       13        7    53.85
ALWAYS           1322        9        5    55.56
ALWAYS           1337       10        4    40.00
ALWAYS           1361        5        3    60.00
ALWAYS           1376        5        3    60.00
ALWAYS           1389        5        3    60.00
INITIAL          1406        0        0

1164                        always_ff @(posedge clk_i or negedge rst_ni) begin
1165       1/1                if (!rst_ni) begin
1166       1/1                  rvfi_stage_halt[i]      <= '0;
1167       1/1                  rvfi_stage_trap[i]      <= '0;
1168       1/1                  rvfi_stage_intr[i]      <= '0;
1169       1/1                  rvfi_stage_order[i]     <= '0;
1170       1/1                  rvfi_stage_insn[i]      <= '0;
1171       1/1                  rvfi_stage_mode[i]      <= {PRIV_LVL_M};
1172       1/1                  rvfi_stage_ixl[i]       <= CSR_MISA_MXL;
1173       1/1                  rvfi_stage_rs1_addr[i]  <= '0;
1174       1/1                  rvfi_stage_rs2_addr[i]  <= '0;
1175       1/1                  rvfi_stage_rs3_addr[i]  <= '0;
1176       1/1                  rvfi_stage_pc_rdata[i]  <= '0;
1177       1/1                  rvfi_stage_pc_wdata[i]  <= '0;
1178       1/1                  rvfi_stage_mem_rmask[i] <= '0;
1179       1/1                  rvfi_stage_mem_wmask[i] <= '0;
1180       1/1                  rvfi_stage_valid[i]     <= '0;
1181       1/1                  rvfi_stage_rs1_rdata[i] <= '0;
1182       1/1                  rvfi_stage_rs2_rdata[i] <= '0;
1183       1/1                  rvfi_stage_rs3_rdata[i] <= '0;
1184       1/1                  rvfi_stage_rd_wdata[i]  <= '0;
1185       1/1                  rvfi_stage_rd_addr[i]   <= '0;
1186       1/1                  rvfi_stage_mem_rdata[i] <= '0;
1187       1/1                  rvfi_stage_mem_wdata[i] <= '0;
1188       1/1                  rvfi_stage_mem_addr[i]  <= '0;
1189                          end else begin
1190       0/1     ==>          rvfi_stage_valid[i] <= rvfi_stage_valid_d[i];
1191                    
1192       0/1     ==>          if (i == 0) begin
1193       0/1     ==>            if(instr_id_done) begin
1194       0/1     ==>              rvfi_stage_halt[i]      <= '0;
1195       0/1     ==>              rvfi_stage_trap[i]      <= illegal_insn_id;
1196       0/1     ==>              rvfi_stage_intr[i]      <= rvfi_intr_d;
1197       0/1     ==>              rvfi_stage_order[i]     <= rvfi_stage_order[i] + 64'(rvfi_stage_valid_d[i]);
1198       0/1     ==>              rvfi_stage_insn[i]      <= rvfi_insn_id;
1199       0/1     ==>              rvfi_stage_mode[i]      <= {priv_mode_id};
1200       0/1     ==>              rvfi_stage_ixl[i]       <= CSR_MISA_MXL;
1201       0/1     ==>              rvfi_stage_rs1_addr[i]  <= rvfi_rs1_addr_d;
1202       0/1     ==>              rvfi_stage_rs2_addr[i]  <= rvfi_rs2_addr_d;
1203       0/1     ==>              rvfi_stage_rs3_addr[i]  <= rvfi_rs3_addr_d;
1204       0/1     ==>              rvfi_stage_pc_rdata[i]  <= pc_id;
1205       0/1     ==>              rvfi_stage_pc_wdata[i]  <= pc_set ? branch_target_ex : pc_if;
1206       0/1     ==>              rvfi_stage_mem_rmask[i] <= rvfi_mem_mask_int;
1207       0/1     ==>              rvfi_stage_mem_wmask[i] <= data_we_o ? rvfi_mem_mask_int : 4'b0000;
1208       0/1     ==>              rvfi_stage_rs1_rdata[i] <= rvfi_rs1_data_d;
1209       0/1     ==>              rvfi_stage_rs2_rdata[i] <= rvfi_rs2_data_d;
1210       0/1     ==>              rvfi_stage_rs3_rdata[i] <= rvfi_rs3_data_d;
1211       0/1     ==>              rvfi_stage_rd_addr[i]   <= rvfi_rd_addr_d;
1212       0/1     ==>              rvfi_stage_rd_wdata[i]  <= rvfi_rd_wdata_d;
1213       0/1     ==>              rvfi_stage_mem_rdata[i] <= rvfi_mem_rdata_d;
1214       0/1     ==>              rvfi_stage_mem_wdata[i] <= rvfi_mem_wdata_d;
1215       0/1     ==>              rvfi_stage_mem_addr[i]  <= rvfi_mem_addr_d;
1216                              end
                   ==>  MISSING_ELSE
1217                            end else begin
1218       0/1     ==>            if(instr_done_wb) begin
1219       0/1     ==>              rvfi_stage_halt[i]      <= rvfi_stage_halt[i-1];
1220       0/1     ==>              rvfi_stage_trap[i]      <= rvfi_stage_trap[i-1];
1221       0/1     ==>              rvfi_stage_intr[i]      <= rvfi_stage_intr[i-1];
1222       0/1     ==>              rvfi_stage_order[i]     <= rvfi_stage_order[i-1];
1223       0/1     ==>              rvfi_stage_insn[i]      <= rvfi_stage_insn[i-1];
1224       0/1     ==>              rvfi_stage_mode[i]      <= rvfi_stage_mode[i-1];
1225       0/1     ==>              rvfi_stage_ixl[i]       <= rvfi_stage_ixl[i-1];
1226       0/1     ==>              rvfi_stage_rs1_addr[i]  <= rvfi_stage_rs1_addr[i-1];
1227       0/1     ==>              rvfi_stage_rs2_addr[i]  <= rvfi_stage_rs2_addr[i-1];
1228       0/1     ==>              rvfi_stage_rs3_addr[i]  <= rvfi_stage_rs3_addr[i-1];
1229       0/1     ==>              rvfi_stage_pc_rdata[i]  <= rvfi_stage_pc_rdata[i-1];
1230       0/1     ==>              rvfi_stage_pc_wdata[i]  <= rvfi_stage_pc_wdata[i-1];
1231       0/1     ==>              rvfi_stage_mem_rmask[i] <= rvfi_stage_mem_rmask[i-1];
1232       0/1     ==>              rvfi_stage_mem_wmask[i] <= rvfi_stage_mem_wmask[i-1];
1233       0/1     ==>              rvfi_stage_rs1_rdata[i] <= rvfi_stage_rs1_rdata[i-1];
1234       0/1     ==>              rvfi_stage_rs2_rdata[i] <= rvfi_stage_rs2_rdata[i-1];
1235       0/1     ==>              rvfi_stage_rs3_rdata[i] <= rvfi_stage_rs3_rdata[i-1];
1236       0/1     ==>              rvfi_stage_mem_wdata[i] <= rvfi_stage_mem_wdata[i-1];
1237       0/1     ==>              rvfi_stage_mem_addr[i]  <= rvfi_stage_mem_addr[i-1];
1238                    
1239                                // For 2 RVFI_STAGES/Writeback Stage ignore first stage flops for rd_addr, rd_wdata and
1240                                // mem_rdata. For RF write addr/data actual write happens in writeback so capture
1241                                // address/data there. For mem_rdata that is only available from the writeback stage.
1242                                // Previous stage flops still exist in RTL as they are used by the non writeback config
1243       0/1     ==>              rvfi_stage_rd_addr[i]   <= rvfi_rd_addr_d;
1244       0/1     ==>              rvfi_stage_rd_wdata[i]  <= rvfi_rd_wdata_d;
1245       0/1     ==>              rvfi_stage_mem_rdata[i] <= rvfi_mem_rdata_d;
1246                              end
                   ==>  MISSING_ELSE
1247                            end
1248                          end
1249                        end
1250                      end
1251                    
1252                    
1253                      // Memory adddress/write data available first cycle of ld/st instruction from register read
1254                      always_comb begin
1255       1/1              if (instr_first_cycle_id) begin
1256       0/1     ==>        rvfi_mem_addr_d  = alu_adder_result_ex;
1257       0/1     ==>        rvfi_mem_wdata_d = lsu_wdata;
1258                        end else begin
1259       1/1                rvfi_mem_addr_d  = rvfi_mem_addr_q;
1260       1/1                rvfi_mem_wdata_d = rvfi_mem_wdata_q;
1261                        end
1262                      end
1263                    
1264                      // Capture read data from LSU when it becomes valid
1265                      always_comb begin
1266       1/1              if (lsu_resp_valid) begin
1267       0/1     ==>        rvfi_mem_rdata_d = rf_wdata_lsu;
1268                        end else begin
1269       1/1                rvfi_mem_rdata_d = rvfi_mem_rdata_q;
1270                        end
1271                      end
1272                    
1273                      always_ff @(posedge clk_i or negedge rst_ni) begin
1274       1/1              if (!rst_ni) begin
1275       1/1                rvfi_mem_addr_q  <= '0;
1276       1/1                rvfi_mem_rdata_q <= '0;
1277       1/1                rvfi_mem_wdata_q <= '0;
1278                        end else begin
1279       0/1     ==>        rvfi_mem_addr_q  <= rvfi_mem_addr_d;
1280       0/1     ==>        rvfi_mem_rdata_q <= rvfi_mem_rdata_d;
1281       0/1     ==>        rvfi_mem_wdata_q <= rvfi_mem_wdata_d;
1282                        end
1283                      end
1284                      // Byte enable based on data type
1285                      always_comb begin
1286       1/1              unique case (lsu_type)
1287       1/1                2'b00:   rvfi_mem_mask_int = 4'b1111;
1288       0/1     ==>        2'b01:   rvfi_mem_mask_int = 4'b0011;
1289       0/1     ==>        2'b10:   rvfi_mem_mask_int = 4'b0001;
1290       0/1     ==>        default: rvfi_mem_mask_int = 4'b0000;
1291                        endcase
1292                      end
1293                    
1294                      always_comb begin
1295       1/1              if (instr_is_compressed_id) begin
1296       0/1     ==>        rvfi_insn_id = {16'b0, instr_rdata_c_id};
1297                        end else begin
1298       1/1                rvfi_insn_id = instr_rdata_id;
1299                        end
1300                      end
1301                    
1302                      // Source registers 1 and 2 are read in the first instruction cycle
1303                      // Source register 3 is read in the second instruction cycle.
1304                      always_comb begin
1305       1/1              if (instr_first_cycle_id) begin
1306       0/1     ==>        rvfi_rs1_data_d = rf_ren_a ? multdiv_operand_a_ex : '0;
1307       0/1     ==>        rvfi_rs1_addr_d = rf_ren_a ? rf_raddr_a : '0;
1308       0/1     ==>        rvfi_rs2_data_d = rf_ren_b ? multdiv_operand_b_ex : '0;
1309       0/1     ==>        rvfi_rs2_addr_d = rf_ren_b ? rf_raddr_b : '0;
1310       0/1     ==>        rvfi_rs3_data_d = '0;
1311       0/1     ==>        rvfi_rs3_addr_d = '0;
1312                        end else begin
1313       1/1                rvfi_rs1_data_d = rvfi_rs1_data_q;
1314       1/1                rvfi_rs1_addr_d = rvfi_rs1_addr_q;
1315       1/1                rvfi_rs2_data_d = rvfi_rs2_data_q;
1316       1/1                rvfi_rs2_addr_d = rvfi_rs2_addr_q;
1317       1/1                rvfi_rs3_data_d = multdiv_operand_a_ex;
1318       1/1                rvfi_rs3_addr_d = rf_raddr_a;
1319                        end
1320                      end
1321                      always_ff @(posedge clk_i or negedge rst_ni) begin
1322       1/1              if (!rst_ni) begin
1323       1/1                rvfi_rs1_data_q <= '0;
1324       1/1                rvfi_rs1_addr_q <= '0;
1325       1/1                rvfi_rs2_data_q <= '0;
1326       1/1                rvfi_rs2_addr_q <= '0;
1327                    
1328                        end else begin
1329       0/1     ==>        rvfi_rs1_data_q <= rvfi_rs1_data_d;
1330       0/1     ==>        rvfi_rs1_addr_q <= rvfi_rs1_addr_d;
1331       0/1     ==>        rvfi_rs2_data_q <= rvfi_rs2_data_d;
1332       0/1     ==>        rvfi_rs2_addr_q <= rvfi_rs2_addr_d;
1333                        end
1334                      end
1335                    
1336                      always_comb begin
1337       1/1              if(rvfi_rd_we_wb) begin
1338                          // Capture address/data of write to register file
1339       0/1     ==>        rvfi_rd_addr_d  = rvfi_rd_addr_wb;
1340                          // If writing to x0 zero write data as required by RVFI specification
1341       0/1     ==>        if(rvfi_rd_addr_wb == 5'b0) begin
1342       0/1     ==>          rvfi_rd_wdata_d = '0;
1343                          end else begin
1344       0/1     ==>          rvfi_rd_wdata_d = rvfi_rd_wdata_wb;
1345                          end
1346       1/1              end else if(rvfi_instr_new_wb) begin
1347                          // If no RF write but new instruction in Writeback (when present) or ID/EX (when no writeback
1348                          // stage present) then zero RF write address/data as required by RVFI specification
1349       0/1     ==>        rvfi_rd_addr_d  = '0;
1350       0/1     ==>        rvfi_rd_wdata_d = '0;
1351                        end else begin
1352                          // Otherwise maintain previous value
1353       1/1                rvfi_rd_addr_d  = rvfi_rd_addr_q;
1354       1/1                rvfi_rd_wdata_d = rvfi_rd_wdata_q;
1355                        end
1356                      end
1357                    
1358                      // RD write register is refreshed only once per cycle and
1359                      // then it is kept stable for the cycle.
1360                      always_ff @(posedge clk_i or negedge rst_ni) begin
1361       1/1              if (!rst_ni) begin
1362       1/1                rvfi_rd_addr_q    <= '0;
1363       1/1                rvfi_rd_wdata_q   <= '0;
1364                        end else begin
1365       0/1     ==>        rvfi_rd_addr_q    <= rvfi_rd_addr_d;
1366       0/1     ==>        rvfi_rd_wdata_q   <= rvfi_rd_wdata_d;
1367                        end
1368                      end
1369                    
1370                      // rvfi_intr must be set for first instruction that is part of a trap handler.
1371                      // On the first cycle of a new instruction see if a trap PC was set by the previous instruction,
1372                      // otherwise maintain value.
1373                      assign rvfi_intr_d = instr_first_cycle_id ? rvfi_set_trap_pc_q : rvfi_intr_q;
1374                    
1375                      always_comb begin
1376       1/1              rvfi_set_trap_pc_d = rvfi_set_trap_pc_q;
1377                    
1378       1/1              if (pc_set && pc_mux_id == PC_EXC &&
1379                            (exc_pc_mux_id == EXC_PC_EXC || exc_pc_mux_id == EXC_PC_IRQ)) begin
1380                          // PC is set to enter a trap handler
1381       0/1     ==>        rvfi_set_trap_pc_d = 1'b1;
1382       1/1              end else if (rvfi_set_trap_pc_q && instr_id_done) begin
1383                          // first instruction has been executed after PC is set to trap handler
1384       0/1     ==>        rvfi_set_trap_pc_d = 1'b0;
1385                        end
                        MISSING_ELSE
1386                      end
1387                    
1388                      always_ff @(posedge clk_i or negedge rst_ni) begin
1389       1/1              if (!rst_ni) begin
1390       1/1                rvfi_set_trap_pc_q <= 1'b0;
1391       1/1                rvfi_intr_q        <= 1'b0;
1392                        end else begin
1393       0/1     ==>        rvfi_set_trap_pc_q <= rvfi_set_trap_pc_d;
1394       0/1     ==>        rvfi_intr_q        <= rvfi_intr_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_core

               Total   Covered  Percent
Conditions         28        4    14.29
Logical            28        4    14.29
Non-Logical         0        0
Event               0        0

 LINE       1306
 EXPRESSION (rf_ren_a ? multdiv_operand_a_ex : '0)
             ----1---

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       1307
 EXPRESSION (rf_ren_a ? rf_raddr_a : '0)
             ----1---

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       1308
 EXPRESSION (rf_ren_b ? multdiv_operand_b_ex : '0)
             ----1---

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       1309
 EXPRESSION (rf_ren_b ? rf_raddr_b : '0)
             ----1---

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       1378
 EXPRESSION (pc_set && (pc_mux_id == PC_EXC) && ((exc_pc_mux_id == EXC_PC_EXC) || (exc_pc_mux_id == EXC_PC_IRQ)))
             ---1--    ----------2----------    --------------------------------3-------------------------------

-1- -2- -3- Status
 0   1   1  Not Covered
 1   0   1  Covered
 1   1   0  Not Covered
 1   1   1  Not Covered

 LINE       1378
 SUB-EXPRESSION ((exc_pc_mux_id == EXC_PC_EXC) || (exc_pc_mux_id == EXC_PC_IRQ))
                 --------------1--------------    --------------2--------------

-1- -2- Status
 0   0  Not Covered
 0   1  Covered
 1   0  Not Covered

 LINE       1382
 EXPRESSION (rvfi_set_trap_pc_q && instr_id_done)
             ---------1--------    ------2------

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       1205
 EXPRESSION (pc_set ? branch_target_ex : pc_if)
             ---1--

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       1207
 EXPRESSION (data_we_o ? rvfi_mem_mask_int : 4'b0)
             ----1----

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       900
 EXPRESSION (rf_we_wb ? rf_wdata_wb : rf_wdata_lsu)
             ----1---

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       910
 EXPRESSION (csr_access ? alu_operand_b_ex[11:0] : 12'b0)
             -----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       1373
 EXPRESSION (instr_first_cycle_id ? rvfi_set_trap_pc_q : rvfi_intr_q)
             ----------1---------

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_core
                Total Covered Percent 
Totals          263   0       0.00    
Total Bits      5412  0       0.00    
Total Bits 0->1 2706  0       0.00    
Total Bits 1->0 2706  0       0.00    

                             
Ports          72   0 0.00   
Port Bits      2064 0 0.00   
Port Bits 0->1 1032 0 0.00   
Port Bits 1->0 1032 0 0.00   

                               
Signals          191  0 0.00   
Signal Bits      3348 0 0.00   
Signal Bits 0->1 1674 0 0.00   
Signal Bits 1->0 1674 0 0.00   

Port Details
                                  Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                             No     No          No          INPUT     
rst_ni                            No     No          No          INPUT     
hart_id_i[31:0]                   No     No          No          INPUT     
boot_addr_i[31:0]                 No     No          No          INPUT     
instr_req_o                       No     No          No          OUTPUT    
instr_gnt_i                       No     No          No          INPUT     
instr_rvalid_i                    No     No          No          INPUT     
instr_addr_o[31:0]                No     No          No          OUTPUT    
instr_rdata_i[31:0]               No     No          No          INPUT     
instr_err_i                       No     No          No          INPUT     
data_req_o                        No     No          No          OUTPUT    
data_gnt_i                        No     No          No          INPUT     
data_rvalid_i                     No     No          No          INPUT     
data_we_o                         No     No          No          OUTPUT    
data_be_o[3:0]                    No     No          No          OUTPUT    
data_addr_o[31:0]                 No     No          No          OUTPUT    
data_wdata_o[31:0]                No     No          No          OUTPUT    
data_rdata_i[31:0]                No     No          No          INPUT     
data_err_i                        No     No          No          INPUT     
dummy_instr_id_o                  No     No          No          OUTPUT    
rf_raddr_a_o[4:0]                 No     No          No          OUTPUT    
rf_raddr_b_o[4:0]                 No     No          No          OUTPUT    
rf_waddr_wb_o[4:0]                No     No          No          OUTPUT    
rf_we_wb_o                        No     No          No          OUTPUT    
rf_wdata_wb_ecc_o[31:0]           No     No          No          OUTPUT    
rf_rdata_a_ecc_i[31:0]            No     No          No          INPUT     
rf_rdata_b_ecc_i[31:0]            No     No          No          INPUT     
ic_tag_req_o[1:0]                 No     No          No          OUTPUT    
ic_tag_write_o                    No     No          No          OUTPUT    
ic_tag_addr_o[7:0]                No     No          No          OUTPUT    
ic_tag_wdata_o[21:0]              No     No          No          OUTPUT    
ic_data_req_o[1:0]                No     No          No          OUTPUT    
ic_data_write_o                   No     No          No          OUTPUT    
ic_data_addr_o[7:0]               No     No          No          OUTPUT    
ic_data_wdata_o[63:0]             No     No          No          OUTPUT    
irq_software_i                    No     No          No          INPUT     
irq_timer_i                       No     No          No          INPUT     
irq_external_i                    No     No          No          INPUT     
irq_fast_i[14:0]                  No     No          No          INPUT     
irq_nm_i                          No     No          No          INPUT     
irq_pending_o                     No     No          No          OUTPUT    
debug_req_i                       No     No          No          INPUT     
crash_dump_o.exception_addr[31:0] No     No          No          OUTPUT    
crash_dump_o.last_data_addr[31:0] No     No          No          OUTPUT    
crash_dump_o.next_pc[31:0]        No     No          No          OUTPUT    
crash_dump_o.current_pc[31:0]     No     No          No          OUTPUT    
rvfi_valid                        No     No          No          OUTPUT    
rvfi_order[63:0]                  No     No          No          OUTPUT    
rvfi_insn[31:0]                   No     No          No          OUTPUT    
rvfi_trap                         No     No          No          OUTPUT    
rvfi_halt                         No     No          No          OUTPUT    
rvfi_intr                         No     No          No          OUTPUT    
rvfi_mode[1:0]                    No     No          No          OUTPUT    
rvfi_ixl[1:0]                     No     No          No          OUTPUT    
rvfi_rs1_addr[4:0]                No     No          No          OUTPUT    
rvfi_rs2_addr[4:0]                No     No          No          OUTPUT    
rvfi_rs3_addr[4:0]                No     No          No          OUTPUT    
rvfi_rs1_rdata[31:0]              No     No          No          OUTPUT    
rvfi_rs2_rdata[31:0]              No     No          No          OUTPUT    
rvfi_rs3_rdata[31:0]              No     No          No          OUTPUT    
rvfi_rd_addr[4:0]                 No     No          No          OUTPUT    
rvfi_rd_wdata[31:0]               No     No          No          OUTPUT    
rvfi_pc_rdata[31:0]               No     No          No          OUTPUT    
rvfi_pc_wdata[31:0]               No     No          No          OUTPUT    
rvfi_mem_addr[31:0]               No     No          No          OUTPUT    
rvfi_mem_rmask[3:0]               No     No          No          OUTPUT    
rvfi_mem_wmask[3:0]               No     No          No          OUTPUT    
rvfi_mem_rdata[31:0]              No     No          No          OUTPUT    
rvfi_mem_wdata[31:0]              No     No          No          OUTPUT    
alert_minor_o                     No     No          No          OUTPUT    
alert_major_o                     No     No          No          OUTPUT    
core_busy_o                       No     No          No          OUTPUT    

Signal Details
                                           Toggle Toggle 1->0 Toggle 0->1 
dummy_instr_id                             No     No          No          
instr_valid_id                             No     No          No          
instr_new_id                               No     No          No          
instr_rdata_id[31:0]                       No     No          No          
instr_rdata_alu_id[31:0]                   No     No          No          
instr_rdata_c_id[15:0]                     No     No          No          
instr_is_compressed_id                     No     No          No          
instr_perf_count_id                        No     No          No          
instr_bp_taken_id                          No     No          No          
instr_fetch_err                            No     No          No          
instr_fetch_err_plus2                      No     No          No          
illegal_c_insn_id                          No     No          No          
pc_if[31:0]                                No     No          No          
pc_id[31:0]                                No     No          No          
pc_wb[31:0]                                No     No          No          
imd_val_we_ex[1:0]                         No     No          No          
data_ind_timing                            No     No          No          
dummy_instr_en                             No     No          No          
dummy_instr_mask[2:0]                      No     No          No          
dummy_instr_seed_en                        No     No          No          
dummy_instr_seed[31:0]                     No     No          No          
icache_enable                              No     No          No          
icache_inval                               No     No          No          
pc_mismatch_alert                          No     No          No          
csr_shadow_err                             No     No          No          
instr_first_cycle_id                       No     No          No          
instr_valid_clear                          No     No          No          
pc_set                                     No     No          No          
pc_set_spec                                No     No          No          
nt_branch_mispredict                       No     No          No          
pc_mux_id[2:0]                             No     No          No          
exc_pc_mux_id[1:0]                         No     No          No          
exc_cause[5:0]                             No     No          No          
lsu_load_err                               No     No          No          
lsu_store_err                              No     No          No          
lsu_addr_incr_req                          No     No          No          
lsu_addr_last[31:0]                        No     No          No          
branch_target_ex[31:0]                     No     No          No          
branch_decision                            No     No          No          
ctrl_busy                                  No     No          No          
if_busy                                    No     No          No          
lsu_busy                                   No     No          No          
rf_raddr_a[4:0]                            No     No          No          
rf_rdata_a[31:0]                           No     No          No          
rf_raddr_b[4:0]                            No     No          No          
rf_rdata_b[31:0]                           No     No          No          
rf_ren_a                                   No     No          No          
rf_ren_b                                   No     No          No          
rf_waddr_wb[4:0]                           No     No          No          
rf_wdata_wb[31:0]                          No     No          No          
rf_wdata_fwd_wb[31:0]                      No     No          No          
rf_wdata_lsu[31:0]                         No     No          No          
rf_we_wb                                   No     No          No          
rf_we_lsu                                  No     No          No          
rf_ecc_err_comb                            No     No          No          
rf_waddr_id[4:0]                           No     No          No          
rf_wdata_id[31:0]                          No     No          No          
rf_we_id                                   No     No          No          
rf_rd_a_wb_match                           No     No          No          
rf_rd_b_wb_match                           No     No          No          
alu_operator_ex[5:0]                       No     No          No          
alu_operand_a_ex[31:0]                     No     No          No          
alu_operand_b_ex[31:0]                     No     No          No          
bt_a_operand[31:0]                         No     No          No          
bt_b_operand[31:0]                         No     No          No          
alu_adder_result_ex[31:0]                  No     No          No          
result_ex[31:0]                            No     No          No          
mult_en_ex                                 No     No          No          
div_en_ex                                  No     No          No          
mult_sel_ex                                No     No          No          
div_sel_ex                                 No     No          No          
multdiv_operator_ex[1:0]                   No     No          No          
multdiv_signed_mode_ex[1:0]                No     No          No          
multdiv_operand_a_ex[31:0]                 No     No          No          
multdiv_operand_b_ex[31:0]                 No     No          No          
multdiv_ready_id                           No     No          No          
csr_access                                 No     No          No          
csr_op[1:0]                                No     No          No          
csr_op_en                                  No     No          No          
csr_addr[11:0]                             No     No          No          
csr_rdata[31:0]                            No     No          No          
csr_wdata[31:0]                            No     No          No          
illegal_csr_insn_id                        No     No          No          
lsu_we                                     No     No          No          
lsu_type[1:0]                              No     No          No          
lsu_sign_ext                               No     No          No          
lsu_req                                    No     No          No          
lsu_wdata[31:0]                            No     No          No          
lsu_req_done                               No     No          No          
id_in_ready                                No     No          No          
ex_valid                                   No     No          No          
lsu_resp_valid                             No     No          No          
lsu_resp_err                               No     No          No          
instr_req_int                              No     No          No          
en_wb                                      No     No          No          
instr_type_wb[1:0]                         No     No          No          
ready_wb                                   No     No          No          
rf_write_wb                                No     No          No          
outstanding_load_wb                        No     No          No          
outstanding_store_wb                       No     No          No          
nmi_mode                                   No     No          No          
irqs.irq_fast[14:0]                        No     No          No          
irqs.irq_external                          No     No          No          
irqs.irq_timer                             No     No          No          
irqs.irq_software                          No     No          No          
csr_mstatus_mie                            No     No          No          
csr_mepc[31:0]                             No     No          No          
csr_depc[31:0]                             No     No          No          
csr_pmp_mseccfg.mml                        No     No          No          
csr_pmp_mseccfg.mmwp                       No     No          No          
csr_pmp_mseccfg.rlb                        No     No          No          
instr_req_out                              No     No          No          
data_req_out                               No     No          No          
csr_save_if                                No     No          No          
csr_save_id                                No     No          No          
csr_save_wb                                No     No          No          
csr_restore_mret_id                        No     No          No          
csr_restore_dret_id                        No     No          No          
csr_save_cause                             No     No          No          
csr_mtvec_init                             No     No          No          
csr_mtvec[31:0]                            No     No          No          
csr_mtval[31:0]                            No     No          No          
csr_mstatus_tw                             No     No          No          
priv_mode_id[1:0]                          No     No          No          
priv_mode_if[1:0]                          No     No          No          
priv_mode_lsu[1:0]                         No     No          No          
debug_mode                                 No     No          No          
debug_cause[2:0]                           No     No          No          
debug_csr_save                             No     No          No          
debug_single_step                          No     No          No          
debug_ebreakm                              No     No          No          
debug_ebreaku                              No     No          No          
trigger_match                              No     No          No          
instr_id_done                              No     No          No          
instr_done_wb                              No     No          No          
perf_instr_ret_wb                          No     No          No          
perf_instr_ret_compressed_wb               No     No          No          
perf_iside_wait                            No     No          No          
perf_dside_wait                            No     No          No          
perf_mul_wait                              No     No          No          
perf_div_wait                              No     No          No          
perf_jump                                  No     No          No          
perf_branch                                No     No          No          
perf_tbranch                               No     No          No          
perf_load                                  No     No          No          
perf_store                                 No     No          No          
illegal_insn_id                            No     No          No          
unused_illegal_insn_id                     No     No          No          
rvfi_instr_new_wb                          No     No          No          
rvfi_intr_d                                No     No          No          
rvfi_intr_q                                No     No          No          
rvfi_set_trap_pc_d                         No     No          No          
rvfi_set_trap_pc_q                         No     No          No          
rvfi_insn_id[31:0]                         No     No          No          
rvfi_rs1_addr_d[4:0]                       No     No          No          
rvfi_rs1_addr_q[4:0]                       No     No          No          
rvfi_rs2_addr_d[4:0]                       No     No          No          
rvfi_rs2_addr_q[4:0]                       No     No          No          
rvfi_rs3_addr_d[4:0]                       No     No          No          
rvfi_rs1_data_d[31:0]                      No     No          No          
rvfi_rs1_data_q[31:0]                      No     No          No          
rvfi_rs2_data_d[31:0]                      No     No          No          
rvfi_rs2_data_q[31:0]                      No     No          No          
rvfi_rs3_data_d[31:0]                      No     No          No          
rvfi_rd_addr_wb[4:0]                       No     No          No          
rvfi_rd_addr_q[4:0]                        No     No          No          
rvfi_rd_addr_d[4:0]                        No     No          No          
rvfi_rd_wdata_wb[31:0]                     No     No          No          
rvfi_rd_wdata_d[31:0]                      No     No          No          
rvfi_rd_wdata_q[31:0]                      No     No          No          
rvfi_rd_we_wb                              No     No          No          
rvfi_mem_mask_int[3:0]                     No     No          No          
rvfi_mem_rdata_d[31:0]                     No     No          No          
rvfi_mem_rdata_q[31:0]                     No     No          No          
rvfi_mem_wdata_d[31:0]                     No     No          No          
rvfi_mem_wdata_q[31:0]                     No     No          No          
rvfi_mem_addr_d[31:0]                      No     No          No          
rvfi_mem_addr_q[31:0]                      No     No          No          
outstanding_load_resp                      No     No          No          
outstanding_store_resp                     No     No          No          
outstanding_load_id                        No     No          No          
outstanding_store_id                       No     No          No          
gen_no_regfile_ecc.unused_rf_ren_a         No     No          No          
gen_no_regfile_ecc.unused_rf_ren_b         No     No          No          
gen_no_regfile_ecc.unused_rf_rd_a_wb_match No     No          No          
gen_no_regfile_ecc.unused_rf_rd_b_wb_match No     No          No          
g_no_pmp.unused_priv_lvl_if[1:0]           No     No          No          
g_no_pmp.unused_priv_lvl_ls[1:0]           No     No          No          
g_no_pmp.unused_csr_pmp_mseccfg.mml        No     No          No          
g_no_pmp.unused_csr_pmp_mseccfg.mmwp       No     No          No          
g_no_pmp.unused_csr_pmp_mseccfg.rlb        No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_core
         Line No. Total Covered Percent 
Branches          46    13      28.26   
TERNARY  900      2     0       0.00    
TERNARY  1373     2     1       50.00   
IF       1255     2     1       50.00   
IF       1266     2     1       50.00   
IF       1274     2     1       50.00   
CASE     1286     4     1       25.00   
IF       1295     2     1       50.00   
IF       1305     9     1       11.11   
IF       1322     2     1       50.00   
IF       1337     4     1       25.00   
IF       1361     2     1       50.00   
IF       1378     3     1       33.33   
IF       1389     2     1       50.00   
IF       1165     8     1       12.50   


900          assign rvfi_rd_wdata_wb = rf_we_wb ? rf_wdata_wb : rf_wdata_lsu;
                                                -1-  
                                                ==>  
                                                ==>  

Branches:

-1- Status      
1   Not Covered 
0   Not Covered 


1373         assign rvfi_intr_d = instr_first_cycle_id ? rvfi_set_trap_pc_q : rvfi_intr_q;
                                                       -1-  
                                                       ==>  
                                                       ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


1255           if (instr_first_cycle_id) begin
               -1-  
1256             rvfi_mem_addr_d  = alu_adder_result_ex;
                 ==>
1257             rvfi_mem_wdata_d = lsu_wdata;
1258           end else begin
1259             rvfi_mem_addr_d  = rvfi_mem_addr_q;
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


1266           if (lsu_resp_valid) begin
               -1-  
1267             rvfi_mem_rdata_d = rf_wdata_lsu;
                 ==>
1268           end else begin
1269             rvfi_mem_rdata_d = rvfi_mem_rdata_q;
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


1274           if (!rst_ni) begin
               -1-  
1275             rvfi_mem_addr_q  <= '0;
                 ==>
1276             rvfi_mem_rdata_q <= '0;
1277             rvfi_mem_wdata_q <= '0;
1278           end else begin
1279             rvfi_mem_addr_q  <= rvfi_mem_addr_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


1286           unique case (lsu_type)
                      -1-  
1287             2'b00:   rvfi_mem_mask_int = 4'b1111;
                 ==>
1288             2'b01:   rvfi_mem_mask_int = 4'b0011;
                 ==>
1289             2'b10:   rvfi_mem_mask_int = 4'b0001;
                 ==>
1290             default: rvfi_mem_mask_int = 4'b0000;
                 ==>

Branches:

-1-     Status      
2'b00   Covered     
2'b01   Not Covered 
2'b10   Not Covered 
default Not Covered 


1295           if (instr_is_compressed_id) begin
               -1-  
1296             rvfi_insn_id = {16'b0, instr_rdata_c_id};
                 ==>
1297           end else begin
1298             rvfi_insn_id = instr_rdata_id;
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


1305           if (instr_first_cycle_id) begin
               -1-  
1306             rvfi_rs1_data_d = rf_ren_a ? multdiv_operand_a_ex : '0;
                                            -2-  
                                            ==>  
                                            ==>  
1307             rvfi_rs1_addr_d = rf_ren_a ? rf_raddr_a : '0;
                                            -3-  
                                            ==>  
                                            ==>  
1308             rvfi_rs2_data_d = rf_ren_b ? multdiv_operand_b_ex : '0;
                                            -4-  
                                            ==>  
                                            ==>  
1309             rvfi_rs2_addr_d = rf_ren_b ? rf_raddr_b : '0;
                                            -5-  
                                            ==>  
                                            ==>  
1310             rvfi_rs3_data_d = '0;
1311             rvfi_rs3_addr_d = '0;
1312           end else begin
1313             rvfi_rs1_data_d = rvfi_rs1_data_q;
                 ==>

Branches:

-1- -2- -3- -4- -5- Status      
1   1   -   -   -   Not Covered 
1   0   -   -   -   Not Covered 
1   -   1   -   -   Not Covered 
1   -   0   -   -   Not Covered 
1   -   -   1   -   Not Covered 
1   -   -   0   -   Not Covered 
1   -   -   -   1   Not Covered 
1   -   -   -   0   Not Covered 
0   -   -   -   -   Covered     


1322           if (!rst_ni) begin
               -1-  
1323             rvfi_rs1_data_q <= '0;
                 ==>
1324             rvfi_rs1_addr_q <= '0;
1325             rvfi_rs2_data_q <= '0;
1326             rvfi_rs2_addr_q <= '0;
1327       
1328           end else begin
1329             rvfi_rs1_data_q <= rvfi_rs1_data_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


1337           if(rvfi_rd_we_wb) begin
               -1-  
1338             // Capture address/data of write to register file
1339             rvfi_rd_addr_d  = rvfi_rd_addr_wb;
1340             // If writing to x0 zero write data as required by RVFI specification
1341             if(rvfi_rd_addr_wb == 5'b0) begin
                 -2-  
1342               rvfi_rd_wdata_d = '0;
                   ==>
1343             end else begin
1344               rvfi_rd_wdata_d = rvfi_rd_wdata_wb;
                   ==>
1345             end
1346           end else if(rvfi_instr_new_wb) begin
                        -3-  
1347             // If no RF write but new instruction in Writeback (when present) or ID/EX (when no writeback
1348             // stage present) then zero RF write address/data as required by RVFI specification
1349             rvfi_rd_addr_d  = '0;
                 ==>
1350             rvfi_rd_wdata_d = '0;
1351           end else begin
1352             // Otherwise maintain previous value
1353             rvfi_rd_addr_d  = rvfi_rd_addr_q;
                 ==>

Branches:

-1- -2- -3- Status      
1   1   -   Not Covered 
1   0   -   Not Covered 
0   -   1   Not Covered 
0   -   0   Covered     


1361           if (!rst_ni) begin
               -1-  
1362             rvfi_rd_addr_q    <= '0;
                 ==>
1363             rvfi_rd_wdata_q   <= '0;
1364           end else begin
1365             rvfi_rd_addr_q    <= rvfi_rd_addr_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


1378           if (pc_set && pc_mux_id == PC_EXC &&
               -1-  
1379               (exc_pc_mux_id == EXC_PC_EXC || exc_pc_mux_id == EXC_PC_IRQ)) begin
1380             // PC is set to enter a trap handler
1381             rvfi_set_trap_pc_d = 1'b1;
                 ==>
1382           end else if (rvfi_set_trap_pc_q && instr_id_done) begin
                        -2-  
1383             // first instruction has been executed after PC is set to trap handler
1384             rvfi_set_trap_pc_d = 1'b0;
                 ==>
1385           end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Not Covered 
0   1   Not Covered 
0   0   Covered     


1389           if (!rst_ni) begin
               -1-  
1390             rvfi_set_trap_pc_q <= 1'b0;
                 ==>
1391             rvfi_intr_q        <= 1'b0;
1392           end else begin
1393             rvfi_set_trap_pc_q <= rvfi_set_trap_pc_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


1165             if (!rst_ni) begin
                 -1-  
1166               rvfi_stage_halt[i]      <= '0;
                   ==>
1167               rvfi_stage_trap[i]      <= '0;
1168               rvfi_stage_intr[i]      <= '0;
1169               rvfi_stage_order[i]     <= '0;
1170               rvfi_stage_insn[i]      <= '0;
1171               rvfi_stage_mode[i]      <= {PRIV_LVL_M};
1172               rvfi_stage_ixl[i]       <= CSR_MISA_MXL;
1173               rvfi_stage_rs1_addr[i]  <= '0;
1174               rvfi_stage_rs2_addr[i]  <= '0;
1175               rvfi_stage_rs3_addr[i]  <= '0;
1176               rvfi_stage_pc_rdata[i]  <= '0;
1177               rvfi_stage_pc_wdata[i]  <= '0;
1178               rvfi_stage_mem_rmask[i] <= '0;
1179               rvfi_stage_mem_wmask[i] <= '0;
1180               rvfi_stage_valid[i]     <= '0;
1181               rvfi_stage_rs1_rdata[i] <= '0;
1182               rvfi_stage_rs2_rdata[i] <= '0;
1183               rvfi_stage_rs3_rdata[i] <= '0;
1184               rvfi_stage_rd_wdata[i]  <= '0;
1185               rvfi_stage_rd_addr[i]   <= '0;
1186               rvfi_stage_mem_rdata[i] <= '0;
1187               rvfi_stage_mem_wdata[i] <= '0;
1188               rvfi_stage_mem_addr[i]  <= '0;
1189             end else begin
1190               rvfi_stage_valid[i] <= rvfi_stage_valid_d[i];
1191       
1192               if (i == 0) begin
                   -2-  
1193                 if(instr_id_done) begin
                     -3-  
1194                   rvfi_stage_halt[i]      <= '0;
1195                   rvfi_stage_trap[i]      <= illegal_insn_id;
1196                   rvfi_stage_intr[i]      <= rvfi_intr_d;
1197                   rvfi_stage_order[i]     <= rvfi_stage_order[i] + 64'(rvfi_stage_valid_d[i]);
1198                   rvfi_stage_insn[i]      <= rvfi_insn_id;
1199                   rvfi_stage_mode[i]      <= {priv_mode_id};
1200                   rvfi_stage_ixl[i]       <= CSR_MISA_MXL;
1201                   rvfi_stage_rs1_addr[i]  <= rvfi_rs1_addr_d;
1202                   rvfi_stage_rs2_addr[i]  <= rvfi_rs2_addr_d;
1203                   rvfi_stage_rs3_addr[i]  <= rvfi_rs3_addr_d;
1204                   rvfi_stage_pc_rdata[i]  <= pc_id;
1205                   rvfi_stage_pc_wdata[i]  <= pc_set ? branch_target_ex : pc_if;
                                                         -4-  
                                                         ==>  
                                                         ==>  
1206                   rvfi_stage_mem_rmask[i] <= rvfi_mem_mask_int;
1207                   rvfi_stage_mem_wmask[i] <= data_we_o ? rvfi_mem_mask_int : 4'b0000;
                                                            -5-  
                                                            ==>  
                                                            ==>  
1208                   rvfi_stage_rs1_rdata[i] <= rvfi_rs1_data_d;
1209                   rvfi_stage_rs2_rdata[i] <= rvfi_rs2_data_d;
1210                   rvfi_stage_rs3_rdata[i] <= rvfi_rs3_data_d;
1211                   rvfi_stage_rd_addr[i]   <= rvfi_rd_addr_d;
1212                   rvfi_stage_rd_wdata[i]  <= rvfi_rd_wdata_d;
1213                   rvfi_stage_mem_rdata[i] <= rvfi_mem_rdata_d;
1214                   rvfi_stage_mem_wdata[i] <= rvfi_mem_wdata_d;
1215                   rvfi_stage_mem_addr[i]  <= rvfi_mem_addr_d;
1216                 end
                     MISSING_ELSE
                     ==>
1217               end else begin
1218                 if(instr_done_wb) begin
                     -6-  
1219                   rvfi_stage_halt[i]      <= rvfi_stage_halt[i-1];
                       ==>
1220                   rvfi_stage_trap[i]      <= rvfi_stage_trap[i-1];
1221                   rvfi_stage_intr[i]      <= rvfi_stage_intr[i-1];
1222                   rvfi_stage_order[i]     <= rvfi_stage_order[i-1];
1223                   rvfi_stage_insn[i]      <= rvfi_stage_insn[i-1];
1224                   rvfi_stage_mode[i]      <= rvfi_stage_mode[i-1];
1225                   rvfi_stage_ixl[i]       <= rvfi_stage_ixl[i-1];
1226                   rvfi_stage_rs1_addr[i]  <= rvfi_stage_rs1_addr[i-1];
1227                   rvfi_stage_rs2_addr[i]  <= rvfi_stage_rs2_addr[i-1];
1228                   rvfi_stage_rs3_addr[i]  <= rvfi_stage_rs3_addr[i-1];
1229                   rvfi_stage_pc_rdata[i]  <= rvfi_stage_pc_rdata[i-1];
1230                   rvfi_stage_pc_wdata[i]  <= rvfi_stage_pc_wdata[i-1];
1231                   rvfi_stage_mem_rmask[i] <= rvfi_stage_mem_rmask[i-1];
1232                   rvfi_stage_mem_wmask[i] <= rvfi_stage_mem_wmask[i-1];
1233                   rvfi_stage_rs1_rdata[i] <= rvfi_stage_rs1_rdata[i-1];
1234                   rvfi_stage_rs2_rdata[i] <= rvfi_stage_rs2_rdata[i-1];
1235                   rvfi_stage_rs3_rdata[i] <= rvfi_stage_rs3_rdata[i-1];
1236                   rvfi_stage_mem_wdata[i] <= rvfi_stage_mem_wdata[i-1];
1237                   rvfi_stage_mem_addr[i]  <= rvfi_stage_mem_addr[i-1];
1238       
1239                   // For 2 RVFI_STAGES/Writeback Stage ignore first stage flops for rd_addr, rd_wdata and
1240                   // mem_rdata. For RF write addr/data actual write happens in writeback so capture
1241                   // address/data there. For mem_rdata that is only available from the writeback stage.
1242                   // Previous stage flops still exist in RTL as they are used by the non writeback config
1243                   rvfi_stage_rd_addr[i]   <= rvfi_rd_addr_d;
1244                   rvfi_stage_rd_wdata[i]  <= rvfi_rd_wdata_d;
1245                   rvfi_stage_mem_rdata[i] <= rvfi_mem_rdata_d;
1246                 end
                     MISSING_ELSE
                     ==>

Branches:

-1- -2- -3- -4- -5- -6- Status      
1   -   -   -   -   -   Covered     
0   1   1   1   -   -   Not Covered 
0   1   1   0   -   -   Not Covered 
0   1   1   -   1   -   Not Covered 
0   1   1   -   0   -   Not Covered 
0   1   0   -   -   -   Not Covered 
0   0   -   -   -   1   Not Covered 
0   0   -   -   -   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_core
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       6     6         100.00  1                 16.67   
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            6     6         100.00  1                 16.67   



-------------------------------------------------------------------------------

Assertion Details

Name                                           Attempts Real Successes Failures Incomplete 
IbexCsrOpValid                                 3        0              0        0          
IbexCsrWdataIntKnown                           3        0              0        0          
IbexCsrWdataIntKnownKnownEnable                3        0              0        0          
IllegalParamSecure                             1        1              0        0          
NoMemResponseWithoutPendingAccess              3        0              0        0          
gen_no_wb_stage.NoMemRFWriteWithoutPendingLoad 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.58  43.66  14.29   0.00  28.26  16.67 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 13.11  28.45  19.12   0.00  16.96   1.01 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME      
 20.58  43.66  14.29   0.00  28.26  16.67 ibex_core 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 24.31  57.14 --       0.09  40.00   0.00 u_ibex_top 


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME              
 16.35  37.50  23.08   0.00  21.15   0.00 cs_registers_i    
 18.04  41.75  21.67   0.00  26.79   0.00 ex_block_i        
  8.11  19.83  12.21   0.00   8.53   0.00 id_stage_i        
 21.85  26.19  52.27   0.00  30.77   0.00 if_stage_i        
  8.62  28.30   0.00   0.00  14.81   0.00 load_store_unit_i 
  8.21  23.53   5.88   0.00  11.63   0.00 u_fcov_bind       
 25.00 --      50.00   0.00  50.00   0.00 wb_stage_i        



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_csr
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_csr.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                                
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstatus_csr      
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mepc_csr         
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mie_csr          
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mscratch_csr     
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mcause_csr       
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtval_csr        
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtvec_csr        
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dcsr_csr         
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_depc_csr         
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch0_csr    
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch1_csr    
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_csr       
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_epc_csr   
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_cause_csr 
 20.83  50.00 --       0.00  33.33   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_cpuctrl_csr      



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_csr ( parameter Width=6,ShadowCopy=0,ResetValue ) 
Toggle Coverage for Module self-instances : 
tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstatus_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mcause_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_cause_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_cpuctrl_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      44    0       0.00    
Total Bits 0->1 22    0       0.00    
Total Bits 1->0 22    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      32 0 0.00   
Port Bits 0->1 16 0 0.00   
Port Bits 1->0 16 0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      12 0 0.00   
Signal Bits 0->1 6  0 0.00   
Signal Bits 1->0 6  0 0.00   

Port Details
               Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i          No     No          No          INPUT     
rst_ni         No     No          No          INPUT     
wr_data_i[5:0] No     No          No          INPUT     
wr_en_i        No     No          No          INPUT     
rd_data_o[5:0] No     No          No          OUTPUT    
rd_error_o     No     No          No          OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
rdata_q[5:0] No     No          No          


-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_csr ( parameter Width=32,ShadowCopy=0,ResetValue ) 
Toggle Coverage for Module self-instances : 
tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mepc_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mscratch_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtval_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtvec_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dcsr_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_depc_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch0_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch1_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_epc_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_csr ( parameter Width=18,ShadowCopy=0,ResetValue=0 ) 
Toggle Coverage for Module self-instances : 
tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mie_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      116   0       0.00    
Total Bits 0->1 58    0       0.00    
Total Bits 1->0 58    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      80 0 0.00   
Port Bits 0->1 40 0 0.00   
Port Bits 1->0 40 0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      36 0 0.00   
Signal Bits 0->1 18 0 0.00   
Signal Bits 1->0 18 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[17:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[17:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[17:0] No     No          No          


-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_csr ( parameter Width=3,ShadowCopy=0,ResetValue=4 ) 
Toggle Coverage for Module self-instances : 
tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_csr
----------------
SCORE  TOGGLE 
 20.83   0.00 

                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      26    0       0.00    
Total Bits 0->1 13    0       0.00    
Total Bits 1->0 13    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      20 0 0.00   
Port Bits 0->1 10 0 0.00   
Port Bits 1->0 10 0 0.00   

                            
Signals          1 0 0.00   
Signal Bits      6 0 0.00   
Signal Bits 0->1 3 0 0.00   
Signal Bits 1->0 3 0 0.00   

Port Details
               Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i          No     No          No          INPUT     
rst_ni         No     No          No          INPUT     
wr_data_i[2:0] No     No          No          INPUT     
wr_en_i        No     No          No          INPUT     
rd_data_o[2:0] No     No          No          OUTPUT    
rd_error_o     No     No          No          OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
rdata_q[2:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 45       0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstatus_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstatus_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstatus_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      44    0       0.00    
Total Bits 0->1 22    0       0.00    
Total Bits 1->0 22    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      32 0 0.00   
Port Bits 0->1 16 0 0.00   
Port Bits 1->0 16 0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      12 0 0.00   
Signal Bits 0->1 6  0 0.00   
Signal Bits 1->0 6  0 0.00   

Port Details
               Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i          No     No          No          INPUT     
rst_ni         No     No          No          INPUT     
wr_data_i[5:0] No     No          No          INPUT     
wr_en_i        No     No          No          INPUT     
rd_data_o[5:0] No     No          No          OUTPUT    
rd_error_o     No     No          No          OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
rdata_q[5:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstatus_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstatus_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mepc_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mepc_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mepc_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mepc_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mepc_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mie_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mie_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mie_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      116   0       0.00    
Total Bits 0->1 58    0       0.00    
Total Bits 1->0 58    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      80 0 0.00   
Port Bits 0->1 40 0 0.00   
Port Bits 1->0 40 0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      36 0 0.00   
Signal Bits 0->1 18 0 0.00   
Signal Bits 1->0 18 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[17:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[17:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[17:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mie_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mie_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mscratch_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mscratch_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mscratch_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mscratch_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mscratch_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mcause_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mcause_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mcause_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      44    0       0.00    
Total Bits 0->1 22    0       0.00    
Total Bits 1->0 22    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      32 0 0.00   
Port Bits 0->1 16 0 0.00   
Port Bits 1->0 16 0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      12 0 0.00   
Signal Bits 0->1 6  0 0.00   
Signal Bits 1->0 6  0 0.00   

Port Details
               Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i          No     No          No          INPUT     
rst_ni         No     No          No          INPUT     
wr_data_i[5:0] No     No          No          INPUT     
wr_en_i        No     No          No          INPUT     
rd_data_o[5:0] No     No          No          OUTPUT    
rd_error_o     No     No          No          OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
rdata_q[5:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mcause_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mcause_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtval_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtval_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtval_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtval_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtval_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtvec_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtvec_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtvec_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtvec_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mtvec_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dcsr_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dcsr_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dcsr_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dcsr_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dcsr_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_depc_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_depc_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_depc_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_depc_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_depc_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch0_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch0_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch0_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch0_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch0_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch1_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch1_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch1_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch1_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_dscratch1_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      26    0       0.00    
Total Bits 0->1 13    0       0.00    
Total Bits 1->0 13    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      20 0 0.00   
Port Bits 0->1 10 0 0.00   
Port Bits 1->0 10 0 0.00   

                            
Signals          1 0 0.00   
Signal Bits      6 0 0.00   
Signal Bits 0->1 3 0 0.00   
Signal Bits 1->0 3 0 0.00   

Port Details
               Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i          No     No          No          INPUT     
rst_ni         No     No          No          INPUT     
wr_data_i[2:0] No     No          No          INPUT     
wr_en_i        No     No          No          INPUT     
rd_data_o[2:0] No     No          No          OUTPUT    
rd_error_o     No     No          No          OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
rdata_q[2:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_epc_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_epc_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_epc_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      200   0       0.00    
Total Bits 0->1 100   0       0.00    
Total Bits 1->0 100   0       0.00    

                            
Ports          6   0 0.00   
Port Bits      136 0 0.00   
Port Bits 0->1 68  0 0.00   
Port Bits 1->0 68  0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      64 0 0.00   
Signal Bits 0->1 32 0 0.00   
Signal Bits 1->0 32 0 0.00   

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i           No     No          No          INPUT     
rst_ni          No     No          No          INPUT     
wr_data_i[31:0] No     No          No          INPUT     
wr_en_i         No     No          No          INPUT     
rd_data_o[31:0] No     No          No          OUTPUT    
rd_error_o      No     No          No          OUTPUT    

Signal Details
              Toggle Toggle 1->0 Toggle 0->1 
rdata_q[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_epc_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_epc_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_cause_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_cause_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_cause_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      44    0       0.00    
Total Bits 0->1 22    0       0.00    
Total Bits 1->0 22    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      32 0 0.00   
Port Bits 0->1 16 0 0.00   
Port Bits 1->0 16 0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      12 0 0.00   
Signal Bits 0->1 6  0 0.00   
Signal Bits 1->0 6  0 0.00   

Port Details
               Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i          No     No          No          INPUT     
rst_ni         No     No          No          INPUT     
wr_data_i[5:0] No     No          No          INPUT     
wr_en_i        No     No          No          INPUT     
rd_data_o[5:0] No     No          No          OUTPUT    
rd_error_o     No     No          No          OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
rdata_q[5:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_cause_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_mstack_cause_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_cpuctrl_csr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 20.83  50.00 --       0.00  33.33   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 20.83  50.00 --       0.00  33.33   0.00 ibex_csr 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_cpuctrl_csr

             Line No.   Total   Covered  Percent
TOTAL                        4        2    50.00
ALWAYS             29        4        2    50.00

28                        always_ff @(posedge clk_i or negedge rst_ni) begin
29         1/1              if (!rst_ni) begin
30         1/1                rdata_q <= ResetValue;
31         0/1     ==>      end else if (wr_en_i) begin
32         0/1     ==>        rdata_q <= wr_data_i;
33                          end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_cpuctrl_csr
                Total Covered Percent 
Totals          7     0       0.00    
Total Bits      44    0       0.00    
Total Bits 0->1 22    0       0.00    
Total Bits 1->0 22    0       0.00    

                           
Ports          6  0 0.00   
Port Bits      32 0 0.00   
Port Bits 0->1 16 0 0.00   
Port Bits 1->0 16 0 0.00   

                             
Signals          1  0 0.00   
Signal Bits      12 0 0.00   
Signal Bits 0->1 6  0 0.00   
Signal Bits 1->0 6  0 0.00   

Port Details
               Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i          No     No          No          INPUT     
rst_ni         No     No          No          INPUT     
wr_data_i[5:0] No     No          No          INPUT     
wr_en_i        No     No          No          INPUT     
rd_data_o[5:0] No     No          No          OUTPUT    
rd_error_o     No     No          No          OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
rdata_q[5:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_cpuctrl_csr
         Line No. Total Covered Percent 
Branches          3     1       33.33   
IF       29       3     1       33.33   


29             if (!rst_ni) begin
               -1-  
30               rdata_q <= ResetValue;
                 ==>
31             end else if (wr_en_i) begin
                        -2-  
32               rdata_q <= wr_data_i;
                 ==>
33             end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.u_cpuctrl_csr
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name           Attempts Real Successes Failures Incomplete 
IbexCSREnValid 3        0              0        0          


===============================================================================
Module : ibex_top
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 24.31  57.14 --       0.09  40.00   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_top.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                  
 24.31  57.14 --       0.09  40.00   0.00 tb_top.DUT.u_ibex_top 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_top

             Line No.   Total   Covered  Percent
TOTAL                        7        4    57.14
ALWAYS            160        3        2    66.67
ALWAYS            169        4        2    50.00

159                       always_ff @(posedge clk_i or negedge rst_ni) begin
160        1/1              if (!rst_ni) begin
161        1/1                core_busy_q <= 1'b0;
162                         end else begin
163        0/1     ==>        core_busy_q <= core_busy_d;
164                         end
165                       end
166                     
167                       // capture fetch_enable_i in fetch_enable_q, once for ever
168                       always_ff @(posedge clk_i or negedge rst_ni) begin
169        1/1              if (!rst_ni) begin
170        1/1                fetch_enable_q <= 1'b0;
171        0/1     ==>      end else if (fetch_enable_i) begin
172        0/1     ==>        fetch_enable_q <= 1'b1;
173                         end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_top
                Total Covered Percent 
Totals          95    1       1.05    
Total Bits      2134  2       0.09    
Total Bits 0->1 1067  1       0.09    
Total Bits 1->0 1067  1       0.09    

                             
Ports          62   1 1.61   
Port Bits      1646 2 0.12   
Port Bits 0->1 823  1 0.12   
Port Bits 1->0 823  1 0.12   

                              
Signals          33  0 0.00   
Signal Bits      488 0 0.00   
Signal Bits 0->1 244 0 0.00   
Signal Bits 1->0 244 0 0.00   

Port Details
                                  Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                             Yes    Yes         Yes         INPUT     
rst_ni                            No     No          No          INPUT     
test_en_i                         No     No          No          INPUT     
ram_cfg_i.rf_cfg.cfg[3:0]         No     No          No          INPUT     
ram_cfg_i.rf_cfg.cfg_en           No     No          No          INPUT     
ram_cfg_i.ram_cfg.cfg[3:0]        No     No          No          INPUT     
ram_cfg_i.ram_cfg.cfg_en          No     No          No          INPUT     
hart_id_i[31:0]                   No     No          No          INPUT     
boot_addr_i[31:0]                 No     No          No          INPUT     
instr_req_o                       No     No          No          OUTPUT    
instr_gnt_i                       No     No          No          INPUT     
instr_rvalid_i                    No     No          No          INPUT     
instr_addr_o[31:0]                No     No          No          OUTPUT    
instr_rdata_i[31:0]               No     No          No          INPUT     
instr_err_i                       No     No          No          INPUT     
data_req_o                        No     No          No          OUTPUT    
data_gnt_i                        No     No          No          INPUT     
data_rvalid_i                     No     No          No          INPUT     
data_we_o                         No     No          No          OUTPUT    
data_be_o[3:0]                    No     No          No          OUTPUT    
data_addr_o[31:0]                 No     No          No          OUTPUT    
data_wdata_o[31:0]                No     No          No          OUTPUT    
data_rdata_i[31:0]                No     No          No          INPUT     
data_err_i                        No     No          No          INPUT     
irq_software_i                    No     No          No          INPUT     
irq_timer_i                       No     No          No          INPUT     
irq_external_i                    No     No          No          INPUT     
irq_fast_i[14:0]                  No     No          No          INPUT     
irq_nm_i                          No     No          No          INPUT     
debug_req_i                       No     No          No          INPUT     
crash_dump_o.exception_addr[31:0] No     No          No          OUTPUT    
crash_dump_o.last_data_addr[31:0] No     No          No          OUTPUT    
crash_dump_o.next_pc[31:0]        No     No          No          OUTPUT    
crash_dump_o.current_pc[31:0]     No     No          No          OUTPUT    
rvfi_valid                        No     No          No          OUTPUT    
rvfi_order[63:0]                  No     No          No          OUTPUT    
rvfi_insn[31:0]                   No     No          No          OUTPUT    
rvfi_trap                         No     No          No          OUTPUT    
rvfi_halt                         No     No          No          OUTPUT    
rvfi_intr                         No     No          No          OUTPUT    
rvfi_mode[1:0]                    No     No          No          OUTPUT    
rvfi_ixl[1:0]                     No     No          No          OUTPUT    
rvfi_rs1_addr[4:0]                No     No          No          OUTPUT    
rvfi_rs2_addr[4:0]                No     No          No          OUTPUT    
rvfi_rs3_addr[4:0]                No     No          No          OUTPUT    
rvfi_rs1_rdata[31:0]              No     No          No          OUTPUT    
rvfi_rs2_rdata[31:0]              No     No          No          OUTPUT    
rvfi_rs3_rdata[31:0]              No     No          No          OUTPUT    
rvfi_rd_addr[4:0]                 No     No          No          OUTPUT    
rvfi_rd_wdata[31:0]               No     No          No          OUTPUT    
rvfi_pc_rdata[31:0]               No     No          No          OUTPUT    
rvfi_pc_wdata[31:0]               No     No          No          OUTPUT    
rvfi_mem_addr[31:0]               No     No          No          OUTPUT    
rvfi_mem_rmask[3:0]               No     No          No          OUTPUT    
rvfi_mem_wmask[3:0]               No     No          No          OUTPUT    
rvfi_mem_rdata[31:0]              No     No          No          OUTPUT    
rvfi_mem_wdata[31:0]              No     No          No          OUTPUT    
fetch_enable_i                    No     No          No          INPUT     
alert_minor_o                     No     No          No          OUTPUT    
alert_major_o                     No     No          No          OUTPUT    
core_sleep_o                      No     No          No          OUTPUT    
scan_rst_ni                       No     No          No          INPUT     

Signal Details
                                           Toggle Toggle 1->0 Toggle 0->1 
clk                                        No     No          No          
core_busy_d                                No     No          No          
core_busy_q                                No     No          No          
fetch_enable_q                             No     No          No          
clock_en                                   No     No          No          
irq_pending                                No     No          No          
dummy_instr_id                             No     No          No          
rf_raddr_a[4:0]                            No     No          No          
rf_raddr_b[4:0]                            No     No          No          
rf_waddr_wb[4:0]                           No     No          No          
rf_we_wb                                   No     No          No          
rf_wdata_wb_ecc[31:0]                      No     No          No          
rf_rdata_a_ecc[31:0]                       No     No          No          
rf_rdata_b_ecc[31:0]                       No     No          No          
ic_tag_req[1:0]                            No     No          No          
ic_tag_write                               No     No          No          
ic_tag_addr[7:0]                           No     No          No          
ic_tag_wdata[21:0]                         No     No          No          
ic_data_req[1:0]                           No     No          No          
ic_data_write                              No     No          No          
ic_data_addr[7:0]                          No     No          No          
ic_data_wdata[63:0]                        No     No          No          
core_alert_major                           No     No          No          
core_alert_minor                           No     No          No          
lockstep_alert_major                       No     No          No          
lockstep_alert_minor                       No     No          No          
unused_lockstep_alert_major                No     No          No          
gen_norams.unused_ram_cfg.rf_cfg.cfg[3:0]  No     No          No          
gen_norams.unused_ram_cfg.rf_cfg.cfg_en    No     No          No          
gen_norams.unused_ram_cfg.ram_cfg.cfg[3:0] No     No          No          
gen_norams.unused_ram_cfg.ram_cfg.cfg_en   No     No          No          
gen_norams.unused_ram_inputs               No     No          No          
gen_no_lockstep.unused_scan                No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_top
         Line No. Total Covered Percent 
Branches          5     2       40.00   
IF       160      2     1       50.00   
IF       169      3     1       33.33   


160            if (!rst_ni) begin
               -1-  
161              core_busy_q <= 1'b0;
                 ==>
162            end else begin
163              core_busy_q <= core_busy_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


169            if (!rst_ni) begin
               -1-  
170              fetch_enable_q <= 1'b0;
                 ==>
171            end else if (fetch_enable_i) begin
                        -2-  
172              fetch_enable_q <= 1'b1;
                 ==>
173            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_top
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       2     2         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            2     2         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name            Attempts Real Successes Failures Incomplete 
IbexAlertMajorX 3        0              0        0          
IbexAlertMinorX 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 24.31  57.14 --       0.09  40.00   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 13.77  30.08  19.12   0.02  18.63   0.99 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 24.31  57.14 --       0.09  40.00   0.00 ibex_top 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME 
  0.12 --     --       0.12 --     --     DUT  


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                           
 74.07 100.00 --      22.22 100.00 --     core_clock_gate_i              
 28.04  50.79 --       0.00  33.33 --     gen_regfile_ff.register_file_i 
 13.11  28.45  19.12   0.00  16.96   1.01 u_ibex_core                    



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_alu
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 25.00  46.48  27.27   0.00  26.23 --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_alu.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                               
 25.00  46.48  27.27   0.00  26.23 --     tb_top.DUT.u_ibex_top.u_ibex_core.ex_block_i.alu_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_alu

             Line No.   Total   Covered  Percent
TOTAL                       71       33    46.48
ALWAYS             53        4        3    75.00
ALWAYS             78        4        3    75.00
ALWAYS            101        3        2    66.67
ALWAYS            118        3        2    66.67
ALWAYS            141        6        2    33.33
ALWAYS            264        3        2    66.67
ALWAYS            286       10        3    30.00
ALWAYS            313       13        9    69.23
ALWAYS            353        4        2    50.00
ALWAYS            373        4        2    50.00
ALWAYS           1198       17        3    17.65

52                        always_comb begin
53         1/1              adder_op_b_negate = 1'b0;
54         1/1              unique case (operator_i)
55                            // Adder OPs
56                            ALU_SUB,
57                      
58                            // Comparator OPs
59                            ALU_EQ,   ALU_NE,
60                            ALU_GE,   ALU_GEU,
61                            ALU_LT,   ALU_LTU,
62                            ALU_SLT,  ALU_SLTU,
63                      
64                            // MinMax OPs (RV32B Ops)
65                            ALU_MIN,  ALU_MINU,
66         1/1                ALU_MAX,  ALU_MAXU: adder_op_b_negate = 1'b1;
67                      
68         0/1     ==>        default:;
69                          endcase
70                        end
71                      
72                        // prepare operand a
73                        assign adder_in_a    = multdiv_sel_i ? multdiv_operand_a_i : {operand_a_i,1'b1};
74                      
75                        // prepare operand b
76                        assign operand_b_neg = {operand_b_i,1'b0} ^ {33{1'b1}};
77                        always_comb begin
78         1/1              unique case(1'b1)
79         0/1     ==>        multdiv_sel_i:     adder_in_b = multdiv_operand_b_i;
80         1/1                adder_op_b_negate: adder_in_b = operand_b_neg;
81         1/1                default :          adder_in_b = {operand_b_i, 1'b0};
82                          endcase
83                        end
84                      
85                        // actual adder
86                        assign adder_result_ext_o = $unsigned(adder_in_a) + $unsigned(adder_in_b);
87                      
88                        assign adder_result       = adder_result_ext_o[32:1];
89                      
90                        assign adder_result_o     = adder_result;
91                      
92                        ////////////////
93                        // Comparison //
94                        ////////////////
95                      
96                        logic is_equal;
97                        logic is_greater_equal;  // handles both signed and unsigned forms
98                        logic cmp_signed;
99                      
100                       always_comb begin
101        1/1              unique case (operator_i)
102                           ALU_GE,
103                           ALU_LT,
104                           ALU_SLT,
105                           // RV32B only
106                           ALU_MIN,
107        0/1     ==>        ALU_MAX: cmp_signed = 1'b1;
108                     
109        1/1                default: cmp_signed = 1'b0;
110                         endcase
111                       end
112                     
113                       assign is_equal = (adder_result == 32'b0);
114                       assign is_equal_result_o = is_equal;
115                     
116                       // Is greater equal
117                       always_comb begin
118        1/1              if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
119        0/1     ==>        is_greater_equal = (adder_result[31] == 1'b0);
120                         end else begin
121        1/1                is_greater_equal = operand_a_i[31] ^ (cmp_signed);
122                         end
123                       end
124                     
125                       // GTE unsigned:
126                       // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
127                       // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
128                       // (a[31] == 1 && b[31] == 0) => 1
129                       // (a[31] == 0 && b[31] == 1) => 0
130                     
131                       // GTE signed:
132                       // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
133                       // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
134                       // (a[31] == 1 && b[31] == 0) => 0
135                       // (a[31] == 0 && b[31] == 1) => 1
136                     
137                       // generate comparison result
138                       logic cmp_result;
139                     
140                       always_comb begin
141        1/1              unique case (operator_i)
142        0/1     ==>        ALU_EQ:             cmp_result =  is_equal;
143        0/1     ==>        ALU_NE:             cmp_result = ~is_equal;
144                           ALU_GE,   ALU_GEU,
145        0/1     ==>        ALU_MAX,  ALU_MAXU: cmp_result = is_greater_equal; // RV32B only
146                           ALU_LT,   ALU_LTU,
147                           ALU_MIN,  ALU_MINU, //RV32B only
148        1/1                ALU_SLT,  ALU_SLTU: cmp_result = ~is_greater_equal;
149                     
150        0/1     ==>        default: cmp_result = is_equal;
151                         endcase
152                       end
153                     
154                       assign comparison_result_o = cmp_result;
155                     
156                       ///////////
157                       // Shift //
158                       ///////////
159                     
160                       // The shifter structure consists of a 33-bit shifter: 32-bit operand + 1 bit extension for
161                       // arithmetic shifts and one-shift support.
162                       // Rotations and funnel shifts are implemented as multi-cycle instructions.
163                       // The shifter is also used for single-bit instructions and bit-field place as detailed below.
164                       //
165                       // Standard Shifts
166                       // ===============
167                       // For standard shift instructions, the direction of the shift is to the right by default. For
168                       // left shifts, the signal shift_left signal is set. If so, the operand is initially reversed,
169                       // shifted to the right by the specified amount and shifted back again. For arithmetic- and
170                       // one-shifts the 33rd bit of the shifter operand can is set accordingly.
171                       //
172                       // Multicycle Shifts
173                       // =================
174                       //
175                       // Rotation
176                       // --------
177                       // For rotations, the operand signals operand_a_i and operand_b_i are kept constant to rs1 and
178                       // rs2 respectively.
179                       //
180                       // Rotation pseudocode:
181                       //   shift_amt = rs2 & 31;
182                       //   multicycle_result = (rs1 >> shift_amt) | (rs1 << (32 - shift_amt));
183                       //                       ^-- cycle 0 -----^ ^-- cycle 1 --------------^
184                       //
185                       // Funnel Shifts
186                       // -------------
187                       // For funnel shifs, operand_a_i is tied to rs1 in the first cycle and rs3 in the
188                       // second cycle. operand_b_i is always tied to rs2. The order of applying the shift amount or
189                       // its complement is determined by bit [5] of shift_amt.
190                       //
191                       // Funnel shift Pseudocode: (fsl)
192                       //  shift_amt = rs2 & 63;
193                       //  shift_amt_compl = 32 - shift_amt[4:0]
194                       //  if (shift_amt >=33):
195                       //     multicycle_result = (rs1 >> shift_amt_compl[4:0]) | (rs3 << shift_amt[4:0]);
196                       //                         ^-- cycle 0 ----------------^ ^-- cycle 1 ------------^
197                       //  else if (shift_amt <= 31 && shift_amt > 0):
198                       //     multicycle_result = (rs1 << shift_amt[4:0]) | (rs3 >> shift_amt_compl[4:0]);
199                       //                         ^-- cycle 0 ----------^ ^-- cycle 1 -------------------^
200                       //  For shift_amt == 0, 32, both shift_amt[4:0] and shift_amt_compl[4:0] == '0.
201                       //  these cases need to be handled separately outside the shifting structure:
202                       //  else if (shift_amt == 32):
203                       //     multicycle_result = rs3
204                       //  else if (shift_amt == 0):
205                       //     multicycle_result = rs1.
206                       //
207                       // Single-Bit Instructions
208                       // =======================
209                       // Single bit instructions operate on bit operand_b_i[4:0] of operand_a_i.
210                     
211                       // The operations sbset, sbclr and sbinv are implemented by generation of a bit-mask using the
212                       // shifter structure. This is done by left-shifting the operand 32'h1 by the required amount.
213                       // The signal shift_sbmode multiplexes the shifter input and sets the signal shift_left.
214                       // Further processing is taken care of by a separate structure.
215                       //
216                       // For sbext, the bit defined by operand_b_i[4:0] is to be returned. This is done by simply
217                       // shifting operand_a_i to the right by the required amount and returning bit [0] of the result.
218                       //
219                       // Bit-Field Place
220                       // ===============
221                       // The shifter structure is shared to compute bfp_mask << bfp_off.
222                     
223                       logic       shift_left;
224                       logic       shift_ones;
225                       logic       shift_arith;
226                       logic       shift_funnel;
227                       logic       shift_sbmode;
228                       logic [5:0] shift_amt;
229                       logic [5:0] shift_amt_compl; // complementary shift amount (32 - shift_amt)
230                     
231                       logic        [31:0] shift_operand;
232                       logic signed [32:0] shift_result_ext_signed;
233                       logic        [32:0] shift_result_ext;
234                       logic               unused_shift_result_ext;
235                       logic        [31:0] shift_result;
236                       logic        [31:0] shift_result_rev;
237                     
238                       // zbf
239                       logic bfp_op;
240                       logic [4:0]  bfp_len;
241                       logic [4:0]  bfp_off;
242                       logic [31:0] bfp_mask;
243                       logic [31:0] bfp_mask_rev;
244                       logic [31:0] bfp_result;
245                     
246                       // bfp: shares the shifter structure to compute bfp_mask << bfp_off
247                       assign bfp_op = (RV32B != RV32BNone) ? (operator_i == ALU_BFP) : 1'b0;
248                       assign bfp_len = {~(|operand_b_i[27:24]), operand_b_i[27:24]}; // len = 0 encodes for len = 16
249                       assign bfp_off = operand_b_i[20:16];
250                       assign bfp_mask = (RV32B != RV32BNone) ? ~(32'hffff_ffff << bfp_len) : '0;
251                       for (genvar i=0; i<32; i++) begin : gen_rev_bfp_mask
252                         assign bfp_mask_rev[i] = bfp_mask[31-i];
253                       end
254                     
255                       assign bfp_result =(RV32B != RV32BNone) ?
256                           (~shift_result & operand_a_i) | ((operand_b_i & bfp_mask) << bfp_off) : '0;
257                     
258                       // bit shift_amt[5]: word swap bit: only considered for FSL/FSR.
259                       // if set, reverse operations in first and second cycle.
260                       assign shift_amt[5] = operand_b_i[5] & shift_funnel;
261                       assign shift_amt_compl = 32 - operand_b_i[4:0];
262                     
263                       always_comb begin
264        1/1              if (bfp_op) begin
265        0/1     ==>        shift_amt[4:0] = bfp_off ; // length field of bfp control word
266                         end else begin
267        1/1                shift_amt[4:0] = instr_first_cycle_i ?
268                               (operand_b_i[5] && shift_funnel ? shift_amt_compl[4:0] : operand_b_i[4:0]) :
269                               (operand_b_i[5] && shift_funnel ? operand_b_i[4:0] : shift_amt_compl[4:0]);
270                         end
271                       end
272                     
273                       // single-bit mode: shift
274                       assign shift_sbmode = (RV32B != RV32BNone) ?
275                           (operator_i == ALU_SBSET) | (operator_i == ALU_SBCLR) | (operator_i == ALU_SBINV) : 1'b0;
276                     
277                       // left shift if this is:
278                       // * a standard left shift (slo, sll)
279                       // * a rol in the first cycle
280                       // * a ror in the second cycle
281                       // * fsl: without word-swap bit: first cycle, else: second cycle
282                       // * fsr: without word-swap bit: second cycle, else: first cycle
283                       // * a single-bit instruction: sbclr, sbset, sbinv (excluding sbext)
284                       // * bfp: bfp_mask << bfp_off
285                       always_comb begin
286        1/1              unique case (operator_i)
287        0/1     ==>        ALU_SLL: shift_left = 1'b1;
288                           ALU_SLO,
289        0/1     ==>        ALU_BFP: shift_left = (RV32B != RV32BNone) ? 1'b1 : 1'b0;
290        0/1     ==>        ALU_ROL: shift_left = (RV32B != RV32BNone) ? instr_first_cycle_i : 0;
291        0/1     ==>        ALU_ROR: shift_left = (RV32B != RV32BNone) ? ~instr_first_cycle_i : 0;
292        0/1     ==>        ALU_FSL: shift_left = (RV32B != RV32BNone) ?
293                             (shift_amt[5] ? ~instr_first_cycle_i : instr_first_cycle_i) : 1'b0;
294        0/1     ==>        ALU_FSR: shift_left = (RV32B != RV32BNone) ?
295                               (shift_amt[5] ? instr_first_cycle_i : ~instr_first_cycle_i) : 1'b0;
296        1/1                default: shift_left = 1'b0;
297                         endcase
298        1/1              if (shift_sbmode) begin
299        0/1     ==>        shift_left = 1'b1;
300                         end
                        MISSING_ELSE
301                       end
302                     
303                       assign shift_arith  = (operator_i == ALU_SRA);
304                       assign shift_ones   =
305                           (RV32B != RV32BNone) ? (operator_i == ALU_SLO) | (operator_i == ALU_SRO) : 1'b0;
306                       assign shift_funnel =
307                           (RV32B != RV32BNone) ? (operator_i == ALU_FSL) | (operator_i == ALU_FSR) : 1'b0;
308                     
309                       // shifter structure.
310                       always_comb begin
311                         // select shifter input
312                         // for bfp, sbmode and shift_left the corresponding bit-reversed input is chosen.
313        1/1              if (RV32B == RV32BNone) begin
314        1/1                shift_operand = shift_left ? operand_a_rev : operand_a_i;
315                         end else begin
316        0/1     ==>        unique case (1'b1)
317        0/1     ==>          bfp_op:       shift_operand = bfp_mask_rev;
318        0/1     ==>          shift_sbmode: shift_operand = 32'h8000_0000;
319        0/1     ==>          default:      shift_operand = shift_left ? operand_a_rev : operand_a_i;
320                           endcase
321                         end
322                     
323        1/1              shift_result_ext_signed =
324                             $signed({shift_ones | (shift_arith & shift_operand[31]), shift_operand}) >>> shift_amt[4:0];
325        1/1              shift_result_ext = $unsigned(shift_result_ext_signed);
326                     
327        1/1              shift_result            = shift_result_ext[31:0];
328        1/1              unused_shift_result_ext = shift_result_ext[32];
329                     
330        1/1              for (int unsigned i=0; i<32; i++) begin
331        1/1                shift_result_rev[i] = shift_result[31-i];
332                         end
333                     
334        1/1              shift_result = shift_left ? shift_result_rev : shift_result;
335                     
336                       end
337                     
338                       ///////////////////
339                       // Bitwise Logic //
340                       ///////////////////
341                     
342                       logic bwlogic_or;
343                       logic bwlogic_and;
344                       logic [31:0] bwlogic_operand_b;
345                       logic [31:0] bwlogic_or_result;
346                       logic [31:0] bwlogic_and_result;
347                       logic [31:0] bwlogic_xor_result;
348                       logic [31:0] bwlogic_result;
349                     
350                       logic bwlogic_op_b_negate;
351                     
352                       always_comb begin
353        1/1              unique case (operator_i)
354                           // Logic-with-negate OPs (RV32B Ops)
355                           ALU_XNOR,
356                           ALU_ORN,
357        0/1     ==>        ALU_ANDN: bwlogic_op_b_negate = (RV32B != RV32BNone) ? 1'b1 : 1'b0;
358        0/1     ==>        ALU_CMIX: bwlogic_op_b_negate = (RV32B != RV32BNone) ? ~instr_first_cycle_i : 1'b0;
359        1/1                default:  bwlogic_op_b_negate = 1'b0;
360                         endcase
361                       end
362                     
363                       assign bwlogic_operand_b = bwlogic_op_b_negate ? operand_b_neg[32:1] : operand_b_i;
364                     
365                       assign bwlogic_or_result  = operand_a_i | bwlogic_operand_b;
366                       assign bwlogic_and_result = operand_a_i & bwlogic_operand_b;
367                       assign bwlogic_xor_result = operand_a_i ^ bwlogic_operand_b;
368                     
369                       assign bwlogic_or  = (operator_i == ALU_OR)  | (operator_i == ALU_ORN);
370                       assign bwlogic_and = (operator_i == ALU_AND) | (operator_i == ALU_ANDN);
371                     
372                       always_comb begin
373        1/1              unique case (1'b1)
374        0/1     ==>        bwlogic_or:  bwlogic_result = bwlogic_or_result;
375        0/1     ==>        bwlogic_and: bwlogic_result = bwlogic_and_result;
376        1/1                default:     bwlogic_result = bwlogic_xor_result;
377                         endcase
378                       end
379                     
380                       logic [5:0]  bitcnt_result;
381                       logic [31:0] minmax_result;
382                       logic [31:0] pack_result;
383                       logic [31:0] sext_result;
384                       logic [31:0] singlebit_result;
385                       logic [31:0] rev_result;
386                       logic [31:0] shuffle_result;
387                       logic [31:0] butterfly_result;
388                       logic [31:0] invbutterfly_result;
389                       logic [31:0] clmul_result;
390                       logic [31:0] multicycle_result;
391                     
392                       if (RV32B != RV32BNone) begin : g_alu_rvb
393                     
394                         /////////////////
395                         // Bitcounting //
396                         /////////////////
397                     
398                         // The bit-counter structure computes the number of set bits in its operand. Partial results
399                         // (from left to right) are needed to compute the control masks for computation of bext/bdep
400                         // by the butterfly network, if implemented.
401                         // For pcnt, clz and ctz, only the end result is used.
402                     
403                         logic        zbe_op;
404                         logic        bitcnt_ctz;
405                         logic        bitcnt_clz;
406                         logic        bitcnt_cz;
407                         logic [31:0] bitcnt_bits;
408                         logic [31:0] bitcnt_mask_op;
409                         logic [31:0] bitcnt_bit_mask;
410                         logic [ 5:0] bitcnt_partial [32];
411                         logic [31:0] bitcnt_partial_lsb_d;
412                         logic [31:0] bitcnt_partial_msb_d;
413                     
414                     
415                         assign bitcnt_ctz    = operator_i == ALU_CTZ;
416                         assign bitcnt_clz    = operator_i == ALU_CLZ;
417                         assign bitcnt_cz     = bitcnt_ctz | bitcnt_clz;
418                         assign bitcnt_result = bitcnt_partial[31];
419                     
420                         // Bit-mask generation for clz and ctz:
421                         // The bit mask is generated by spreading the lowest-order set bit in the operand to all
422                         // higher order bits. The resulting mask is inverted to cover the lowest order zeros. In order
423                         // to create the bit mask for leading zeros, the input operand needs to be reversed.
424                         assign bitcnt_mask_op = bitcnt_clz ? operand_a_rev : operand_a_i;
425                     
426                         always_comb begin
427                           bitcnt_bit_mask = bitcnt_mask_op;
428                           bitcnt_bit_mask |= bitcnt_bit_mask << 1;
429                           bitcnt_bit_mask |= bitcnt_bit_mask << 2;
430                           bitcnt_bit_mask |= bitcnt_bit_mask << 4;
431                           bitcnt_bit_mask |= bitcnt_bit_mask << 8;
432                           bitcnt_bit_mask |= bitcnt_bit_mask << 16;
433                           bitcnt_bit_mask = ~bitcnt_bit_mask;
434                         end
435                     
436                         assign zbe_op = (operator_i == ALU_BEXT) | (operator_i == ALU_BDEP);
437                     
438                         always_comb begin
439                           case(1'b1)
440                             zbe_op:      bitcnt_bits = operand_b_i;
441                             bitcnt_cz:   bitcnt_bits = bitcnt_bit_mask & ~bitcnt_mask_op; // clz / ctz
442                             default:     bitcnt_bits = operand_a_i; // pcnt
443                           endcase
444                         end
445                     
446                         // The parallel prefix counter is of the structure of a Brent-Kung Adder. In the first
447                         // log2(width) stages, the sum of the n preceding bit lines is computed for the bit lines at
448                         // positions 2**n-1 (power-of-two positions) where n denotes the current stage.
449                         // In stage n=log2(width), the count for position width-1 (the MSB) is finished.
450                         // For the intermediate values, an inverse adder tree then computes the bit counts for the bit
451                         // lines at positions
452                         // m = 2**(n-1) + i*2**(n-2), where i = [1 ... width / 2**(n-1)-1] and n = [log2(width) ... 2].
453                         // Thus, at every subsequent stage the result of two previously unconnected sub-trees is
454                         // summed, starting at the node summing bits [width/2-1 : 0] and [3*width/4-1: width/2]
455                         // and moving to iteratively sum up all the sub-trees.
456                         // The inverse adder tree thus features log2(width) - 1 stages the first of these stages is a
457                         // single addition at position 3*width/4 - 1. It does not interfere with the last
458                         // stage of the primary adder tree. These stages can thus be folded together, resulting in a
459                         // total of 2*log2(width)-2 stages.
460                         // For more details refer to R. Brent, H. T. Kung, "A Regular Layout for Parallel Adders",
461                         // (1982).
462                         // For a bitline at position p, only bits
463                         // bitcnt_partial[max(i, such that p % log2(i) == 0)-1 : 0] are needed for generation of the
464                         // butterfly network control signals. The adders in the intermediate value adder tree thus need
465                         // not be full 5-bit adders. We leave the optimization to the synthesis tools.
466                         //
467                         // Consider the following 8-bit example for illustraton.
468                         //
469                         // let bitcnt_bits = 8'babcdefgh.
470                         //
471                         //                   a  b  c  d  e  f  g  h
472                         //                   | /:  | /:  | /:  | /:
473                         //                   |/ :  |/ :  |/ :  |/ :
474                         // stage 1:          +  :  +  :  +  :  +  :
475                         //                   |  : /:  :  |  : /:  :
476                         //                   |,--+ :  :  |,--+ :  :
477                         // stage 2:          +  :  :  :  +  :  :  :
478                         //                   |  :  |  : /:  :  :  :
479                         //                   |,-----,--+ :  :  :  : ^-primary adder tree
480                         // stage 3:          +  :  +  :  :  :  :  : -------------------------
481                         //                   :  | /| /| /| /| /|  : ,-intermediate adder tree
482                         //                   :  |/ |/ |/ |/ |/ :  :
483                         // stage 4           :  +  +  +  +  +  :  :
484                         //                   :  :  :  :  :  :  :  :
485                         // bitcnt_partial[i] 7  6  5  4  3  2  1  0
486                     
487                         always_comb begin
488                           bitcnt_partial = '{default: '0};
489                           // stage 1
490                           for (int unsigned i=1; i<32; i+=2) begin
491                             bitcnt_partial[i] = {5'h0, bitcnt_bits[i]} + {5'h0, bitcnt_bits[i-1]};
492                           end
493                           // stage 2
494                           for (int unsigned i=3; i<32; i+=4) begin
495                             bitcnt_partial[i] = bitcnt_partial[i-2] + bitcnt_partial[i];
496                           end
497                           // stage 3
498                           for (int unsigned i=7; i<32; i+=8) begin
499                             bitcnt_partial[i] = bitcnt_partial[i-4] + bitcnt_partial[i];
500                           end
501                           // stage 4
502                           for (int unsigned i=15; i <32; i+=16) begin
503                             bitcnt_partial[i] = bitcnt_partial[i-8] + bitcnt_partial[i];
504                           end
505                           // stage 5
506                           bitcnt_partial[31] = bitcnt_partial[15] + bitcnt_partial[31];
507                           // ^- primary adder tree
508                           // -------------------------------
509                           // ,-intermediate value adder tree
510                           bitcnt_partial[23] = bitcnt_partial[15] + bitcnt_partial[23];
511                     
512                           // stage 6
513                           for (int unsigned i=11; i<32; i+=8) begin
514                             bitcnt_partial[i] = bitcnt_partial[i-4] + bitcnt_partial[i];
515                           end
516                     
517                           // stage 7
518                           for (int unsigned i=5; i<32; i+=4) begin
519                             bitcnt_partial[i] = bitcnt_partial[i-2] + bitcnt_partial[i];
520                           end
521                           // stage 8
522                           bitcnt_partial[0] = {5'h0, bitcnt_bits[0]};
523                           for (int unsigned i=2; i<32; i+=2) begin
524                             bitcnt_partial[i] = bitcnt_partial[i-1] + {5'h0, bitcnt_bits[i]};
525                           end
526                         end
527                     
528                         ///////////////
529                         // Min / Max //
530                         ///////////////
531                     
532                         assign minmax_result = cmp_result ? operand_a_i : operand_b_i;
533                     
534                         //////////
535                         // Pack //
536                         //////////
537                     
538                         logic packu;
539                         logic packh;
540                         assign packu = operator_i == ALU_PACKU;
541                         assign packh = operator_i == ALU_PACKH;
542                     
543                         always_comb begin
544                           unique case (1'b1)
545                             packu:   pack_result = {operand_b_i[31:16], operand_a_i[31:16]};
546                             packh:   pack_result = {16'h0, operand_b_i[7:0], operand_a_i[7:0]};
547                             default: pack_result = {operand_b_i[15:0], operand_a_i[15:0]};
548                           endcase
549                         end
550                     
551                         //////////
552                         // Sext //
553                         //////////
554                     
555                         assign sext_result = (operator_i == ALU_SEXTB) ?
556                             { {24{operand_a_i[7]}}, operand_a_i[7:0]} : { {16{operand_a_i[15]}}, operand_a_i[15:0]};
557                     
558                         /////////////////////////////
559                         // Single-bit Instructions //
560                         /////////////////////////////
561                     
562                         always_comb begin
563                           unique case (operator_i)
564                             ALU_SBSET: singlebit_result = operand_a_i | shift_result;
565                             ALU_SBCLR: singlebit_result = operand_a_i & ~shift_result;
566                             ALU_SBINV: singlebit_result = operand_a_i ^ shift_result;
567                             default:   singlebit_result = {31'h0, shift_result[0]}; // ALU_SBEXT
568                           endcase
569                         end
570                     
571                         ////////////////////////////////////
572                         // General Reverse and Or-combine //
573                         ////////////////////////////////////
574                     
575                         // Only a subset of the General reverse and or-combine instructions are implemented in the
576                         // balanced version of the B extension. Currently rev, rev8 and orc.b are supported in the
577                         // base extension.
578                     
579                         logic [4:0] zbp_shift_amt;
580                         logic gorc_op;
581                     
582                         assign gorc_op = (operator_i == ALU_GORC);
583                         assign zbp_shift_amt[2:0] = (RV32B == RV32BFull) ? shift_amt[2:0] : {3{&shift_amt[2:0]}};
584                         assign zbp_shift_amt[4:3] = (RV32B == RV32BFull) ? shift_amt[4:3] : {2{&shift_amt[4:3]}};
585                     
586                         always_comb begin
587                           rev_result = operand_a_i;
588                     
589                           if (zbp_shift_amt[0]) begin
590                             rev_result = (gorc_op ? rev_result : 32'h0)       |
591                                          ((rev_result & 32'h5555_5555) <<  1) |
592                                          ((rev_result & 32'haaaa_aaaa) >>  1);
593                           end
594                     
595                           if (zbp_shift_amt[1]) begin
596                             rev_result = (gorc_op ? rev_result : 32'h0)       |
597                                          ((rev_result & 32'h3333_3333) <<  2) |
598                                          ((rev_result & 32'hcccc_cccc) >>  2);
599                           end
600                     
601                           if (zbp_shift_amt[2]) begin
602                             rev_result = (gorc_op ? rev_result : 32'h0)       |
603                                          ((rev_result & 32'h0f0f_0f0f) <<  4) |
604                                          ((rev_result & 32'hf0f0_f0f0) >>  4);
605                           end
606                     
607                           if (zbp_shift_amt[3]) begin
608                             rev_result = (gorc_op & (RV32B == RV32BFull) ? rev_result : 32'h0) |
609                                          ((rev_result & 32'h00ff_00ff) <<  8) |
610                                          ((rev_result & 32'hff00_ff00) >>  8);
611                           end
612                     
613                           if (zbp_shift_amt[4]) begin
614                             rev_result = (gorc_op & (RV32B == RV32BFull) ? rev_result : 32'h0) |
615                                          ((rev_result & 32'h0000_ffff) << 16) |
616                                          ((rev_result & 32'hffff_0000) >> 16);
617                           end
618                         end
619                     
620                         logic crc_hmode;
621                         logic crc_bmode;
622                         logic [31:0] clmul_result_rev;
623                     
624                         if (RV32B == RV32BFull) begin : gen_alu_rvb_full
625                     
626                           /////////////////////////
627                           // Shuffle / Unshuffle //
628                           /////////////////////////
629                     
630                           localparam logic [31:0] SHUFFLE_MASK_L [4] =
631                               '{32'h00ff_0000, 32'h0f00_0f00, 32'h3030_3030, 32'h4444_4444};
632                           localparam logic [31:0] SHUFFLE_MASK_R [4] =
633                               '{32'h0000_ff00, 32'h00f0_00f0, 32'h0c0c_0c0c, 32'h2222_2222};
634                     
635                           localparam logic [31:0] FLIP_MASK_L [4] =
636                               '{32'h2200_1100, 32'h0044_0000, 32'h4411_0000, 32'h1100_0000};
637                           localparam logic [31:0] FLIP_MASK_R [4] =
638                               '{32'h0088_0044, 32'h0000_2200, 32'h0000_8822, 32'h0000_0088};
639                     
640                           logic [31:0] SHUFFLE_MASK_NOT [4];
641                           for(genvar i = 0; i < 4; i++) begin : gen_shuffle_mask_not
642                             assign SHUFFLE_MASK_NOT[i] = ~(SHUFFLE_MASK_L[i] | SHUFFLE_MASK_R[i]);
643                           end
644                     
645                           logic shuffle_flip;
646                           assign shuffle_flip = operator_i == ALU_UNSHFL;
647                     
648                           logic [3:0] shuffle_mode;
649                     
650                           always_comb begin
651                             shuffle_result = operand_a_i;
652                     
653                             if (shuffle_flip) begin
654                               shuffle_mode[3] = shift_amt[0];
655                               shuffle_mode[2] = shift_amt[1];
656                               shuffle_mode[1] = shift_amt[2];
657                               shuffle_mode[0] = shift_amt[3];
658                             end else begin
659                               shuffle_mode = shift_amt[3:0];
660                             end
661                     
662                             if (shuffle_flip) begin
663                               shuffle_result = (shuffle_result & 32'h8822_4411) |
664                                   ((shuffle_result << 6)  & FLIP_MASK_L[0]) |
665                                   ((shuffle_result >> 6)  & FLIP_MASK_R[0]) |
666                                   ((shuffle_result << 9)  & FLIP_MASK_L[1]) |
667                                   ((shuffle_result >> 9)  & FLIP_MASK_R[1]) |
668                                   ((shuffle_result << 15) & FLIP_MASK_L[2]) |
669                                   ((shuffle_result >> 15) & FLIP_MASK_R[2]) |
670                                   ((shuffle_result << 21) & FLIP_MASK_L[3]) |
671                                   ((shuffle_result >> 21) & FLIP_MASK_R[3]);
672                             end
673                     
674                             if (shuffle_mode[3]) begin
675                               shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[0]) |
676                                   (((shuffle_result << 8) & SHUFFLE_MASK_L[0]) |
677                                   ((shuffle_result >> 8) & SHUFFLE_MASK_R[0]));
678                             end
679                             if (shuffle_mode[2]) begin
680                               shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[1]) |
681                                   (((shuffle_result << 4) & SHUFFLE_MASK_L[1]) |
682                                   ((shuffle_result >> 4) & SHUFFLE_MASK_R[1]));
683                             end
684                             if (shuffle_mode[1]) begin
685                               shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[2]) |
686                                   (((shuffle_result << 2) & SHUFFLE_MASK_L[2]) |
687                                   ((shuffle_result >> 2) & SHUFFLE_MASK_R[2]));
688                             end
689                             if (shuffle_mode[0]) begin
690                               shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[3]) |
691                                   (((shuffle_result << 1) & SHUFFLE_MASK_L[3]) |
692                                   ((shuffle_result >> 1) & SHUFFLE_MASK_R[3]));
693                             end
694                     
695                             if (shuffle_flip) begin
696                               shuffle_result = (shuffle_result & 32'h8822_4411) |
697                                   ((shuffle_result << 6)  & FLIP_MASK_L[0]) |
698                                   ((shuffle_result >> 6)  & FLIP_MASK_R[0]) |
699                                   ((shuffle_result << 9)  & FLIP_MASK_L[1]) |
700                                   ((shuffle_result >> 9)  & FLIP_MASK_R[1]) |
701                                   ((shuffle_result << 15) & FLIP_MASK_L[2]) |
702                                   ((shuffle_result >> 15) & FLIP_MASK_R[2]) |
703                                   ((shuffle_result << 21) & FLIP_MASK_L[3]) |
704                                   ((shuffle_result >> 21) & FLIP_MASK_R[3]);
705                             end
706                           end
707                     
708                           ///////////////
709                           // Butterfly //
710                           ///////////////
711                     
712                           // The butterfly / inverse butterfly network executing bext/bdep (zbe) instructions.
713                           // For bdep, the control bits mask of a local left region is generated by
714                           // the inverse of a n-bit left rotate and complement upon wrap (LROTC) operation by the number
715                           // of ones in the deposit bitmask to the right of the segment. n hereby denotes the width
716                           // of the according segment. The bitmask for a pertaining local right region is equal to the
717                           // corresponding local left region. Bext uses an analogue inverse process.
718                           // Consider the following 8-bit example.  For details, see Hilewitz et al. "Fast Bit Gather,
719                           // Bit Scatter and Bit Permuation Instructions for Commodity Microprocessors", (2008).
720                           //
721                           // The bext/bdep instructions are completed in 2 cycles. In the first cycle, the control
722                           // bitmask is prepared by executing the parallel prefix bit count. In the second cycle,
723                           // the bit swapping is executed according to the control masks.
724                     
725                           // 8-bit example:  (Hilewitz et al.)
726                           // Consider the instruction bdep operand_a_i deposit_mask
727                           // Let operand_a_i = 8'babcd_efgh
728                           //    deposit_mask = 8'b1010_1101
729                           //
730                           // control bitmask for stage 1:
731                           //  - number of ones in the right half of the deposit bitmask: 3
732                           //  - width of the segment: 4
733                           //  - control bitmask = ~LROTC(4'b0, 3)[3:0] = 4'b1000
734                           //
735                           // control bitmask:   c3 c2  c1 c0  c3 c2  c1 c0
736                           //                    1  0   0  0   1  0   0  0
737                           //                    <- L ----->   <- R ----->
738                           // operand_a_i        a  b   c  d   e  f   g  h
739                           //                    :\ |   |  |  /:  |   |  |
740                           //                    : +|---|--|-+ :  |   |  |
741                           //                    :/ |   |  |  \:  |   |  |
742                           // stage 1            e  b   c  d   a  f   g  h
743                           //                    <L->   <R->   <L->   <R->
744                           // control bitmask:   c3 c2  c3 c2  c1 c0  c1 c0
745                           //                    1  1   1  1   1  0   1  0
746                           //                    :\ :\ /: /:   :\ |  /:  |
747                           //                    : +:-+-:+ :   : +|-+ :  |
748                           //                    :/ :/ \: \:   :/ |  \:  |
749                           // stage 2            c  d   e  b   g  f   a  h
750                           //                    L  R   L  R   L  R   L  R
751                           // control bitmask:   c3 c3  c2 c2  c1 c1  c0 c0
752                           //                    1  1   0  0   1  1   0  0
753                           //                    :\/:   |  |   :\/:   |  |
754                           //                    :  :   |  |   :  :   |  |
755                           //                    :/\:   |  |   :/\:   |  |
756                           // stage 3            d  c   e  b   f  g   a  h
757                           // & deposit bitmask: 1  0   1  0   1  1   0  1
758                           // result:            d  0   e  0   f  g   0  h
759                     
760                           logic [ 5:0] bitcnt_partial_q [32];
761                     
762                           // first cycle
763                           // Store partial bitcnts
764                           for (genvar i=0; i<32; i++) begin : gen_bitcnt_reg_in_lsb
765                             assign bitcnt_partial_lsb_d[i] = bitcnt_partial[i][0];
766                           end
767                     
768                           for (genvar i=0; i<16; i++) begin : gen_bitcnt_reg_in_b1
769                             assign bitcnt_partial_msb_d[i] = bitcnt_partial[2*i+1][1];
770                           end
771                     
772                           for (genvar i=0; i<8; i++) begin : gen_bitcnt_reg_in_b2
773                             assign bitcnt_partial_msb_d[16+i] = bitcnt_partial[4*i+3][2];
774                           end
775                     
776                           for (genvar i=0; i<4; i++) begin : gen_bitcnt_reg_in_b3
777                             assign bitcnt_partial_msb_d[24+i] = bitcnt_partial[8*i+7][3];
778                           end
779                     
780                           for (genvar i=0; i<2; i++) begin : gen_bitcnt_reg_in_b4
781                             assign bitcnt_partial_msb_d[28+i] = bitcnt_partial[16*i+15][4];
782                           end
783                     
784                           assign bitcnt_partial_msb_d[30] = bitcnt_partial[31][5];
785                           assign bitcnt_partial_msb_d[31] = 1'b0; // unused
786                     
787                           // Second cycle
788                           // Load partial bitcnts
789                           always_comb begin
790                             bitcnt_partial_q = '{default: '0};
791                     
792                             for (int unsigned i=0; i<32; i++) begin : gen_bitcnt_reg_out_lsb
793                               bitcnt_partial_q[i][0] = imd_val_q_i[0][i];
794                             end
795                     
796                             for (int unsigned i=0; i<16; i++) begin : gen_bitcnt_reg_out_b1
797                               bitcnt_partial_q[2*i+1][1] = imd_val_q_i[1][i];
798                             end
799                     
800                             for (int unsigned i=0; i<8; i++) begin : gen_bitcnt_reg_out_b2
801                               bitcnt_partial_q[4*i+3][2] = imd_val_q_i[1][16+i];
802                             end
803                     
804                             for (int unsigned i=0; i<4; i++) begin : gen_bitcnt_reg_out_b3
805                               bitcnt_partial_q[8*i+7][3] = imd_val_q_i[1][24+i];
806                             end
807                     
808                             for (int unsigned i=0; i<2; i++) begin : gen_bitcnt_reg_out_b4
809                               bitcnt_partial_q[16*i+15][4] = imd_val_q_i[1][28+i];
810                             end
811                     
812                             bitcnt_partial_q[31][5] = imd_val_q_i[1][30];
813                           end
814                     
815                           logic [31:0] butterfly_mask_l[5];
816                           logic [31:0] butterfly_mask_r[5];
817                           logic [31:0] butterfly_mask_not[5];
818                           logic [31:0] lrotc_stage [5]; // left rotate and complement upon wrap
819                     
820                           // number of bits in local r = 32 / 2**(stage + 1) = 16/2**stage
821                           `define _N(stg) (16 >> stg)
822                     
823                           // bext / bdep control bit generation
824                           for (genvar stg=0; stg<5; stg++) begin : gen_butterfly_ctrl_stage
825                             // number of segs: 2** stg
826                             for (genvar seg=0; seg<2**stg; seg++) begin : gen_butterfly_ctrl
827                     
828                               assign lrotc_stage[stg][2*`_N(stg)*(seg+1)-1 : 2*`_N(stg)*seg] =
829                                   {{`_N(stg){1'b0}},{`_N(stg){1'b1}}} <<
830                                     bitcnt_partial_q[`_N(stg)*(2*seg+1)-1][$clog2(`_N(stg)):0];
831                     
832                               assign butterfly_mask_l[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)]
833                                        = ~lrotc_stage[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)];
834                     
835                               assign butterfly_mask_r[stg][`_N(stg)*(2*seg+1)-1 : `_N(stg)*(2*seg)]
836                                        = ~lrotc_stage[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)];
837                     
838                               assign butterfly_mask_l[stg][`_N(stg)*(2*seg+1)-1 : `_N(stg)*(2*seg)]   = '0;
839                               assign butterfly_mask_r[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)] = '0;
840                             end
841                           end
842                           `undef _N
843                     
844                           for (genvar stg=0; stg<5; stg++) begin : gen_butterfly_not
845                             assign butterfly_mask_not[stg] =
846                                 ~(butterfly_mask_l[stg] | butterfly_mask_r[stg]);
847                           end
848                     
849                           always_comb begin
850                             butterfly_result = operand_a_i;
851                     
852                             butterfly_result = butterfly_result & butterfly_mask_not[0] |
853                                 ((butterfly_result & butterfly_mask_l[0]) >> 16)|
854                                 ((butterfly_result & butterfly_mask_r[0]) << 16);
855                     
856                             butterfly_result = butterfly_result & butterfly_mask_not[1] |
857                                 ((butterfly_result & butterfly_mask_l[1]) >> 8)|
858                                 ((butterfly_result & butterfly_mask_r[1]) << 8);
859                     
860                             butterfly_result = butterfly_result & butterfly_mask_not[2] |
861                                 ((butterfly_result & butterfly_mask_l[2]) >> 4)|
862                                 ((butterfly_result & butterfly_mask_r[2]) << 4);
863                     
864                             butterfly_result = butterfly_result & butterfly_mask_not[3] |
865                                 ((butterfly_result & butterfly_mask_l[3]) >> 2)|
866                                 ((butterfly_result & butterfly_mask_r[3]) << 2);
867                     
868                             butterfly_result = butterfly_result & butterfly_mask_not[4] |
869                                 ((butterfly_result & butterfly_mask_l[4]) >> 1)|
870                                 ((butterfly_result & butterfly_mask_r[4]) << 1);
871                     
872                             butterfly_result = butterfly_result & operand_b_i;
873                           end
874                     
875                           always_comb begin
876                             invbutterfly_result = operand_a_i & operand_b_i;
877                     
878                             invbutterfly_result = invbutterfly_result & butterfly_mask_not[4] |
879                                 ((invbutterfly_result & butterfly_mask_l[4]) >> 1)|
880                                 ((invbutterfly_result & butterfly_mask_r[4]) << 1);
881                     
882                             invbutterfly_result = invbutterfly_result & butterfly_mask_not[3] |
883                                 ((invbutterfly_result & butterfly_mask_l[3]) >> 2)|
884                                 ((invbutterfly_result & butterfly_mask_r[3]) << 2);
885                     
886                             invbutterfly_result = invbutterfly_result & butterfly_mask_not[2] |
887                                 ((invbutterfly_result & butterfly_mask_l[2]) >> 4)|
888                                 ((invbutterfly_result & butterfly_mask_r[2]) << 4);
889                     
890                             invbutterfly_result = invbutterfly_result & butterfly_mask_not[1] |
891                                 ((invbutterfly_result & butterfly_mask_l[1]) >> 8)|
892                                 ((invbutterfly_result & butterfly_mask_r[1]) << 8);
893                     
894                             invbutterfly_result = invbutterfly_result & butterfly_mask_not[0] |
895                                 ((invbutterfly_result & butterfly_mask_l[0]) >> 16)|
896                                 ((invbutterfly_result & butterfly_mask_r[0]) << 16);
897                           end
898                     
899                           ///////////////////////////////////////////////////
900                           // Carry-less Multiply + Cyclic Redundancy Check //
901                           ///////////////////////////////////////////////////
902                     
903                           // Carry-less multiplication can be understood as multiplication based on
904                           // the addition interpreted as the bit-wise xor operation.
905                           //
906                           // Example: 1101 X 1011 = 1111111:
907                           //
908                           //       1011 X 1101
909                           //       -----------
910                           //              1101
911                           //         xor 1101
912                           //         ---------
913                           //             10111
914                           //        xor 0000
915                           //        ----------
916                           //            010111
917                           //       xor 1101
918                           //       -----------
919                           //           1111111
920                           //
921                           // Architectural details:
922                           //         A 32 x 32-bit array
923                           //         [ operand_b[i] ? (operand_a << i) : '0 for i in 0 ... 31 ]
924                           //         is generated. The entries of the array are pairwise 'xor-ed'
925                           //         together in a 5-stage binary tree.
926                           //
927                           //
928                           // Cyclic Redundancy Check:
929                           //
930                           // CRC-32 (CRC-32/ISO-HDLC) and CRC-32C (CRC-32/ISCSI) are directly implemented. For
931                           // documentation of the crc configuration (crc-polynomials, initialization, reflection, etc.)
932                           // see http://reveng.sourceforge.net/crc-catalogue/all.htm
933                           // A useful guide to crc arithmetic and algorithms is given here:
934                           // http://www.piclist.com/techref/method/math/crcguide.html.
935                           //
936                           // The CRC operation solves the following equation using binary polynomial arithmetic:
937                           //
938                           // rev(rd)(x) = rev(rs1)(x) * x**n mod {1, P}(x)
939                           //
940                           // where P denotes lower 32 bits of the corresponding CRC polynomial, rev(a) the bit reversal
941                           // of a, n = 8,16, or 32 for .b, .h, .w -variants. {a, b} denotes bit concatenation.
942                           //
943                           // Using barret reduction, one can show that
944                           //
945                           // M(x) mod P(x) = R(x) =
946                           //          (M(x) * x**n) & {deg(P(x)'{1'b1}}) ^ (M(x) x**-(deg(P(x) - n)) cx mu(x) cx P(x),
947                           //
948                           // Where mu(x) = polydiv(x**64, {1,P}) & 0xffffffff. Here, 'cx' refers to carry-less
949                           // multiplication. Substituting rev(rd)(x) for R(x) and rev(rs1)(x) for M(x) and solving for
950                           // rd(x) with P(x) a crc32 polynomial (deg(P(x)) = 32), we get
951                           //
952                           // rd = rev( (rev(rs1) << n)  ^ ((rev(rs1) >> (32-n)) cx mu cx P)
953                           //    = (rs1 >> n) ^ rev(rev( (rs1 << (32-n)) cx rev(mu)) cx P)
954                           //                       ^-- cycle 0--------------------^
955                           //      ^- cycle 1 -------------------------------------------^
956                           //
957                           // In the last step we used the fact that carry-less multiplication is bit-order agnostic:
958                           // rev(a cx b) = rev(a) cx rev(b).
959                     
960                           logic clmul_rmode;
961                           logic clmul_hmode;
962                           logic [31:0] clmul_op_a;
963                           logic [31:0] clmul_op_b;
964                           logic [31:0] operand_b_rev;
965                           logic [31:0] clmul_and_stage[32];
966                           logic [31:0] clmul_xor_stage1[16];
967                           logic [31:0] clmul_xor_stage2[8];
968                           logic [31:0] clmul_xor_stage3[4];
969                           logic [31:0] clmul_xor_stage4[2];
970                     
971                           logic [31:0] clmul_result_raw;
972                     
973                           for (genvar i=0; i<32; i++) begin: gen_rev_operand_b
974                             assign operand_b_rev[i] = operand_b_i[31-i];
975                           end
976                     
977                           assign clmul_rmode = operator_i == ALU_CLMULR;
978                           assign clmul_hmode = operator_i == ALU_CLMULH;
979                     
980                           // CRC
981                           localparam logic [31:0] CRC32_POLYNOMIAL = 32'h04c1_1db7;
982                           localparam logic [31:0] CRC32_MU_REV = 32'hf701_1641;
983                     
984                           localparam logic [31:0] CRC32C_POLYNOMIAL = 32'h1edc_6f41;
985                           localparam logic [31:0] CRC32C_MU_REV = 32'hdea7_13f1;
986                     
987                           logic crc_op;
988                     
989                           logic crc_cpoly;
990                     
991                           logic [31:0] crc_operand;
992                           logic [31:0] crc_poly;
993                           logic [31:0] crc_mu_rev;
994                     
995                           assign crc_op = (operator_i == ALU_CRC32C_W) | (operator_i == ALU_CRC32_W) |
996                                           (operator_i == ALU_CRC32C_H) | (operator_i == ALU_CRC32_H) |
997                                           (operator_i == ALU_CRC32C_B) | (operator_i == ALU_CRC32_B);
998                     
999                           assign crc_cpoly = (operator_i == ALU_CRC32C_W) |
1000                                             (operator_i == ALU_CRC32C_H) |
1001                                             (operator_i == ALU_CRC32C_B);
1002                    
1003                          assign crc_hmode = (operator_i == ALU_CRC32_H) | (operator_i == ALU_CRC32C_H);
1004                          assign crc_bmode = (operator_i == ALU_CRC32_B) | (operator_i == ALU_CRC32C_B);
1005                    
1006                          assign crc_poly   = crc_cpoly ? CRC32C_POLYNOMIAL : CRC32_POLYNOMIAL;
1007                          assign crc_mu_rev = crc_cpoly ? CRC32C_MU_REV : CRC32_MU_REV;
1008                    
1009                          always_comb begin
1010                            unique case(1'b1)
1011                              crc_bmode: crc_operand = {operand_a_i[7:0], 24'h0};
1012                              crc_hmode: crc_operand = {operand_a_i[15:0], 16'h0};
1013                              default:   crc_operand = operand_a_i;
1014                            endcase
1015                          end
1016                    
1017                          // Select clmul input
1018                          always_comb begin
1019                            if (crc_op) begin
1020                              clmul_op_a = instr_first_cycle_i ? crc_operand : imd_val_q_i[0];
1021                              clmul_op_b = instr_first_cycle_i ? crc_mu_rev : crc_poly;
1022                            end else begin
1023                              clmul_op_a = clmul_rmode | clmul_hmode ? operand_a_rev : operand_a_i;
1024                              clmul_op_b = clmul_rmode | clmul_hmode ? operand_b_rev : operand_b_i;
1025                            end
1026                          end
1027                    
1028                          for (genvar i=0; i<32; i++) begin : gen_clmul_and_op
1029                            assign clmul_and_stage[i] = clmul_op_b[i] ? clmul_op_a << i : '0;
1030                          end
1031                    
1032                          for (genvar i=0; i<16; i++) begin : gen_clmul_xor_op_l1
1033                            assign clmul_xor_stage1[i] = clmul_and_stage[2*i] ^ clmul_and_stage[2*i+1];
1034                          end
1035                    
1036                          for (genvar i=0; i<8; i++) begin : gen_clmul_xor_op_l2
1037                            assign clmul_xor_stage2[i] = clmul_xor_stage1[2*i] ^ clmul_xor_stage1[2*i+1];
1038                          end
1039                    
1040                          for (genvar i=0; i<4; i++) begin : gen_clmul_xor_op_l3
1041                            assign clmul_xor_stage3[i] = clmul_xor_stage2[2*i] ^ clmul_xor_stage2[2*i+1];
1042                          end
1043                    
1044                          for (genvar i=0; i<2; i++) begin : gen_clmul_xor_op_l4
1045                            assign clmul_xor_stage4[i] = clmul_xor_stage3[2*i] ^ clmul_xor_stage3[2*i+1];
1046                          end
1047                    
1048                          assign clmul_result_raw = clmul_xor_stage4[0] ^ clmul_xor_stage4[1];
1049                    
1050                          for (genvar i=0; i<32; i++) begin : gen_rev_clmul_result
1051                            assign clmul_result_rev[i] = clmul_result_raw[31-i];
1052                          end
1053                    
1054                          // clmulr_result = rev(clmul(rev(a), rev(b)))
1055                          // clmulh_result = clmulr_result >> 1
1056                          always_comb begin
1057                            case(1'b1)
1058                              clmul_rmode: clmul_result = clmul_result_rev;
1059                              clmul_hmode: clmul_result = {1'b0, clmul_result_rev[31:1]};
1060                              default:     clmul_result = clmul_result_raw;
1061                            endcase
1062                          end
1063                        end else begin : gen_alu_rvb_notfull
1064                          logic [31:0] unused_imd_val_q_1;
1065                          assign unused_imd_val_q_1   = imd_val_q_i[1];
1066                          assign shuffle_result       = '0;
1067                          assign butterfly_result     = '0;
1068                          assign invbutterfly_result  = '0;
1069                          assign clmul_result         = '0;
1070                          // support signals
1071                          assign bitcnt_partial_lsb_d = '0;
1072                          assign bitcnt_partial_msb_d = '0;
1073                          assign clmul_result_rev     = '0;
1074                          assign crc_bmode            = '0;
1075                          assign crc_hmode            = '0;
1076                        end
1077                    
1078                        //////////////////////////////////////
1079                        // Multicycle Bitmanip Instructions //
1080                        //////////////////////////////////////
1081                        // Ternary instructions + Shift Rotations + Bit extract/deposit + CRC
1082                        // For ternary instructions (zbt), operand_a_i is tied to rs1 in the first cycle and rs3 in the
1083                        // second cycle. operand_b_i is always tied to rs2.
1084                    
1085                        always_comb begin
1086                          unique case (operator_i)
1087                            ALU_CMOV: begin
1088                              multicycle_result = (operand_b_i == 32'h0) ? operand_a_i : imd_val_q_i[0];
1089                              imd_val_d_o = '{operand_a_i, 32'h0};
1090                              if (instr_first_cycle_i) begin
1091                                imd_val_we_o = 2'b01;
1092                              end else begin
1093                                imd_val_we_o = 2'b00;
1094                              end
1095                            end
1096                    
1097                            ALU_CMIX: begin
1098                              multicycle_result = imd_val_q_i[0] | bwlogic_and_result;
1099                              imd_val_d_o = '{bwlogic_and_result, 32'h0};
1100                              if (instr_first_cycle_i) begin
1101                                imd_val_we_o = 2'b01;
1102                              end else begin
1103                                imd_val_we_o = 2'b00;
1104                              end
1105                            end
1106                    
1107                            ALU_FSR, ALU_FSL,
1108                            ALU_ROL, ALU_ROR: begin
1109                              if (shift_amt[4:0] == 5'h0) begin
1110                                multicycle_result = shift_amt[5] ? operand_a_i : imd_val_q_i[0];
1111                              end else begin
1112                                multicycle_result = imd_val_q_i[0] | shift_result;
1113                              end
1114                              imd_val_d_o = '{shift_result, 32'h0};
1115                              if (instr_first_cycle_i) begin
1116                                imd_val_we_o = 2'b01;
1117                              end else begin
1118                                imd_val_we_o = 2'b00;
1119                              end
1120                            end
1121                    
1122                            ALU_CRC32_W, ALU_CRC32C_W,
1123                            ALU_CRC32_H, ALU_CRC32C_H,
1124                            ALU_CRC32_B, ALU_CRC32C_B: begin
1125                              if (RV32B == RV32BFull) begin
1126                                unique case(1'b1)
1127                                  crc_bmode: multicycle_result = clmul_result_rev ^ (operand_a_i >> 8);
1128                                  crc_hmode: multicycle_result = clmul_result_rev ^ (operand_a_i >> 16);
1129                                  default:   multicycle_result = clmul_result_rev;
1130                                endcase
1131                                imd_val_d_o = '{clmul_result_rev, 32'h0};
1132                                if (instr_first_cycle_i) begin
1133                                  imd_val_we_o = 2'b01;
1134                                end else begin
1135                                  imd_val_we_o = 2'b00;
1136                                end
1137                              end else begin
1138                                imd_val_d_o = '{operand_a_i, 32'h0};
1139                                imd_val_we_o = 2'b00;
1140                                multicycle_result = '0;
1141                              end
1142                            end
1143                    
1144                            ALU_BEXT, ALU_BDEP: begin
1145                              if (RV32B == RV32BFull) begin
1146                                multicycle_result = (operator_i == ALU_BDEP) ? butterfly_result : invbutterfly_result;
1147                                imd_val_d_o = '{bitcnt_partial_lsb_d, bitcnt_partial_msb_d};
1148                                if (instr_first_cycle_i) begin
1149                                  imd_val_we_o = 2'b11;
1150                                end else begin
1151                                  imd_val_we_o = 2'b00;
1152                                end
1153                              end else begin
1154                                imd_val_d_o = '{operand_a_i, 32'h0};
1155                                imd_val_we_o = 2'b00;
1156                                multicycle_result = '0;
1157                              end
1158                            end
1159                    
1160                            default: begin
1161                              imd_val_d_o = '{operand_a_i, 32'h0};
1162                              imd_val_we_o = 2'b00;
1163                              multicycle_result = '0;
1164                            end
1165                          endcase
1166                        end
1167                    
1168                    
1169                      end else begin : g_no_alu_rvb
1170                        logic [31:0] unused_imd_val_q[2];
1171                        assign unused_imd_val_q           = imd_val_q_i;
1172                        logic [31:0] unused_butterfly_result;
1173                        assign unused_butterfly_result    = butterfly_result;
1174                        logic [31:0] unused_invbutterfly_result;
1175                        assign unused_invbutterfly_result = invbutterfly_result;
1176                        // RV32B result signals
1177                        assign bitcnt_result       = '0;
1178                        assign minmax_result       = '0;
1179                        assign pack_result         = '0;
1180                        assign sext_result         = '0;
1181                        assign singlebit_result    = '0;
1182                        assign rev_result          = '0;
1183                        assign shuffle_result      = '0;
1184                        assign butterfly_result    = '0;
1185                        assign invbutterfly_result = '0;
1186                        assign clmul_result        = '0;
1187                        assign multicycle_result   = '0;
1188                        // RV32B support signals
1189                        assign imd_val_d_o         = '{default: '0};
1190                        assign imd_val_we_o        = '{default: '0};
1191                      end
1192                    
1193                      ////////////////
1194                      // Result mux //
1195                      ////////////////
1196                    
1197                      always_comb begin
1198       1/1              result_o   = '0;
1199                    
1200       1/1              unique case (operator_i)
1201                          // Bitwise Logic Operations (negate: RV32B)
1202                          ALU_XOR,  ALU_XNOR,
1203                          ALU_OR,   ALU_ORN,
1204       0/1     ==>        ALU_AND,  ALU_ANDN: result_o = bwlogic_result;
1205                    
1206                          // Adder Operations
1207       0/1     ==>        ALU_ADD,  ALU_SUB: result_o = adder_result;
1208                    
1209                          // Shift Operations
1210                          ALU_SLL,  ALU_SRL,
1211                          ALU_SRA,
1212                          // RV32B
1213       0/1     ==>        ALU_SLO,  ALU_SRO: result_o = shift_result;
1214                    
1215                          // Shuffle Operations (RV32B)
1216       0/1     ==>        ALU_SHFL, ALU_UNSHFL: result_o = shuffle_result;
1217                    
1218                          // Comparison Operations
1219                          ALU_EQ,   ALU_NE,
1220                          ALU_GE,   ALU_GEU,
1221                          ALU_LT,   ALU_LTU,
1222       1/1                ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};
1223                    
1224                          // MinMax Operations (RV32B)
1225                          ALU_MIN,  ALU_MAX,
1226       0/1     ==>        ALU_MINU, ALU_MAXU: result_o = minmax_result;
1227                    
1228                          // Bitcount Operations (RV32B)
1229                          ALU_CLZ, ALU_CTZ,
1230       0/1     ==>        ALU_PCNT: result_o = {26'h0, bitcnt_result};
1231                    
1232                          // Pack Operations (RV32B)
1233                          ALU_PACK, ALU_PACKH,
1234       0/1     ==>        ALU_PACKU: result_o = pack_result;
1235                    
1236                          // Sign-Extend (RV32B)
1237       0/1     ==>        ALU_SEXTB, ALU_SEXTH: result_o = sext_result;
1238                    
1239                          // Ternary Bitmanip Operations (RV32B)
1240                          ALU_CMIX, ALU_CMOV,
1241                          ALU_FSL,  ALU_FSR,
1242                          // Rotate Shift (RV32B)
1243                          ALU_ROL, ALU_ROR,
1244                          // Cyclic Redundancy Checks (RV32B)
1245                          ALU_CRC32_W, ALU_CRC32C_W,
1246                          ALU_CRC32_H, ALU_CRC32C_H,
1247                          ALU_CRC32_B, ALU_CRC32C_B,
1248                          // Bit Extract / Deposit (RV32B)
1249       0/1     ==>        ALU_BEXT, ALU_BDEP: result_o = multicycle_result;
1250                    
1251                          // Single-Bit Bitmanip Operations (RV32B)
1252                          ALU_SBSET, ALU_SBCLR,
1253       0/1     ==>        ALU_SBINV, ALU_SBEXT: result_o = singlebit_result;
1254                    
1255                          // General Reverse / Or-combine (RV32B)
1256       0/1     ==>        ALU_GREV, ALU_GORC: result_o = rev_result;
1257                    
1258                          // Bit Field Place (RV32B)
1259       0/1     ==>        ALU_BFP: result_o = bfp_result;
1260                    
1261                          // Carry-less Multiply Operations (RV32B)
1262                          ALU_CLMUL, ALU_CLMULR,
1263       0/1     ==>        ALU_CLMULH: result_o = clmul_result;
1264                    
1265       0/1     ==>        default: ;

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_alu

               Total   Covered  Percent
Conditions         22        6    27.27
Logical            22        6    27.27
Non-Logical         0        0
Event               0        0

 LINE       267
 EXPRESSION 
 Number  Term
      1  instr_first_cycle_i ? ((operand_b_i[5] && shift_funnel) ? shift_amt_compl[4:0] : operand_b_i[4:0]) : ((operand_b_i[5] && shift_funnel) ? operand_b_i[4:0] : shift_amt_compl[4:0]))

-1- Status
 0  Covered
 1  Not Covered

 LINE       267
 SUB-EXPRESSION ((operand_b_i[5] && shift_funnel) ? shift_amt_compl[4:0] : operand_b_i[4:0])
                 ----------------1---------------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       267
 SUB-EXPRESSION (operand_b_i[5] && shift_funnel)
                 -------1------    ------2-----

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       267
 SUB-EXPRESSION ((operand_b_i[5] && shift_funnel) ? operand_b_i[4:0] : shift_amt_compl[4:0])
                 ----------------1---------------

-1- Status
 0  Covered
 1  Not Covered

 LINE       267
 SUB-EXPRESSION (operand_b_i[5] && shift_funnel)
                 -------1------    ------2-----

-1- -2- Status
 0   1  Not Covered
 1   0  Not Covered
 1   1  Not Covered

 LINE       314
 EXPRESSION (shift_left ? operand_a_rev : operand_a_i)
             -----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       319
 EXPRESSION (shift_left ? operand_a_rev : operand_a_i)
             -----1----

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       334
 EXPRESSION (shift_left ? shift_result_rev : shift_result)
             -----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       73
 EXPRESSION (multdiv_sel_i ? multdiv_operand_a_i : ({operand_a_i, 1'b1}))
             ------1------

-1- Status
 0  Covered
 1  Not Covered

 LINE       363
 EXPRESSION (bwlogic_op_b_negate ? operand_b_neg[32:1] : operand_b_i)
             ---------1---------

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_alu
                Total Covered Percent 
Totals          64    0       0.00    
Total Bits      2498  0       0.00    
Total Bits 0->1 1249  0       0.00    
Total Bits 1->0 1249  0       0.00    

                            
Ports          13  0 0.00   
Port Bits      480 0 0.00   
Port Bits 0->1 240 0 0.00   
Port Bits 1->0 240 0 0.00   

                               
Signals          51   0 0.00   
Signal Bits      2018 0 0.00   
Signal Bits 0->1 1009 0 0.00   
Signal Bits 1->0 1009 0 0.00   

Port Details
                          Toggle Toggle 1->0 Toggle 0->1 Direction 
operator_i[5:0]           No     No          No          INPUT     
operand_a_i[31:0]         No     No          No          INPUT     
operand_b_i[31:0]         No     No          No          INPUT     
instr_first_cycle_i       No     No          No          INPUT     
multdiv_operand_a_i[32:0] No     No          No          INPUT     
multdiv_operand_b_i[32:0] No     No          No          INPUT     
multdiv_sel_i             No     No          No          INPUT     
imd_val_we_o[1:0]         No     No          No          OUTPUT    
adder_result_o[31:0]      No     No          No          OUTPUT    
adder_result_ext_o[33:0]  No     No          No          OUTPUT    
result_o[31:0]            No     No          No          OUTPUT    
comparison_result_o       No     No          No          OUTPUT    
is_equal_result_o         No     No          No          OUTPUT    

Signal Details
                                              Toggle Toggle 1->0 Toggle 0->1 
operand_a_rev[31:0]                           No     No          No          
operand_b_neg[32:0]                           No     No          No          
adder_op_b_negate                             No     No          No          
adder_in_a[32:0]                              No     No          No          
adder_in_b[32:0]                              No     No          No          
adder_result[31:0]                            No     No          No          
is_equal                                      No     No          No          
is_greater_equal                              No     No          No          
cmp_signed                                    No     No          No          
cmp_result                                    No     No          No          
shift_left                                    No     No          No          
shift_ones                                    No     No          No          
shift_arith                                   No     No          No          
shift_funnel                                  No     No          No          
shift_sbmode                                  No     No          No          
shift_amt[5:0]                                No     No          No          
shift_amt_compl[5:0]                          No     No          No          
shift_operand[31:0]                           No     No          No          
shift_result_ext_signed[32:0]                 No     No          No          
shift_result_ext[32:0]                        No     No          No          
unused_shift_result_ext                       No     No          No          
shift_result[31:0]                            No     No          No          
shift_result_rev[31:0]                        No     No          No          
bfp_op                                        No     No          No          
bfp_len[4:0]                                  No     No          No          
bfp_off[4:0]                                  No     No          No          
bfp_mask[31:0]                                No     No          No          
bfp_mask_rev[31:0]                            No     No          No          
bfp_result[31:0]                              No     No          No          
bwlogic_or                                    No     No          No          
bwlogic_and                                   No     No          No          
bwlogic_operand_b[31:0]                       No     No          No          
bwlogic_or_result[31:0]                       No     No          No          
bwlogic_and_result[31:0]                      No     No          No          
bwlogic_xor_result[31:0]                      No     No          No          
bwlogic_result[31:0]                          No     No          No          
bwlogic_op_b_negate                           No     No          No          
bitcnt_result[5:0]                            No     No          No          
minmax_result[31:0]                           No     No          No          
pack_result[31:0]                             No     No          No          
sext_result[31:0]                             No     No          No          
singlebit_result[31:0]                        No     No          No          
rev_result[31:0]                              No     No          No          
shuffle_result[31:0]                          No     No          No          
butterfly_result[31:0]                        No     No          No          
invbutterfly_result[31:0]                     No     No          No          
clmul_result[31:0]                            No     No          No          
multicycle_result[31:0]                       No     No          No          
unused_shift_amt_compl                        No     No          No          
g_no_alu_rvb.unused_butterfly_result[31:0]    No     No          No          
g_no_alu_rvb.unused_invbutterfly_result[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_alu
         Line No. Total Covered Percent 
Branches          61    16      26.23   
TERNARY  73       2     1       50.00   
TERNARY  363      2     1       50.00   
CASE     54       2     1       50.00   
CASE     78       3     2       66.67   
CASE     101      2     1       50.00   
IF       118      2     1       50.00   
CASE     141      5     1       20.00   
IF       264      5     1       20.00   
CASE     286      7     1       14.29   
IF       298      2     1       50.00   
IF       313      6     1       16.67   
TERNARY  334      2     1       50.00   
CASE     353      3     1       33.33   
CASE     373      3     1       33.33   
CASE     1200     15    1       6.67    


73           assign adder_in_a    = multdiv_sel_i ? multdiv_operand_a_i : {operand_a_i,1'b1};
                                                  -1-  
                                                  ==>  
                                                  ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


363          assign bwlogic_operand_b = bwlogic_op_b_negate ? operand_b_neg[32:1] : operand_b_i;
                                                            -1-  
                                                            ==>  
                                                            ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


54             unique case (operator_i)
                      -1-  
55               // Adder OPs
56               ALU_SUB,
57         
58               // Comparator OPs
59               ALU_EQ,   ALU_NE,
60               ALU_GE,   ALU_GEU,
61               ALU_LT,   ALU_LTU,
62               ALU_SLT,  ALU_SLTU,
63         
64               // MinMax OPs (RV32B Ops)
65               ALU_MIN,  ALU_MINU,
66               ALU_MAX,  ALU_MAXU: adder_op_b_negate = 1'b1;
                 ==>
67         
68               default:;
                 ==>

Branches:

-1-                                                                                                                 Status      
CASEITEM-1: ALU_SUB ALU_EQ ALU_NE ALU_GE ALU_GEU ALU_LT ALU_LTU ALU_SLT ALU_SLTU ALU_MIN ALU_MINU ALU_MAX ALU_MAXU  Covered     
default                                                                                                             Not Covered 


78             unique case(1'b1)
                      -1-  
79               multdiv_sel_i:     adder_in_b = multdiv_operand_b_i;
                 ==>
80               adder_op_b_negate: adder_in_b = operand_b_neg;
                 ==>
81               default :          adder_in_b = {operand_b_i, 1'b0};
                 ==>

Branches:

-1-                Status      
multdiv_sel_i      Not Covered 
adder_op_b_negate  Covered     
default            Covered     


101            unique case (operator_i)
                      -1-  
102              ALU_GE,
103              ALU_LT,
104              ALU_SLT,
105              // RV32B only
106              ALU_MIN,
107              ALU_MAX: cmp_signed = 1'b1;
                 ==>
108        
109              default: cmp_signed = 1'b0;
                 ==>

Branches:

-1-                                    Status      
ALU_GE ALU_LT ALU_SLT ALU_MIN ALU_MAX  Not Covered 
default                                Covered     


118            if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
               -1-  
119              is_greater_equal = (adder_result[31] == 1'b0);
                 ==>
120            end else begin
121              is_greater_equal = operand_a_i[31] ^ (cmp_signed);
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


141            unique case (operator_i)
                      -1-  
142              ALU_EQ:             cmp_result =  is_equal;
                 ==>
143              ALU_NE:             cmp_result = ~is_equal;
                 ==>
144              ALU_GE,   ALU_GEU,
145              ALU_MAX,  ALU_MAXU: cmp_result = is_greater_equal; // RV32B only
                 ==>
146              ALU_LT,   ALU_LTU,
147              ALU_MIN,  ALU_MINU, //RV32B only
148              ALU_SLT,  ALU_SLTU: cmp_result = ~is_greater_equal;
                 ==>
149        
150              default: cmp_result = is_equal;
                 ==>

Branches:

-1-                                               Status      
ALU_EQ                                            Not Covered 
ALU_NE                                            Not Covered 
ALU_GE ALU_GEU ALU_MAX ALU_MAXU                   Not Covered 
ALU_LT ALU_LTU ALU_MIN ALU_MINU ALU_SLT ALU_SLTU  Covered     
default                                           Not Covered 


264            if (bfp_op) begin
               -1-  
265              shift_amt[4:0] = bfp_off ; // length field of bfp control word
                 ==>
266            end else begin
267              shift_amt[4:0] = instr_first_cycle_i ?
                                                      -2-  
268                  (operand_b_i[5] && shift_funnel ? shift_amt_compl[4:0] : operand_b_i[4:0]) :
                                                     -3-  
                                                     ==>  
                                                     ==>  
269                  (operand_b_i[5] && shift_funnel ? operand_b_i[4:0] : shift_amt_compl[4:0]);
                                                     -4-  
                                                     ==>  
                                                     ==>  

Branches:

-1- -2- -3- -4- Status      
1   -   -   -   Not Covered 
0   1   1   -   Not Covered 
0   1   0   -   Not Covered 
0   0   -   1   Not Covered 
0   0   -   0   Covered     


286            unique case (operator_i)
                      -1-  
287              ALU_SLL: shift_left = 1'b1;
                 ==>
288              ALU_SLO,
289              ALU_BFP: shift_left = (RV32B != RV32BNone) ? 1'b1 : 1'b0;
                 ==>
290              ALU_ROL: shift_left = (RV32B != RV32BNone) ? instr_first_cycle_i : 0;
                 ==>
291              ALU_ROR: shift_left = (RV32B != RV32BNone) ? ~instr_first_cycle_i : 0;
                 ==>
292              ALU_FSL: shift_left = (RV32B != RV32BNone) ?
                 ==>
293                (shift_amt[5] ? ~instr_first_cycle_i : instr_first_cycle_i) : 1'b0;
294              ALU_FSR: shift_left = (RV32B != RV32BNone) ?
                 ==>
295                  (shift_amt[5] ? instr_first_cycle_i : ~instr_first_cycle_i) : 1'b0;
296              default: shift_left = 1'b0;
                 ==>

Branches:

-1-              Status      
ALU_SLL          Not Covered 
ALU_SLO ALU_BFP  Not Covered 
ALU_ROL          Not Covered 
ALU_ROR          Not Covered 
ALU_FSL          Not Covered 
ALU_FSR          Not Covered 
default          Covered     


298            if (shift_sbmode) begin
               -1-      
299              shift_left = 1'b1;
                 ==>
300            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


313            if (RV32B == RV32BNone) begin
               -1-  
314              shift_operand = shift_left ? operand_a_rev : operand_a_i;
                                            -2-  
                                            ==>  
                                            ==>  
315            end else begin
316              unique case (1'b1)
                        -3-  
317                bfp_op:       shift_operand = bfp_mask_rev;
                   ==>
318                shift_sbmode: shift_operand = 32'h8000_0000;
                   ==>
319                default:      shift_operand = shift_left ? operand_a_rev : operand_a_i;
                                                            -4-  
                                                            ==>  
                                                            ==>  

Branches:

-1- -2- -3-           -4- Status      
1   1   -             -   Not Covered 
1   0   -             -   Covered     
0   -   bfp_op        -   Not Covered 
0   -   shift_sbmode  -   Not Covered 
0   -   default       1   Not Covered 
0   -   default       0   Not Covered 


334            shift_result = shift_left ? shift_result_rev : shift_result;
                                         -1-  
                                         ==>  
                                         ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


353            unique case (operator_i)
                      -1-  
354              // Logic-with-negate OPs (RV32B Ops)
355              ALU_XNOR,
356              ALU_ORN,
357              ALU_ANDN: bwlogic_op_b_negate = (RV32B != RV32BNone) ? 1'b1 : 1'b0;
                 ==>
358              ALU_CMIX: bwlogic_op_b_negate = (RV32B != RV32BNone) ? ~instr_first_cycle_i : 1'b0;
                 ==>
359              default:  bwlogic_op_b_negate = 1'b0;
                 ==>

Branches:

-1-                        Status      
ALU_XNOR ALU_ORN ALU_ANDN  Not Covered 
ALU_CMIX                   Not Covered 
default                    Covered     


373            unique case (1'b1)
                      -1-  
374              bwlogic_or:  bwlogic_result = bwlogic_or_result;
                 ==>
375              bwlogic_and: bwlogic_result = bwlogic_and_result;
                 ==>
376              default:     bwlogic_result = bwlogic_xor_result;
                 ==>

Branches:

-1-          Status      
bwlogic_or   Not Covered 
bwlogic_and  Not Covered 
default      Covered     


1200           unique case (operator_i)
                      -1-  
1201             // Bitwise Logic Operations (negate: RV32B)
1202             ALU_XOR,  ALU_XNOR,
1203             ALU_OR,   ALU_ORN,
1204             ALU_AND,  ALU_ANDN: result_o = bwlogic_result;
                 ==>
1205       
1206             // Adder Operations
1207             ALU_ADD,  ALU_SUB: result_o = adder_result;
                 ==>
1208       
1209             // Shift Operations
1210             ALU_SLL,  ALU_SRL,
1211             ALU_SRA,
1212             // RV32B
1213             ALU_SLO,  ALU_SRO: result_o = shift_result;
                 ==>
1214       
1215             // Shuffle Operations (RV32B)
1216             ALU_SHFL, ALU_UNSHFL: result_o = shuffle_result;
                 ==>
1217       
1218             // Comparison Operations
1219             ALU_EQ,   ALU_NE,
1220             ALU_GE,   ALU_GEU,
1221             ALU_LT,   ALU_LTU,
1222             ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};
                 ==>
1223       
1224             // MinMax Operations (RV32B)
1225             ALU_MIN,  ALU_MAX,
1226             ALU_MINU, ALU_MAXU: result_o = minmax_result;
                 ==>
1227       
1228             // Bitcount Operations (RV32B)
1229             ALU_CLZ, ALU_CTZ,
1230             ALU_PCNT: result_o = {26'h0, bitcnt_result};
                 ==>
1231       
1232             // Pack Operations (RV32B)
1233             ALU_PACK, ALU_PACKH,
1234             ALU_PACKU: result_o = pack_result;
                 ==>
1235       
1236             // Sign-Extend (RV32B)
1237             ALU_SEXTB, ALU_SEXTH: result_o = sext_result;
                 ==>
1238       
1239             // Ternary Bitmanip Operations (RV32B)
1240             ALU_CMIX, ALU_CMOV,
1241             ALU_FSL,  ALU_FSR,
1242             // Rotate Shift (RV32B)
1243             ALU_ROL, ALU_ROR,
1244             // Cyclic Redundancy Checks (RV32B)
1245             ALU_CRC32_W, ALU_CRC32C_W,
1246             ALU_CRC32_H, ALU_CRC32C_H,
1247             ALU_CRC32_B, ALU_CRC32C_B,
1248             // Bit Extract / Deposit (RV32B)
1249             ALU_BEXT, ALU_BDEP: result_o = multicycle_result;
                 ==>
1250       
1251             // Single-Bit Bitmanip Operations (RV32B)
1252             ALU_SBSET, ALU_SBCLR,
1253             ALU_SBINV, ALU_SBEXT: result_o = singlebit_result;
                 ==>
1254       
1255             // General Reverse / Or-combine (RV32B)
1256             ALU_GREV, ALU_GORC: result_o = rev_result;
                 ==>
1257       
1258             // Bit Field Place (RV32B)
1259             ALU_BFP: result_o = bfp_result;
                 ==>
1260       
1261             // Carry-less Multiply Operations (RV32B)
1262             ALU_CLMUL, ALU_CLMULR,
1263             ALU_CLMULH: result_o = clmul_result;
                 ==>
1264       
1265             default: ;
                 ==>

Branches:

-1-                                                                                                                                                          Status      
ALU_XOR ALU_XNOR ALU_OR ALU_ORN ALU_AND ALU_ANDN                                                                                                             Not Covered 
ALU_ADD ALU_SUB                                                                                                                                              Not Covered 
ALU_SLL ALU_SRL ALU_SRA ALU_SLO ALU_SRO                                                                                                                      Not Covered 
ALU_SHFL ALU_UNSHFL                                                                                                                                          Not Covered 
ALU_EQ ALU_NE ALU_GE ALU_GEU ALU_LT ALU_LTU ALU_SLT ALU_SLTU                                                                                                 Covered     
ALU_MIN ALU_MAX ALU_MINU ALU_MAXU                                                                                                                            Not Covered 
ALU_CLZ ALU_CTZ ALU_PCNT                                                                                                                                     Not Covered 
ALU_PACK ALU_PACKH ALU_PACKU                                                                                                                                 Not Covered 
ALU_SEXTB ALU_SEXTH                                                                                                                                          Not Covered 
CASEITEM-10: ALU_CMIX ALU_CMOV ALU_FSL ALU_FSR ALU_ROL ALU_ROR ALU_CRC32_W ALU_CRC32C_W ALU_CRC32_H ALU_CRC32C_H ALU_CRC32_B ALU_CRC32C_B ALU_BEXT ALU_BDEP  Not Covered 
ALU_SBSET ALU_SBCLR ALU_SBINV ALU_SBEXT                                                                                                                      Not Covered 
ALU_GREV ALU_GORC                                                                                                                                            Not Covered 
ALU_BFP                                                                                                                                                      Not Covered 
ALU_CLMUL ALU_CLMULR ALU_CLMULH                                                                                                                              Not Covered 
default                                                                                                                                                      Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.ex_block_i.alu_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 25.00  46.48  27.27   0.00  26.23 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 25.00  46.48  27.27   0.00  26.23 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME     
 25.00  46.48  27.27   0.00  26.23 --     ibex_alu 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 33.33 --      50.00   0.00  50.00 --     ex_block_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : prim_clock_gating
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 25.00 --     --      25.00 --     --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/prim_clock_gating.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                    
 25.00 --     --      25.00 --     --     tb_top.DUT.u_ibex_top.core_clock_gate_i 



-------------------------------------------------------------------------------
Toggle Coverage for Module : prim_clock_gating
                Total Covered Percent 
Totals          4     1       25.00   
Total Bits      8     2       25.00   
Total Bits 0->1 4     1       25.00   
Total Bits 1->0 4     1       25.00   

                          
Ports          4 1 25.00  
Port Bits      8 2 25.00  
Port Bits 0->1 4 1 25.00  
Port Bits 1->0 4 1 25.00  

Port Details
          Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i     Yes    Yes         Yes         INPUT     
en_i      No     No          No          INPUT     
test_en_i No     No          No          INPUT     
clk_o     No     No          No          OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.core_clock_gate_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 25.00 --     --      25.00 --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 74.07 100.00 --      22.22 100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME              
 25.00 --     --      25.00 --     --     prim_clock_gating 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 24.31  57.14 --       0.09  40.00   0.00 u_ibex_top 


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                       
 73.33 100.00 --      20.00 100.00 --     gen_generic.u_impl_generic 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_wb_stage
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 25.00 --      50.00   0.00  50.00   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_wb_stage.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                         
 25.00 --      50.00   0.00  50.00   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.wb_stage_i 



-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_wb_stage

               Total   Covered  Percent
Conditions          2        1    50.00
Logical             2        1    50.00
Non-Logical         0        0
Event               0        0

 LINE       173
 EXPRESSION (rf_wdata_wb_mux_we[0] ? rf_wdata_wb_mux[0] : rf_wdata_wb_mux[1])
             ----------1----------

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_wb_stage
                Total Covered Percent 
Totals          33    0       0.00    
Total Bits      522   0       0.00    
Total Bits 0->1 261   0       0.00    
Total Bits 1->0 261   0       0.00    

                            
Ports          26  0 0.00   
Port Bits      442 0 0.00   
Port Bits 0->1 221 0 0.00   
Port Bits 1->0 221 0 0.00   

                             
Signals          7  0 0.00   
Signal Bits      80 0 0.00   
Signal Bits 0->1 40 0 0.00   
Signal Bits 1->0 40 0 0.00   

Port Details
                               Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                          No     No          No          INPUT     
rst_ni                         No     No          No          INPUT     
en_wb_i                        No     No          No          INPUT     
instr_type_wb_i[1:0]           No     No          No          INPUT     
pc_id_i[31:0]                  No     No          No          INPUT     
instr_is_compressed_id_i       No     No          No          INPUT     
instr_perf_count_id_i          No     No          No          INPUT     
ready_wb_o                     No     No          No          OUTPUT    
rf_write_wb_o                  No     No          No          OUTPUT    
outstanding_load_wb_o          No     No          No          OUTPUT    
outstanding_store_wb_o         No     No          No          OUTPUT    
pc_wb_o[31:0]                  No     No          No          OUTPUT    
perf_instr_ret_wb_o            No     No          No          OUTPUT    
perf_instr_ret_compressed_wb_o No     No          No          OUTPUT    
rf_waddr_id_i[4:0]             No     No          No          INPUT     
rf_wdata_id_i[31:0]            No     No          No          INPUT     
rf_we_id_i                     No     No          No          INPUT     
rf_wdata_lsu_i[31:0]           No     No          No          INPUT     
rf_we_lsu_i                    No     No          No          INPUT     
rf_wdata_fwd_wb_o[31:0]        No     No          No          OUTPUT    
rf_waddr_wb_o[4:0]             No     No          No          OUTPUT    
rf_wdata_wb_o[31:0]            No     No          No          OUTPUT    
rf_we_wb_o                     No     No          No          OUTPUT    
lsu_resp_valid_i               No     No          No          INPUT     
lsu_resp_err_i                 No     No          No          INPUT     
instr_done_wb_o                No     No          No          OUTPUT    

Signal Details
                                      Toggle Toggle 1->0 Toggle 0->1 
rf_wdata_wb_mux_we[1:0]               No     No          No          
fcov_wb_valid                         No     No          No          
unused_fcov_wb_valid                  No     No          No          
g_bypass_wb.unused_clk                No     No          No          
g_bypass_wb.unused_rst                No     No          No          
g_bypass_wb.unused_instr_type_wb[1:0] No     No          No          
g_bypass_wb.unused_pc_id[31:0]        No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_wb_stage
         Line No. Total Covered Percent 
Branches          2     1       50.00   
TERNARY  173      2     1       50.00   


173          assign rf_wdata_wb_o = rf_wdata_wb_mux_we[0] ? rf_wdata_wb_mux[0] : rf_wdata_wb_mux[1];
                                                          -1-  
                                                          ==>  
                                                          ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_wb_stage
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                     Attempts Real Successes Failures Incomplete 
RFWriteFromOneSourceOnly 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.wb_stage_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 25.00 --      50.00   0.00  50.00   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 25.00 --      50.00   0.00  50.00   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME          
 25.00 --      50.00   0.00  50.00   0.00 ibex_wb_stage 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME        
 20.58  43.66  14.29   0.00  28.26  16.67 u_ibex_core 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_register_file_ff
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 28.04  50.79 --       0.00  33.33 --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_register_file_ff.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                 
 28.04  50.79 --       0.00  33.33 --     tb_top.DUT.u_ibex_top.gen_regfile_ff.register_file_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_register_file_ff

             Line No.   Total   Covered  Percent
TOTAL                      126       64    50.79
ALWAYS             49        2        2   100.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00
ALWAYS             57        4        2    50.00

48                        always_comb begin : we_a_decoder
49         1/1              for (int unsigned i = 1; i < NUM_WORDS; i++) begin
50         1/1                we_a_dec[i] = (waddr_a_i == 5'(i)) ?  we_a_i : 1'b0;
51                          end
52                        end
53                      
54                        // No flops for R0 as it's hard-wired to 0
55                        for (genvar i = 1; i < NUM_WORDS; i++) begin : g_rf_flops
56                          always_ff @(posedge clk_i or negedge rst_ni) begin
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 1
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 2
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 3
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 4
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 5
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 6
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 7
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 8
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 9
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 10
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 11
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 12
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 13
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 14
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 15
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 16
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 17
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 18
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 19
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 20
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 21
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 22
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 23
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 24
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 25
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 26
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 27
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 28
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 29
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE
***repeat 30
57         1/1                if (!rst_ni) begin
58         1/1                  rf_reg_q[i] <= '0;
59         0/1     ==>        end else if(we_a_dec[i]) begin
60         0/1     ==>          rf_reg_q[i] <= wdata_a_i;
61                            end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_register_file_ff
                Total Covered Percent 
Totals          16    0       0.00    
Total Bits      4330  0       0.00    
Total Bits 0->1 2165  0       0.00    
Total Bits 1->0 2165  0       0.00    

                            
Ports          11  0 0.00   
Port Bits      232 0 0.00   
Port Bits 0->1 116 0 0.00   
Port Bits 1->0 116 0 0.00   

                               
Signals          5    0 0.00   
Signal Bits      4098 0 0.00   
Signal Bits 0->1 2049 0 0.00   
Signal Bits 1->0 2049 0 0.00   

Port Details
                 Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i            No     No          No          INPUT     
rst_ni           No     No          No          INPUT     
test_en_i        No     No          No          INPUT     
dummy_instr_id_i No     No          No          INPUT     
raddr_a_i[4:0]   No     No          No          INPUT     
rdata_a_o[31:0]  No     No          No          OUTPUT    
raddr_b_i[4:0]   No     No          No          INPUT     
rdata_b_o[31:0]  No     No          No          OUTPUT    
waddr_a_i[4:0]   No     No          No          INPUT     
wdata_a_i[31:0]  No     No          No          INPUT     
we_a_i           No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
rf_reg[31:0][31:0]                No     No          No          
rf_reg_q[31:1][31:0]              No     No          No          
we_a_dec[31:1]                    No     No          No          
unused_test_en                    No     No          No          
g_normal_r0.unused_dummy_instr_id No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_register_file_ff
         Line No. Total Covered Percent 
Branches          93    31      33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   
IF       57       3     1       33.33   


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


57               if (!rst_ni) begin
                 -1-  
58                 rf_reg_q[i] <= '0;
                   ==>
59               end else if(we_a_dec[i]) begin
                          -2-  
60                 rf_reg_q[i] <= wdata_a_i;
                   ==>
61               end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Not Covered 
0   0   Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.gen_regfile_ff.register_file_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 28.04  50.79 --       0.00  33.33 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 28.04  50.79 --       0.00  33.33 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                  
 28.04  50.79 --       0.00  33.33 --     ibex_register_file_ff 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 24.31  57.14 --       0.09  40.00   0.00 u_ibex_top 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_fetch_fifo
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 30.50  48.00  53.33   0.00  51.16   0.00 

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_fetch_fifo.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                                                      
 30.50  48.00  53.33   0.00  51.16   0.00 tb_top.DUT.u_ibex_top.u_ibex_core.if_stage_i.gen_prefetch_buffer.prefetch_buffer_i.fifo_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_fetch_fifo

             Line No.   Total   Covered  Percent
TOTAL                       25       12    48.00
ALWAYS            114       11        5    45.45
ALWAYS            153        2        2   100.00
ALWAYS            222        3        2    66.67
ALWAYS            231        3        1    33.33
ALWAYS            231        3        1    33.33
ALWAYS            231        3        1    33.33

113                       always_comb begin
114        1/1              if (out_addr_o[1]) begin
115                           // unaligned case
116        0/1     ==>        out_rdata_o     = rdata_unaligned;
117        0/1     ==>        out_err_o       = err_unaligned;
118        0/1     ==>        out_err_plus2_o = err_plus2;
119                     
120        0/1     ==>        if (unaligned_is_compressed) begin
121        0/1     ==>          out_valid_o = valid;
122                           end else begin
123        0/1     ==>          out_valid_o = valid_unaligned;
124                           end
125                         end else begin
126                           // aligned case
127        1/1                out_rdata_o     = rdata;
128        1/1                out_err_o       = err;
129        1/1                out_err_plus2_o = 1'b0;
130        1/1                out_valid_o     = valid;
131                         end
132                       end
133                     
134                       /////////////////////////
135                       // Instruction address //
136                       /////////////////////////
137                     
138                       // Update the address on branches and every time an instruction is driven
139                       assign instr_addr_en = clear_i | (out_ready_i & out_valid_o);
140                     
141                       // Increment the address by two every time a compressed instruction is popped
142                       assign addr_incr_two = instr_addr_q[1] ? unaligned_is_compressed :
143                                                                aligned_is_compressed;
144                     
145                       assign instr_addr_next = (instr_addr_q[31:1] +
146                                                 // Increment address by 4 or 2
147                                                 {29'd0,~addr_incr_two,addr_incr_two});
148                     
149                       assign instr_addr_d = clear_i ? in_addr_i[31:1] :
150                                                       instr_addr_next;
151                     
152                       always_ff @(posedge clk_i) begin
153        1/1              if (instr_addr_en) begin
154        1/1                instr_addr_q <= instr_addr_d;
155                         end
                   ==>  MISSING_ELSE
156                       end
157                     
158                       // Output both PC of current instruction and instruction following. PC of instruction following is
159                       // required for the branch predictor. It's used to fetch the instruction following a branch that
160                       // was not-taken but (mis)predicted taken.
161                       assign out_addr_next_o = {instr_addr_next, 1'b0};
162                       assign out_addr_o      = {instr_addr_q, 1'b0};
163                     
164                       // The LSB of the address is unused, since all addresses are halfword aligned
165                       assign unused_addr_in = in_addr_i[0];
166                     
167                       /////////////////
168                       // FIFO status //
169                       /////////////////
170                     
171                       // Indicate the fill level of fifo-entries. This is used to determine when a new request can be
172                       // made on the bus. The prefetch buffer only needs to know about the upper entries which overlap
173                       // with NUM_REQS.
174                       assign busy_o = valid_q[DEPTH-1:DEPTH-NUM_REQS];
175                     
176                       /////////////////////
177                       // FIFO management //
178                       /////////////////////
179                     
180                       // Since an entry can contain unaligned instructions, popping an entry can leave the entry valid
181                       assign pop_fifo = out_ready_i & out_valid_o & (~aligned_is_compressed | out_addr_o[1]);
182                     
183                       for (genvar i = 0; i < (DEPTH - 1); i++) begin : g_fifo_next
184                         // Calculate lowest free entry (write pointer)
185                         if (i == 0) begin : g_ent0
186                           assign lowest_free_entry[i] = ~valid_q[i];
187                         end else begin : g_ent_others
188                           assign lowest_free_entry[i] = ~valid_q[i] & valid_q[i-1];
189                         end
190                     
191                         // An entry is set when an incoming request chooses the lowest available entry
192                         assign valid_pushed[i] = (in_valid_i & lowest_free_entry[i]) |
193                                                  valid_q[i];
194                         // Popping the FIFO shifts all entries down
195                         assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];
196                         // All entries are wiped out on a clear
197                         assign valid_d[i] = valid_popped[i] & ~clear_i;
198                     
199                         // data flops are enabled if there is new data to shift into it, or
200                         assign entry_en[i] = (valid_pushed[i+1] & pop_fifo) |
201                                              // a new request is incoming and this is the lowest free entry
202                                              (in_valid_i & lowest_free_entry[i] & ~pop_fifo);
203                     
204                         // take the next entry or the incoming data
205                         assign rdata_d[i]  = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;
206                         assign err_d  [i]  = valid_q[i+1] ? err_q  [i+1] : in_err_i;
207                       end
208                       // The top entry is similar but with simpler muxing
209                       assign lowest_free_entry[DEPTH-1] = ~valid_q[DEPTH-1] & valid_q[DEPTH-2];
210                       assign valid_pushed     [DEPTH-1] = valid_q[DEPTH-1] | (in_valid_i & lowest_free_entry[DEPTH-1]);
211                       assign valid_popped     [DEPTH-1] = pop_fifo ? 1'b0 : valid_pushed[DEPTH-1];
212                       assign valid_d [DEPTH-1]          = valid_popped[DEPTH-1] & ~clear_i;
213                       assign entry_en[DEPTH-1]          = in_valid_i & lowest_free_entry[DEPTH-1];
214                       assign rdata_d [DEPTH-1]          = in_rdata_i;
215                       assign err_d   [DEPTH-1]          = in_err_i;
216                     
217                       ////////////////////
218                       // FIFO registers //
219                       ////////////////////
220                     
221                       always_ff @(posedge clk_i or negedge rst_ni) begin
222        1/1              if (!rst_ni) begin
223        1/1                valid_q <= '0;
224                         end else begin
225        0/1     ==>        valid_q <= valid_d;
226                         end
227                       end
228                     
229                       for (genvar i = 0; i < DEPTH; i++) begin : g_fifo_regs
230                         always_ff @(posedge clk_i) begin
231        1/1                if (entry_en[i]) begin
232        0/1     ==>          rdata_q[i]   <= rdata_d[i];
233        0/1     ==>          err_q[i]     <= err_d[i];
234                           end
                        MISSING_ELSE
***repeat 1
231        1/1                if (entry_en[i]) begin
232        0/1     ==>          rdata_q[i]   <= rdata_d[i];
233        0/1     ==>          err_q[i]     <= err_d[i];
234                           end
                        MISSING_ELSE
***repeat 2
231        1/1                if (entry_en[i]) begin
232        0/1     ==>          rdata_q[i]   <= rdata_d[i];
233        0/1     ==>          err_q[i]     <= err_d[i];
234                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_fetch_fifo

               Total   Covered  Percent
Conditions         30       16    53.33
Logical            30       16    53.33
Non-Logical         0        0
Event               0        0

 LINE       68
 EXPRESSION (valid_q[0] ? rdata_q[0] : in_rdata_i)
             -----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       69
 EXPRESSION (valid_q[0] ? err_q[0] : in_err_i)
             -----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       84
 EXPRESSION (valid_q[1] ? ({rdata_q[1][15:0], rdata[31:16]}) : ({in_rdata_i[15:0], rdata[31:16]}))
             -----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       92
 EXPRESSION 
 Number  Term
      1  valid_q[1] ? (((err_q[1] & (~unaligned_is_compressed)) | err_q[0])) : (((valid_q[0] & err_q[0]) | (in_err_i & ((~valid_q[0]) | (~unaligned_is_compressed))))))

-1- Status
 0  Covered
 1  Not Covered

 LINE       98
 EXPRESSION (valid_q[1] ? ((err_q[1] & (~err_q[0]))) : (((in_err_i & valid_q[0]) & (~err_q[0]))))
             -----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       102
 EXPRESSION (valid_q[1] ? 1'b1 : ((valid_q[0] & in_valid_i)))
             -----1----

-1- Status
 0  Covered
 1  Not Covered

 LINE       142
 EXPRESSION (instr_addr_q[1] ? unaligned_is_compressed : aligned_is_compressed)
             -------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       149
 EXPRESSION (clear_i ? in_addr_i[31:1] : instr_addr_next)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       211
 EXPRESSION (pop_fifo ? 1'b0 : valid_pushed[(DEPTH - 1)])
             ----1---

-1- Status
 0  Covered
 1  Not Covered

 LINE       195
 EXPRESSION (pop_fifo ? valid_pushed[(0 + 1)] : valid_pushed[0])
             ----1---

-1- Status
 0  Covered
 1  Not Covered

 LINE       205
 EXPRESSION (valid_q[(0 + 1)] ? rdata_q[(0 + 1)] : in_rdata_i)
             --------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       206
 EXPRESSION (valid_q[(0 + 1)] ? err_q[(0 + 1)] : in_err_i)
             --------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       195
 EXPRESSION (pop_fifo ? valid_pushed[(1 + 1)] : valid_pushed[1])
             ----1---

-1- Status
 0  Covered
 1  Not Covered

 LINE       205
 EXPRESSION (valid_q[(1 + 1)] ? rdata_q[(1 + 1)] : in_rdata_i)
             --------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       206
 EXPRESSION (valid_q[(1 + 1)] ? err_q[(1 + 1)] : in_err_i)
             --------1-------

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_fetch_fifo
                Total Covered Percent 
Totals          41    0       0.00    
Total Bits      1110  0       0.00    
Total Bits 0->1 555   0       0.00    
Total Bits 1->0 555   0       0.00    

                            
Ports          15  0 0.00   
Port Bits      342 0 0.00   
Port Bits 0->1 171 0 0.00   
Port Bits 1->0 171 0 0.00   

                              
Signals          26  0 0.00   
Signal Bits      768 0 0.00   
Signal Bits 0->1 384 0 0.00   
Signal Bits 1->0 384 0 0.00   

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                 No     No          No          INPUT     
rst_ni                No     No          No          INPUT     
clear_i               No     No          No          INPUT     
busy_o[1:0]           No     No          No          OUTPUT    
in_valid_i            No     No          No          INPUT     
in_addr_i[31:0]       No     No          No          INPUT     
in_rdata_i[31:0]      No     No          No          INPUT     
in_err_i              No     No          No          INPUT     
out_valid_o           No     No          No          OUTPUT    
out_ready_i           No     No          No          INPUT     
out_addr_o[31:0]      No     No          No          OUTPUT    
out_addr_next_o[31:0] No     No          No          OUTPUT    
out_rdata_o[31:0]     No     No          No          OUTPUT    
out_err_o             No     No          No          OUTPUT    
out_err_plus2_o       No     No          No          OUTPUT    

Signal Details
                        Toggle Toggle 1->0 Toggle 0->1 
rdata_d[2:0][31:0]      No     No          No          
rdata_q[2:0][31:0]      No     No          No          
err_d[2:0]              No     No          No          
err_q[2:0]              No     No          No          
valid_d[2:0]            No     No          No          
valid_q[2:0]            No     No          No          
lowest_free_entry[2:0]  No     No          No          
valid_pushed[2:0]       No     No          No          
valid_popped[2:0]       No     No          No          
entry_en[2:0]           No     No          No          
pop_fifo                No     No          No          
rdata[31:0]             No     No          No          
rdata_unaligned[31:0]   No     No          No          
err                     No     No          No          
err_unaligned           No     No          No          
err_plus2               No     No          No          
valid                   No     No          No          
valid_unaligned         No     No          No          
aligned_is_compressed   No     No          No          
unaligned_is_compressed No     No          No          
addr_incr_two           No     No          No          
instr_addr_next[31:1]   No     No          No          
instr_addr_d[31:1]      No     No          No          
instr_addr_q[31:1]      No     No          No          
instr_addr_en           No     No          No          
unused_addr_in          No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_fetch_fifo
         Line No. Total Covered Percent 
Branches          43    22      51.16   
TERNARY  68       2     1       50.00   
TERNARY  69       2     1       50.00   
TERNARY  84       2     1       50.00   
TERNARY  92       2     1       50.00   
TERNARY  98       2     1       50.00   
TERNARY  102      2     1       50.00   
TERNARY  142      2     1       50.00   
TERNARY  149      2     2       100.00  
TERNARY  211      2     1       50.00   
TERNARY  195      2     1       50.00   
TERNARY  205      2     1       50.00   
TERNARY  206      2     1       50.00   
TERNARY  195      2     1       50.00   
TERNARY  205      2     1       50.00   
TERNARY  206      2     1       50.00   
IF       114      3     1       33.33   
IF       153      2     1       50.00   
IF       222      2     1       50.00   
IF       231      2     1       50.00   
IF       231      2     1       50.00   
IF       231      2     1       50.00   


68           assign rdata = valid_q[0] ? rdata_q[0] : in_rdata_i;
                                       -1-  
                                       ==>  
                                       ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


69           assign err   = valid_q[0] ? err_q[0]   : in_err_i;
                                       -1-  
                                       ==>  
                                       ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


84           assign rdata_unaligned = valid_q[1] ? {rdata_q[1][15:0], rdata[31:16]} :
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


92           assign err_unaligned   = valid_q[1] ? ((err_q[1] & ~unaligned_is_compressed) | err_q[0]) :
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


98           assign err_plus2       = valid_q[1] ? (err_q[1] & ~err_q[0]) :
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


102          assign valid_unaligned = valid_q[1] ? 1'b1 :
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


142          assign addr_incr_two = instr_addr_q[1] ? unaligned_is_compressed :
                                                    -1-  
                                                    ==>  
                                                    ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


149          assign instr_addr_d = clear_i ? in_addr_i[31:1] :
                                           -1-  
                                           ==>  
                                           ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


211          assign valid_popped     [DEPTH-1] = pop_fifo ? 1'b0 : valid_pushed[DEPTH-1];
                                                          -1-  
                                                          ==>  
                                                          ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


195            assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


205            assign rdata_d[i]  = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


206            assign err_d  [i]  = valid_q[i+1] ? err_q  [i+1] : in_err_i;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


195            assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


205            assign rdata_d[i]  = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


206            assign err_d  [i]  = valid_q[i+1] ? err_q  [i+1] : in_err_i;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


114            if (out_addr_o[1]) begin
               -1-  
115              // unaligned case
116              out_rdata_o     = rdata_unaligned;
117              out_err_o       = err_unaligned;
118              out_err_plus2_o = err_plus2;
119        
120              if (unaligned_is_compressed) begin
                 -2-  
121                out_valid_o = valid;
                   ==>
122              end else begin
123                out_valid_o = valid_unaligned;
                   ==>
124              end
125            end else begin
126              // aligned case
127              out_rdata_o     = rdata;
                 ==>

Branches:

-1- -2- Status      
1   1   Not Covered 
1   0   Not Covered 
0   -   Covered     


153            if (instr_addr_en) begin
               -1-  
154              instr_addr_q <= instr_addr_d;
                 ==>
155            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


222            if (!rst_ni) begin
               -1-  
223              valid_q <= '0;
                 ==>
224            end else begin
225              valid_q <= valid_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


231              if (entry_en[i]) begin
                 -1-  
232                rdata_q[i]   <= rdata_d[i];
                   ==>
233                err_q[i]     <= err_d[i];
234              end
                 MISSING_ELSE
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


231              if (entry_en[i]) begin
                 -1-  
232                rdata_q[i]   <= rdata_d[i];
                   ==>
233                err_q[i]     <= err_d[i];
234              end
                 MISSING_ELSE
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


231              if (entry_en[i]) begin
                 -1-  
232                rdata_q[i]   <= rdata_d[i];
                   ==>
233                err_q[i]     <= err_d[i];
234              end
                 MISSING_ELSE
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_fetch_fifo
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       2     2         100.00  0                 0.00    
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            2     2         100.00  0                 0.00    



-------------------------------------------------------------------------------

Assertion Details

Name                     Attempts Real Successes Failures Incomplete 
IbexFetchFifoPushFull    3        0              0        0          
IbexFetchFifoPushPopFull 3        0              0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.if_stage_i.gen_prefetch_buffer.prefetch_buffer_i.fifo_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 30.50  48.00  53.33   0.00  51.16   0.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 30.50  48.00  53.33   0.00  51.16   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME            
 30.50  48.00  53.33   0.00  51.16   0.00 ibex_fetch_fifo 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                  
 40.00  60.00  50.00   0.00  50.00 --     gen_prefetch_buffer.prefetch_buffer_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : uvm_custom_install_recording
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 31.67  33.33 --     --      30.00 --     

Source File(s) : 

/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/vcs/uvm_custom_install_vcs_recorder.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                         
 31.67  33.33 --     --      30.00 --     uvm_custom_install_recording 



-------------------------------------------------------------------------------
Line Coverage for Module : uvm_custom_install_recording

             Line No.   Total   Covered  Percent
TOTAL                       21        7    33.33
INITIAL            40       21        7    33.33

39                      
40         1/1               clp = uvm_cmdline_processor::get_inst();
41         1/1               cs = uvm_coreservice_t::get();
42         1/1               env_str = getenv("SNPS_SIM_DEFAULT_GUI");
43         1/1               vc_env_str = getenv("VC_HOME");
44         1/1               if (vc_env_str!="")begin
45         0/1     ==>           sanity_file_name = {vc_env_str,"/etc/.sanity"};
46         0/1     ==>           file_handle = $fopen(sanity_file_name,"r");
47         0/1     ==>           if (file_handle!=0) begin
48         0/1     ==>               is_sanity_exist = 1;
49         0/1     ==>               $fclose(file_handle);
50                               end
                   ==>  MISSING_ELSE
51                           end
                        MISSING_ELSE
52                      
53                           // Register the vcs_smartlog_catcher to dump messages into VPD
54         1/1               if (clp.get_arg_matches("+UVM_LOG_RECORD", tr_args) && (!clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args) 
55                                                                                  && (env_str != "verdi") && !is_sanity_exist)) begin
56                             static vcs_smartlog_catcher _vcs_catcher = new();
57         0/1     ==>         uvm_report_cb::add(null,_vcs_catcher);
58                           end
                        MISSING_ELSE
59                      
60                           // Register the uvm_vcs_recorder to record transactions into VPD
61         1/1               if (clp.get_arg_matches("+UVM_TR_RECORD", tr_args) && (!clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args)
62                                                                                  && (env_str != "verdi")&& !is_sanity_exist)) begin
63         0/1     ==>        vcs_db = new();
64         0/1     ==>        cs.set_default_tr_database(vcs_db);
65         0/1     ==>        if (clp.get_arg_matches("+UVM_DISABLE_AUTO_COMPONENT", tr_args)) begin
66         0/2     ==>  	 `uvm_info("VCS_TR_AUTO", "+UVM_DISABLE_AUTO_COMPONENT enabled but transaction recording enabled, usage model requires user to explicitly set recording_detail on components", UVM_MEDIUM)
uvm_info("VCS_TR_AUTO", "+UVM_DISABLE_AUTO_COMPONENT enabled but transaction recording enabled, usage model requires user to explicitly set recording_detail on components", UVM_MEDIUM):
66.1                    begin 
66.2       0/1     ==>       if (uvm_report_enabled(UVM_MEDIUM,UVM_INFO,"VCS_TR_AUTO")) 
66.3       0/1     ==>         uvm_report_info ("VCS_TR_AUTO", "+UVM_DISABLE_AUTO_COMPONENT enabled but transaction recording enabled, usage model requires user to explicitly set recording_detail on components", UVM_MEDIUM, "/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/vcs/uvm_custom_install_vcs_recorder.sv", 66, "", 1); 
66.4                       end
                   ==>  MISSING_ELSE
67                            end
68                            else begin
69         0/2     ==>  	 `uvm_info("VCS_TR_AUTO", "+UVM_TR_RECORD implicitly enables recording_details to UVM_FULL for all components. For explicit control use +UVM_DISABLE_AUTO_COMPONENT and set recording_detail on components accordingly", UVM_MEDIUM)
uvm_info("VCS_TR_AUTO", "+UVM_TR_RECORD implicitly enables recording_details to UVM_FULL for all components. For explicit control use +UVM_DISABLE_AUTO_COMPONENT and set recording_detail on components accordingly", UVM_MEDIUM):
69.1                    begin 
69.2       0/1     ==>       if (uvm_report_enabled(UVM_MEDIUM,UVM_INFO,"VCS_TR_AUTO")) 
69.3       0/1     ==>         uvm_report_info ("VCS_TR_AUTO", "+UVM_TR_RECORD implicitly enables recording_details to UVM_FULL for all components. For explicit control use +UVM_DISABLE_AUTO_COMPONENT and set recording_detail on components accordingly", UVM_MEDIUM, "/usr/synopsys/vcs-L-2016.06//etc/uvm-1.2/vcs/uvm_custom_install_vcs_recorder.sv", 69, "", 1); 
69.4                       end
                   ==>  MISSING_ELSE
70         0/1     ==>  	  uvm_config_db#(uvm_bitstream_t)::set(uvm_root::get(), "*", "recording_detail", UVM_FULL);
71                            end
72                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Module : uvm_custom_install_recording
         Line No. Total Covered Percent 
Branches          10    3       30.00   
IF       44       3     1       33.33   
IF       54       2     1       50.00   
IF       61       5     1       20.00   


44              if (vc_env_str!="")begin
                -1-  
45                  sanity_file_name = {vc_env_str,"/etc/.sanity"};
46                  file_handle = $fopen(sanity_file_name,"r");
47                  if (file_handle!=0) begin
                    -2-  
48                      is_sanity_exist = 1;
                        ==>
49                      $fclose(file_handle);
50                  end
                    MISSING_ELSE
                    ==>
51              end
                MISSING_ELSE
                ==>

Branches:

-1- -2- Status      
1   1   Not Covered 
1   0   Not Covered 
0   -   Covered     


54              if (clp.get_arg_matches("+UVM_LOG_RECORD", tr_args) && (!clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args) 
                -1-  
55                                                                     && (env_str != "verdi") && !is_sanity_exist)) begin
56                static vcs_smartlog_catcher _vcs_catcher = new();
57                uvm_report_cb::add(null,_vcs_catcher);
                  ==>
58              end
                MISSING_ELSE
                ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


61              if (clp.get_arg_matches("+UVM_TR_RECORD", tr_args) && (!clp.get_arg_matches("+UVM_VERDI_TRACE", tr_args)
                -1-  
62                                                                     && (env_str != "verdi")&& !is_sanity_exist)) begin
63               vcs_db = new();
64               cs.set_default_tr_database(vcs_db);
65               if (clp.get_arg_matches("+UVM_DISABLE_AUTO_COMPONENT", tr_args)) begin
                 -2-  
66         	 `uvm_info("VCS_TR_AUTO", "+UVM_DISABLE_AUTO_COMPONENT enabled but transaction recording enabled, usage model requires user to explicitly set recording_detail on components", UVM_MEDIUM)
           	 -3-                                                                                                                                                                                         
           	 ==>
           	 MISSING_ELSE
           	 ==>
67               end
68               else begin
69         	 `uvm_info("VCS_TR_AUTO", "+UVM_TR_RECORD implicitly enables recording_details to UVM_FULL for all components. For explicit control use +UVM_DISABLE_AUTO_COMPONENT and set recording_detail on components accordingly", UVM_MEDIUM)
           	 -4-                                                                                                                                                                                                                                   
           	 ==>
           	 MISSING_ELSE
           	 ==>
70         	  uvm_config_db#(uvm_bitstream_t)::set(uvm_root::get(), "*", "recording_detail", UVM_FULL);
71               end
72              end
                MISSING_ELSE
                ==>

Branches:

-1- -2- -3- -4- Status      
1   1   1   -   Not Covered 
1   1   0   -   Not Covered 
1   0   -   1   Not Covered 
1   0   -   0   Not Covered 
0   -   -   -   Covered     


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvm_custom_install_recording
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 31.67  33.33 --     --      30.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 31.67  33.33 --     --      30.00 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                         
 31.67  33.33 --     --      30.00 --     uvm_custom_install_recording 


Parent : 

none
----------------


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_ex_block
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 33.33 --      50.00   0.00  50.00 --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_ex_block.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                         
 33.33 --      50.00   0.00  50.00 --     tb_top.DUT.u_ibex_top.u_ibex_core.ex_block_i 



-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_ex_block

               Total   Covered  Percent
Conditions         10        5    50.00
Logical            10        5    50.00
Non-Logical         0        0
Event               0        0

 LINE       83
 EXPRESSION (multdiv_sel ? multdiv_imd_val_d[0] : ({2'b0, alu_imd_val_d[0]}))
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       84
 EXPRESSION (multdiv_sel ? multdiv_imd_val_d[1] : ({2'b0, alu_imd_val_d[1]}))
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       85
 EXPRESSION (multdiv_sel ? multdiv_imd_val_we : alu_imd_val_we)
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       89
 EXPRESSION (multdiv_sel ? multdiv_result : alu_result)
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       197
 EXPRESSION (multdiv_sel ? multdiv_valid : ((~(|alu_imd_val_we))))
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_ex_block
                Total Covered Percent 
Totals          37    0       0.00    
Total Bits      1094  0       0.00    
Total Bits 0->1 547   0       0.00    
Total Bits 1->0 547   0       0.00    

                            
Ports          24  0 0.00   
Port Bits      622 0 0.00   
Port Bits 0->1 311 0 0.00   
Port Bits 1->0 311 0 0.00   

                              
Signals          13  0 0.00   
Signal Bits      472 0 0.00   
Signal Bits 0->1 236 0 0.00   
Signal Bits 1->0 236 0 0.00   

Port Details
                            Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                       No     No          No          INPUT     
rst_ni                      No     No          No          INPUT     
alu_operator_i[5:0]         No     No          No          INPUT     
alu_operand_a_i[31:0]       No     No          No          INPUT     
alu_operand_b_i[31:0]       No     No          No          INPUT     
alu_instr_first_cycle_i     No     No          No          INPUT     
bt_a_operand_i[31:0]        No     No          No          INPUT     
bt_b_operand_i[31:0]        No     No          No          INPUT     
multdiv_operator_i[1:0]     No     No          No          INPUT     
mult_en_i                   No     No          No          INPUT     
div_en_i                    No     No          No          INPUT     
mult_sel_i                  No     No          No          INPUT     
div_sel_i                   No     No          No          INPUT     
multdiv_signed_mode_i[1:0]  No     No          No          INPUT     
multdiv_operand_a_i[31:0]   No     No          No          INPUT     
multdiv_operand_b_i[31:0]   No     No          No          INPUT     
multdiv_ready_id_i          No     No          No          INPUT     
data_ind_timing_i           No     No          No          INPUT     
imd_val_we_o[1:0]           No     No          No          OUTPUT    
alu_adder_result_ex_o[31:0] No     No          No          OUTPUT    
result_ex_o[31:0]           No     No          No          OUTPUT    
branch_target_o[31:0]       No     No          No          OUTPUT    
branch_decision_o           No     No          No          OUTPUT    
ex_valid_o                  No     No          No          OUTPUT    

Signal Details
                                                 Toggle Toggle 1->0 Toggle 0->1 
alu_result[31:0]                                 No     No          No          
multdiv_result[31:0]                             No     No          No          
multdiv_alu_operand_b[32:0]                      No     No          No          
multdiv_alu_operand_a[32:0]                      No     No          No          
alu_adder_result_ext[33:0]                       No     No          No          
alu_cmp_result                                   No     No          No          
alu_is_equal_result                              No     No          No          
multdiv_valid                                    No     No          No          
multdiv_sel                                      No     No          No          
alu_imd_val_we[1:0]                              No     No          No          
multdiv_imd_val_we[1:0]                          No     No          No          
g_no_branch_target_alu.unused_bt_a_operand[31:0] No     No          No          
g_no_branch_target_alu.unused_bt_b_operand[31:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_ex_block
         Line No. Total Covered Percent 
Branches          10    5       50.00   
TERNARY  83       2     1       50.00   
TERNARY  84       2     1       50.00   
TERNARY  85       2     1       50.00   
TERNARY  89       2     1       50.00   
TERNARY  197      2     1       50.00   


83           assign imd_val_d_o[0] = multdiv_sel ? multdiv_imd_val_d[0] : {2'b0, alu_imd_val_d[0]};
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


84           assign imd_val_d_o[1] = multdiv_sel ? multdiv_imd_val_d[1] : {2'b0, alu_imd_val_d[1]};
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


85           assign imd_val_we_o   = multdiv_sel ? multdiv_imd_val_we : alu_imd_val_we;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


89           assign result_ex_o  = multdiv_sel ? multdiv_result : alu_result;
                                               -1-  
                                               ==>  
                                               ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


197          assign ex_valid_o = multdiv_sel ? multdiv_valid : ~(|alu_imd_val_we);
                                             -1-  
                                             ==>  
                                             ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.ex_block_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 33.33 --      50.00   0.00  50.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 18.04  41.75  21.67   0.00  26.79   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME          
 33.33 --      50.00   0.00  50.00 --     ibex_ex_block 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME        
 20.58  43.66  14.29   0.00  28.26  16.67 u_ibex_core 


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                       
 25.00  46.48  27.27   0.00  26.23 --     alu_i                      
 13.62  39.02   7.14   0.00  21.95   0.00 gen_multdiv_fast.multdiv_i 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_prefetch_buffer
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 40.00  60.00  50.00   0.00  50.00 --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_prefetch_buffer.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                                               
 40.00  60.00  50.00   0.00  50.00 --     tb_top.DUT.u_ibex_top.u_ibex_core.if_stage_i.gen_prefetch_buffer.prefetch_buffer_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_prefetch_buffer

             Line No.   Total   Covered  Percent
TOTAL                       15        9    60.00
ALWAYS            185        2        1    50.00
ALWAYS            228        2        2   100.00
ALWAYS            296       11        6    54.55

184                       always_ff @(posedge clk_i) begin
185        1/1              if (stored_addr_en) begin
186        0/1     ==>        stored_addr_q <= stored_addr_d;
187                         end
                        MISSING_ELSE
188                       end
189                     
190                       if (BranchPredictor) begin : g_branch_predictor
191                         // Where the branch predictor is present record what address followed a predicted branch.  If
192                         // that branch is predicted taken but mispredicted (so not-taken) this is used to resume on
193                         // the not-taken code path.
194                         logic [31:0] branch_mispredict_addr_q;
195                         logic        branch_mispredict_addr_en;
196                     
197                         assign branch_mispredict_addr_en = branch_i & predicted_branch_i;
198                     
199                         always_ff @(posedge clk_i) begin
200                           if (branch_mispredict_addr_en) begin
201                             branch_mispredict_addr_q <= addr_next;
202                           end
203                         end
204                     
205                         assign branch_mispredict_addr = branch_mispredict_addr_q;
206                       end else begin : g_no_branch_predictor
207                         logic        unused_predicted_branch;
208                         logic [31:0] unused_addr_next;
209                     
210                         assign unused_predicted_branch = predicted_branch_i;
211                         assign unused_addr_next        = addr_next;
212                     
213                         assign branch_mispredict_addr = '0;
214                       end
215                     
216                       // 2. fetch_addr_q
217                     
218                       // Update on a branch or as soon as a request is issued
219                       assign fetch_addr_en = branch_or_mispredict | (valid_new_req & ~valid_req_q);
220                     
221                       assign fetch_addr_d = (branch_i            ? addr_i :
222                                              branch_mispredict_i ? {branch_mispredict_addr[31:2], 2'b00} :
223                                                                    {fetch_addr_q[31:2], 2'b00}) +
224                                             // Current address + 4
225                                             {{29{1'b0}},(valid_new_req & ~valid_req_q),2'b00};
226                     
227                       always_ff @(posedge clk_i) begin
228        1/1              if (fetch_addr_en) begin
229        1/1                fetch_addr_q <= fetch_addr_d;
230                         end
                   ==>  MISSING_ELSE
231                       end
232                     
233                       // Address mux
234                       assign instr_addr = valid_req_q         ? stored_addr_q :
235                                           branch_spec_i       ? addr_i :
236                                           branch_mispredict_i ? branch_mispredict_addr :
237                                                                 fetch_addr_q;
238                     
239                       assign instr_addr_w_aligned = {instr_addr[31:2], 2'b00};
240                     
241                       ///////////////////////////////
242                       // Request outstanding queue //
243                       ///////////////////////////////
244                     
245                       for (genvar i = 0; i < NUM_REQS; i++) begin : g_outstanding_reqs
246                         // Request 0 (always the oldest outstanding request)
247                         if (i == 0) begin : g_req0
248                           // A request becomes outstanding once granted, and is cleared once the rvalid is received.
249                           // Outstanding requests shift down the queue towards entry 0.
250                           assign rdata_outstanding_n[i] = (valid_req & gnt_or_pmp_err) |
251                                                           rdata_outstanding_q[i];
252                           // If a branch is received at any point while a request is outstanding, it must be tracked
253                           // to ensure we discard the data once received
254                           assign branch_discard_n[i]    = (valid_req & gnt_or_pmp_err & discard_req_d) |
255                                                           (branch_or_mispredict & rdata_outstanding_q[i]) |
256                                                           branch_discard_q[i];
257                           // Record whether this request received a PMP error
258                           assign rdata_pmp_err_n[i]     = (valid_req & ~rdata_outstanding_q[i] & instr_pmp_err_i) |
259                                                           rdata_pmp_err_q[i];
260                     
261                         end else begin : g_reqtop
262                         // Entries > 0 consider the FIFO fill state to calculate their next state (by checking
263                         // whether the previous entry is valid)
264                     
265                           assign rdata_outstanding_n[i] = (valid_req & gnt_or_pmp_err &
266                                                            rdata_outstanding_q[i-1]) |
267                                                           rdata_outstanding_q[i];
268                           assign branch_discard_n[i]    = (valid_req & gnt_or_pmp_err & discard_req_d &
269                                                            rdata_outstanding_q[i-1]) |
270                                                           (branch_or_mispredict & rdata_outstanding_q[i]) |
271                                                           branch_discard_q[i];
272                           assign rdata_pmp_err_n[i]     = (valid_req & ~rdata_outstanding_q[i] & instr_pmp_err_i &
273                                                            rdata_outstanding_q[i-1]) |
274                                                           rdata_pmp_err_q[i];
275                         end
276                       end
277                     
278                       // Shift the entries down on each instr_rvalid_i
279                       assign rdata_outstanding_s = rvalid_or_pmp_err ? {1'b0,rdata_outstanding_n[NUM_REQS-1:1]} :
280                                                                        rdata_outstanding_n;
281                       assign branch_discard_s    = rvalid_or_pmp_err ? {1'b0,branch_discard_n[NUM_REQS-1:1]} :
282                                                                        branch_discard_n;
283                       assign rdata_pmp_err_s     = rvalid_or_pmp_err ? {1'b0,rdata_pmp_err_n[NUM_REQS-1:1]} :
284                                                                        rdata_pmp_err_n;
285                     
286                       // Push a new entry to the FIFO once complete (and not cancelled by a branch)
287                       assign fifo_valid = rvalid_or_pmp_err & ~branch_discard_q[0];
288                     
289                       assign fifo_addr = branch_i ? addr_i : branch_mispredict_addr;
290                     
291                       ///////////////
292                       // Registers //
293                       ///////////////
294                     
295                       always_ff @(posedge clk_i or negedge rst_ni) begin
296        1/1              if (!rst_ni) begin
297        1/1                valid_req_q          <= 1'b0;
298        1/1                discard_req_q        <= 1'b0;
299        1/1                rdata_outstanding_q  <= 'b0;
300        1/1                branch_discard_q     <= 'b0;
301        1/1                rdata_pmp_err_q      <= 'b0;
302                         end else begin
303        0/1     ==>        valid_req_q          <= valid_req_d;
304        0/1     ==>        discard_req_q        <= discard_req_d;
305        0/1     ==>        rdata_outstanding_q  <= rdata_outstanding_s;
306        0/1     ==>        branch_discard_q     <= branch_discard_s;
307        0/1     ==>        rdata_pmp_err_q      <= rdata_pmp_err_s;

-------------------------------------------------------------------------------
Cond Coverage for Module : ibex_prefetch_buffer

               Total   Covered  Percent
Conditions         14        7    50.00
Logical            14        7    50.00
Non-Logical         0        0
Event               0        0

 LINE       234
 EXPRESSION (valid_req_q ? stored_addr_q : (branch_spec_i ? addr_i : (branch_mispredict_i ? branch_mispredict_addr : fetch_addr_q)))
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       234
 SUB-EXPRESSION (branch_spec_i ? addr_i : (branch_mispredict_i ? branch_mispredict_addr : fetch_addr_q))
                 ------1------

-1- Status
 0  Not Covered
 1  Covered

 LINE       234
 SUB-EXPRESSION (branch_mispredict_i ? branch_mispredict_addr : fetch_addr_q)
                 ---------1---------

-1- Status
 0  Not Covered
 1  Not Covered

 LINE       279
 EXPRESSION (rvalid_or_pmp_err ? ({1'b0, rdata_outstanding_n[1]}) : rdata_outstanding_n)
             --------1--------

-1- Status
 0  Covered
 1  Not Covered

 LINE       281
 EXPRESSION (rvalid_or_pmp_err ? ({1'b0, branch_discard_n[1]}) : branch_discard_n)
             --------1--------

-1- Status
 0  Covered
 1  Not Covered

 LINE       283
 EXPRESSION (rvalid_or_pmp_err ? ({1'b0, rdata_pmp_err_n[1]}) : rdata_pmp_err_n)
             --------1--------

-1- Status
 0  Covered
 1  Not Covered

 LINE       289
 EXPRESSION (branch_i ? addr_i : branch_mispredict_addr)
             ----1---

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_prefetch_buffer
                Total Covered Percent 
Totals          61    0       0.00    
Total Bits      1074  0       0.00    
Total Bits 0->1 537   0       0.00    
Total Bits 1->0 537   0       0.00    

                            
Ports          22  0 0.00   
Port Bits      354 0 0.00   
Port Bits 0->1 177 0 0.00   
Port Bits 1->0 177 0 0.00   

                              
Signals          39  0 0.00   
Signal Bits      720 0 0.00   
Signal Bits 0->1 360 0 0.00   
Signal Bits 1->0 360 0 0.00   

Port Details
                    Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i               No     No          No          INPUT     
rst_ni              No     No          No          INPUT     
req_i               No     No          No          INPUT     
branch_i            No     No          No          INPUT     
branch_spec_i       No     No          No          INPUT     
predicted_branch_i  No     No          No          INPUT     
branch_mispredict_i No     No          No          INPUT     
addr_i[31:0]        No     No          No          INPUT     
ready_i             No     No          No          INPUT     
valid_o             No     No          No          OUTPUT    
rdata_o[31:0]       No     No          No          OUTPUT    
addr_o[31:0]        No     No          No          OUTPUT    
err_o               No     No          No          OUTPUT    
err_plus2_o         No     No          No          OUTPUT    
instr_req_o         No     No          No          OUTPUT    
instr_gnt_i         No     No          No          INPUT     
instr_addr_o[31:0]  No     No          No          OUTPUT    
instr_rdata_i[31:0] No     No          No          INPUT     
instr_err_i         No     No          No          INPUT     
instr_pmp_err_i     No     No          No          INPUT     
instr_rvalid_i      No     No          No          INPUT     
busy_o              No     No          No          OUTPUT    

Signal Details
                                              Toggle Toggle 1->0 Toggle 0->1 
branch_suppress                               No     No          No          
valid_new_req                                 No     No          No          
valid_req                                     No     No          No          
valid_req_d                                   No     No          No          
valid_req_q                                   No     No          No          
discard_req_d                                 No     No          No          
discard_req_q                                 No     No          No          
gnt_or_pmp_err                                No     No          No          
rvalid_or_pmp_err                             No     No          No          
rdata_outstanding_n[1:0]                      No     No          No          
rdata_outstanding_s[1:0]                      No     No          No          
rdata_outstanding_q[1:0]                      No     No          No          
branch_discard_n[1:0]                         No     No          No          
branch_discard_s[1:0]                         No     No          No          
branch_discard_q[1:0]                         No     No          No          
rdata_pmp_err_n[1:0]                          No     No          No          
rdata_pmp_err_s[1:0]                          No     No          No          
rdata_pmp_err_q[1:0]                          No     No          No          
rdata_outstanding_rev[1:0]                    No     No          No          
stored_addr_d[31:0]                           No     No          No          
stored_addr_q[31:0]                           No     No          No          
stored_addr_en                                No     No          No          
fetch_addr_d[31:0]                            No     No          No          
fetch_addr_q[31:0]                            No     No          No          
fetch_addr_en                                 No     No          No          
branch_mispredict_addr[31:0]                  No     No          No          
instr_addr[31:0]                              No     No          No          
instr_addr_w_aligned[31:0]                    No     No          No          
instr_or_pmp_err                              No     No          No          
fifo_valid                                    No     No          No          
fifo_addr[31:0]                               No     No          No          
fifo_ready                                    No     No          No          
fifo_clear                                    No     No          No          
fifo_busy[1:0]                                No     No          No          
valid_raw                                     No     No          No          
addr_next[31:0]                               No     No          No          
branch_or_mispredict                          No     No          No          
g_no_branch_predictor.unused_predicted_branch No     No          No          
g_no_branch_predictor.unused_addr_next[31:0]  No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_prefetch_buffer
         Line No. Total Covered Percent 
Branches          18    9       50.00   
TERNARY  234      4     1       25.00   
TERNARY  279      2     1       50.00   
TERNARY  281      2     1       50.00   
TERNARY  283      2     1       50.00   
TERNARY  289      2     2       100.00  
IF       185      2     1       50.00   
IF       228      2     1       50.00   
IF       296      2     1       50.00   


234          assign instr_addr = valid_req_q         ? stored_addr_q :
                                                     -1-  
                                                     ==>  
235                              branch_spec_i       ? addr_i :
                                                     -2-  
                                                     ==>  
236                              branch_mispredict_i ? branch_mispredict_addr :
                                                     -3-  
                                                     ==>  
                                                     ==>  

Branches:

-1- -2- -3- Status      
1   -   -   Not Covered 
0   1   -   Covered     
0   0   1   Not Covered 
0   0   0   Not Covered 


279          assign rdata_outstanding_s = rvalid_or_pmp_err ? {1'b0,rdata_outstanding_n[NUM_REQS-1:1]} :
                                                            -1-  
                                                            ==>  
                                                            ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


281          assign branch_discard_s    = rvalid_or_pmp_err ? {1'b0,branch_discard_n[NUM_REQS-1:1]} :
                                                            -1-  
                                                            ==>  
                                                            ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


283          assign rdata_pmp_err_s     = rvalid_or_pmp_err ? {1'b0,rdata_pmp_err_n[NUM_REQS-1:1]} :
                                                            -1-  
                                                            ==>  
                                                            ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


289          assign fifo_addr = branch_i ? addr_i : branch_mispredict_addr;
                                         -1-  
                                         ==>  
                                         ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


185            if (stored_addr_en) begin
               -1-  
186              stored_addr_q <= stored_addr_d;
                 ==>
187            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


228            if (fetch_addr_en) begin
               -1-  
229              fetch_addr_q <= fetch_addr_d;
                 ==>
230            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


296            if (!rst_ni) begin
               -1-  
297              valid_req_q          <= 1'b0;
                 ==>
298              discard_req_q        <= 1'b0;
299              rdata_outstanding_q  <= 'b0;
300              branch_discard_q     <= 'b0;
301              rdata_pmp_err_q      <= 'b0;
302            end else begin
303              valid_req_q          <= valid_req_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.if_stage_i.gen_prefetch_buffer.prefetch_buffer_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 40.00  60.00  50.00   0.00  50.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 31.12  52.50  52.27   0.00  50.82   0.00 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                 
 40.00  60.00  50.00   0.00  50.00 --     ibex_prefetch_buffer 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 13.39  28.57 --       0.00  25.00   0.00 if_stage_i 


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME   
 30.50  48.00  53.33   0.00  51.16   0.00 fifo_i 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_counter
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 43.49  73.33 --       0.00  57.14 --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/ibex_counter.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                                
 36.51  66.67 --       0.00  42.86 --     tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.minstret_counter_i 
 43.49  73.33 --       0.00  57.14 --     tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.mcycle_counter_i   



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_counter

             Line No.   Total   Covered  Percent
TOTAL                       15       11    73.33
ALWAYS             24       12        9    75.00
ALWAYS             60        3        2    66.67

23                          // Write
24         1/1              we = counter_we_i | counterh_we_i;
25         1/1              counter_load[63:32] = counter[63:32];
26         1/1              counter_load[31:0]  = counter_val_i;
27         1/1              if (counterh_we_i) begin
28         0/1     ==>        counter_load[63:32] = counter_val_i;
29         0/1     ==>        counter_load[31:0]  = counter[31:0];
30                          end
                        MISSING_ELSE
31                      
32                          // Increment
33         1/1              counter_upd = counter[CounterWidth-1:0] + {{CounterWidth-1{1'b0}},1'b1};
34                      
35                          // Next value logic
36         1/1              if (we) begin
37         0/1     ==>        counter_d = counter_load[CounterWidth-1:0];
38         1/1              end else if (counter_inc_i)begin
39         1/1                counter_d = counter_upd[CounterWidth-1:0];
40                          end else begin
41         1/1                counter_d = counter[CounterWidth-1:0];
42                          end
43                        end
44                      
45                      `ifdef FPGA_XILINX
46                        // Set DSP pragma for supported xilinx FPGAs
47                        localparam int DspPragma = CounterWidth < 49  ? "yes" : "no";
48                        (* use_dsp = DspPragma *) logic [CounterWidth-1:0] counter_q;
49                      
50                        // DSP output register requires synchronous reset.
51                        `define COUNTER_FLOP_RST posedge clk_i
52                      `else
53                        logic [CounterWidth-1:0] counter_q;
54                      
55                        `define COUNTER_FLOP_RST posedge clk_i or negedge rst_ni
56                      `endif
57                      
58                        // Counter flop
59                        always_ff @(`COUNTER_FLOP_RST) begin
60         1/1              if (!rst_ni) begin
61         1/1                counter_q <= '0;
62                          end else begin
63         0/1     ==>        counter_q <= counter_d;

-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_counter
                Total Covered Percent 
Totals          13    0       0.00    
Total Bits      844   0       0.00    
Total Bits 0->1 422   0       0.00    
Total Bits 1->0 422   0       0.00    

                            
Ports          7   0 0.00   
Port Bits      202 0 0.00   
Port Bits 0->1 101 0 0.00   
Port Bits 1->0 101 0 0.00   

                              
Signals          6   0 0.00   
Signal Bits      642 0 0.00   
Signal Bits 0->1 321 0 0.00   
Signal Bits 1->0 321 0 0.00   

Port Details
                    Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i               No     No          No          INPUT     
rst_ni              No     No          No          INPUT     
counter_inc_i       No     No          No          INPUT     
counterh_we_i       No     No          No          INPUT     
counter_we_i        No     No          No          INPUT     
counter_val_i[31:0] No     No          No          INPUT     
counter_val_o[63:0] No     No          No          OUTPUT    

Signal Details
                   Toggle Toggle 1->0 Toggle 0->1 
counter[63:0]      No     No          No          
counter_upd[63:0]  No     No          No          
counter_load[63:0] No     No          No          
we                 No     No          No          
counter_d[63:0]    No     No          No          
counter_q[63:0]    No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_counter
         Line No. Total Covered Percent 
Branches          7     4       57.14   
IF       27       2     1       50.00   
IF       36       3     2       66.67   
IF       60       2     1       50.00   


27             if (counterh_we_i) begin
               -1-  
28               counter_load[63:32] = counter_val_i;
                 ==>
29               counter_load[31:0]  = counter[31:0];
30             end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


36             if (we) begin
               -1-  
37               counter_d = counter_load[CounterWidth-1:0];
                 ==>
38             end else if (counter_inc_i)begin
                        -2-  
39               counter_d = counter_upd[CounterWidth-1:0];
                 ==>
40             end else begin
41               counter_d = counter[CounterWidth-1:0];
                 ==>

Branches:

-1- -2- Status      
1   -   Not Covered 
0   1   Covered     
0   0   Covered     


60             if (!rst_ni) begin
               -1-  
61               counter_q <= '0;
                 ==>
62             end else begin
63               counter_q <= counter_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.minstret_counter_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 36.51  66.67 --       0.00  42.86 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 36.51  66.67 --       0.00  42.86 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME         
 43.49  73.33 --       0.00  57.14 --     ibex_counter 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.minstret_counter_i

             Line No.   Total   Covered  Percent
TOTAL                       15       10    66.67
ALWAYS             24       12        8    66.67
ALWAYS             60        3        2    66.67

23                          // Write
24         1/1              we = counter_we_i | counterh_we_i;
25         1/1              counter_load[63:32] = counter[63:32];
26         1/1              counter_load[31:0]  = counter_val_i;
27         1/1              if (counterh_we_i) begin
28         0/1     ==>        counter_load[63:32] = counter_val_i;
29         0/1     ==>        counter_load[31:0]  = counter[31:0];
30                          end
                        MISSING_ELSE
31                      
32                          // Increment
33         1/1              counter_upd = counter[CounterWidth-1:0] + {{CounterWidth-1{1'b0}},1'b1};
34                      
35                          // Next value logic
36         1/1              if (we) begin
37         0/1     ==>        counter_d = counter_load[CounterWidth-1:0];
38         1/1              end else if (counter_inc_i)begin
39         0/1     ==>        counter_d = counter_upd[CounterWidth-1:0];
40                          end else begin
41         1/1                counter_d = counter[CounterWidth-1:0];
42                          end
43                        end
44                      
45                      `ifdef FPGA_XILINX
46                        // Set DSP pragma for supported xilinx FPGAs
47                        localparam int DspPragma = CounterWidth < 49  ? "yes" : "no";
48                        (* use_dsp = DspPragma *) logic [CounterWidth-1:0] counter_q;
49                      
50                        // DSP output register requires synchronous reset.
51                        `define COUNTER_FLOP_RST posedge clk_i
52                      `else
53                        logic [CounterWidth-1:0] counter_q;
54                      
55                        `define COUNTER_FLOP_RST posedge clk_i or negedge rst_ni
56                      `endif
57                      
58                        // Counter flop
59                        always_ff @(`COUNTER_FLOP_RST) begin
60         1/1              if (!rst_ni) begin
61         1/1                counter_q <= '0;
62                          end else begin
63         0/1     ==>        counter_q <= counter_d;

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.minstret_counter_i
                Total Covered Percent 
Totals          13    0       0.00    
Total Bits      844   0       0.00    
Total Bits 0->1 422   0       0.00    
Total Bits 1->0 422   0       0.00    

                            
Ports          7   0 0.00   
Port Bits      202 0 0.00   
Port Bits 0->1 101 0 0.00   
Port Bits 1->0 101 0 0.00   

                              
Signals          6   0 0.00   
Signal Bits      642 0 0.00   
Signal Bits 0->1 321 0 0.00   
Signal Bits 1->0 321 0 0.00   

Port Details
                    Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i               No     No          No          INPUT     
rst_ni              No     No          No          INPUT     
counter_inc_i       No     No          No          INPUT     
counterh_we_i       No     No          No          INPUT     
counter_we_i        No     No          No          INPUT     
counter_val_i[31:0] No     No          No          INPUT     
counter_val_o[63:0] No     No          No          OUTPUT    

Signal Details
                   Toggle Toggle 1->0 Toggle 0->1 
counter[63:0]      No     No          No          
counter_upd[63:0]  No     No          No          
counter_load[63:0] No     No          No          
we                 No     No          No          
counter_d[63:0]    No     No          No          
counter_q[63:0]    No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.minstret_counter_i
         Line No. Total Covered Percent 
Branches          7     3       42.86   
IF       27       2     1       50.00   
IF       36       3     1       33.33   
IF       60       2     1       50.00   


27             if (counterh_we_i) begin
               -1-  
28               counter_load[63:32] = counter_val_i;
                 ==>
29               counter_load[31:0]  = counter[31:0];
30             end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


36             if (we) begin
               -1-  
37               counter_d = counter_load[CounterWidth-1:0];
                 ==>
38             end else if (counter_inc_i)begin
                        -2-  
39               counter_d = counter_upd[CounterWidth-1:0];
                 ==>
40             end else begin
41               counter_d = counter[CounterWidth-1:0];
                 ==>

Branches:

-1- -2- Status      
1   -   Not Covered 
0   1   Not Covered 
0   0   Covered     


60             if (!rst_ni) begin
               -1-  
61               counter_q <= '0;
                 ==>
62             end else begin
63               counter_q <= counter_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.mcycle_counter_i
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 43.49  73.33 --       0.00  57.14 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 43.49  73.33 --       0.00  57.14 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME         
 43.49  73.33 --       0.00  57.14 --     ibex_counter 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME           
 12.83  29.73  23.08   0.00  11.34   0.00 cs_registers_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.mcycle_counter_i

             Line No.   Total   Covered  Percent
TOTAL                       15       11    73.33
ALWAYS             24       12        9    75.00
ALWAYS             60        3        2    66.67

23                          // Write
24         1/1              we = counter_we_i | counterh_we_i;
25         1/1              counter_load[63:32] = counter[63:32];
26         1/1              counter_load[31:0]  = counter_val_i;
27         1/1              if (counterh_we_i) begin
28         0/1     ==>        counter_load[63:32] = counter_val_i;
29         0/1     ==>        counter_load[31:0]  = counter[31:0];
30                          end
                        MISSING_ELSE
31                      
32                          // Increment
33         1/1              counter_upd = counter[CounterWidth-1:0] + {{CounterWidth-1{1'b0}},1'b1};
34                      
35                          // Next value logic
36         1/1              if (we) begin
37         0/1     ==>        counter_d = counter_load[CounterWidth-1:0];
38         1/1              end else if (counter_inc_i)begin
39         1/1                counter_d = counter_upd[CounterWidth-1:0];
40                          end else begin
41         1/1                counter_d = counter[CounterWidth-1:0];
42                          end
43                        end
44                      
45                      `ifdef FPGA_XILINX
46                        // Set DSP pragma for supported xilinx FPGAs
47                        localparam int DspPragma = CounterWidth < 49  ? "yes" : "no";
48                        (* use_dsp = DspPragma *) logic [CounterWidth-1:0] counter_q;
49                      
50                        // DSP output register requires synchronous reset.
51                        `define COUNTER_FLOP_RST posedge clk_i
52                      `else
53                        logic [CounterWidth-1:0] counter_q;
54                      
55                        `define COUNTER_FLOP_RST posedge clk_i or negedge rst_ni
56                      `endif
57                      
58                        // Counter flop
59                        always_ff @(`COUNTER_FLOP_RST) begin
60         1/1              if (!rst_ni) begin
61         1/1                counter_q <= '0;
62                          end else begin
63         0/1     ==>        counter_q <= counter_d;

-------------------------------------------------------------------------------
Toggle Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.mcycle_counter_i
                Total Covered Percent 
Totals          13    0       0.00    
Total Bits      844   0       0.00    
Total Bits 0->1 422   0       0.00    
Total Bits 1->0 422   0       0.00    

                            
Ports          7   0 0.00   
Port Bits      202 0 0.00   
Port Bits 0->1 101 0 0.00   
Port Bits 1->0 101 0 0.00   

                              
Signals          6   0 0.00   
Signal Bits      642 0 0.00   
Signal Bits 0->1 321 0 0.00   
Signal Bits 1->0 321 0 0.00   

Port Details
                    Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i               No     No          No          INPUT     
rst_ni              No     No          No          INPUT     
counter_inc_i       No     No          No          INPUT     
counterh_we_i       No     No          No          INPUT     
counter_we_i        No     No          No          INPUT     
counter_val_i[31:0] No     No          No          INPUT     
counter_val_o[63:0] No     No          No          OUTPUT    

Signal Details
                   Toggle Toggle 1->0 Toggle 0->1 
counter[63:0]      No     No          No          
counter_upd[63:0]  No     No          No          
counter_load[63:0] No     No          No          
we                 No     No          No          
counter_d[63:0]    No     No          No          
counter_q[63:0]    No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Instance : tb_top.DUT.u_ibex_top.u_ibex_core.cs_registers_i.mcycle_counter_i
         Line No. Total Covered Percent 
Branches          7     4       57.14   
IF       27       2     1       50.00   
IF       36       3     2       66.67   
IF       60       2     1       50.00   


27             if (counterh_we_i) begin
               -1-  
28               counter_load[63:32] = counter_val_i;
                 ==>
29               counter_load[31:0]  = counter[31:0];
30             end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


36             if (we) begin
               -1-  
37               counter_d = counter_load[CounterWidth-1:0];
                 ==>
38             end else if (counter_inc_i)begin
                        -2-  
39               counter_d = counter_upd[CounterWidth-1:0];
                 ==>
40             end else begin
41               counter_d = counter[CounterWidth-1:0];
                 ==>

Branches:

-1- -2- Status      
1   -   Not Covered 
0   1   Covered     
0   0   Covered     


60             if (!rst_ni) begin
               -1-  
61               counter_q <= '0;
                 ==>
62             end else begin
63               counter_q <= counter_d;
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


===============================================================================
Module : prim_generic_clock_gating
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 73.33 100.00 --      20.00 100.00 --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/rtl/prim_generic_clock_gating.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                                                               
 73.33 100.00 --      20.00 100.00 --     tb_top.DUT.u_ibex_top.core_clock_gate_i.gen_generic.u_impl_generic 



-------------------------------------------------------------------------------
Line Coverage for Module : prim_generic_clock_gating

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
ALWAYS             21        2        2   100.00

20                        always_latch begin
21         1/1              if (!clk_i) begin
22         1/1                en_latch = en_i | test_en_i;
23                          end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : prim_generic_clock_gating
                Total Covered Percent 
Totals          5     1       20.00   
Total Bits      10    2       20.00   
Total Bits 0->1 5     1       20.00   
Total Bits 1->0 5     1       20.00   

                          
Ports          4 1 25.00  
Port Bits      8 2 25.00  
Port Bits 0->1 4 1 25.00  
Port Bits 1->0 4 1 25.00  

                            
Signals          1 0 0.00   
Signal Bits      2 0 0.00   
Signal Bits 0->1 1 0 0.00   
Signal Bits 1->0 1 0 0.00   

Port Details
          Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i     Yes    Yes         Yes         INPUT     
en_i      No     No          No          INPUT     
test_en_i No     No          No          INPUT     
clk_o     No     No          No          OUTPUT    

Signal Details
         Toggle Toggle 1->0 Toggle 0->1 
en_latch No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : prim_generic_clock_gating
         Line No. Total Covered Percent 
Branches          2     2       100.00  
IF       21       2     2       100.00  


21             if (!clk_i) begin
               -1-  
22               en_latch = en_i | test_en_i;
                 ==>
23             end
               MISSING_ELSE
               ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top.DUT.u_ibex_top.core_clock_gate_i.gen_generic.u_impl_generic
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 73.33 100.00 --      20.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 73.33 100.00 --      20.00 100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME                      
 73.33 100.00 --      20.00 100.00 --     prim_generic_clock_gating 


Parent : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME              
 25.00 --     --      25.00 --     --     core_clock_gate_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : tb_top
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 75.00 100.00 --      50.00 --     --     

Source File(s) : 

/root/Desktop/UVM/Capstone-Project/part-i/code/verif/tb_top.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME   
 75.00 100.00 --      50.00 --     --     tb_top 



-------------------------------------------------------------------------------
Line Coverage for Module : tb_top

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
INITIAL           135        3        3   100.00
ALWAYS            140        2        2   100.00
INITIAL           143        4        4   100.00
INITIAL           153        3        3   100.00

134                     	initial begin
135        1/1          		$dumpvars;
136        1/1          		$dumpfile("waveform.vcd");
137        1/1          		run_test("base_test");
138                     	end
139                     	/////////////////////////////////////////////////////////
140        2/2          	always #5 clk = ~clk;
141                     	
142                     	initial begin
143        1/1          		rst_n = 0;
144        2/2          		#30;
145        1/1          		rst_n = 1;
146                     	end
147                     	
148                     	initial begin
149                     		////////////////////////////////////////////////////////////////////////////////////////
150                     		//
151                     		// Set Interfaces down the hierarchy
152                     		//
153        1/1          		uvm_config_db #(virtual instr_mem_intf)	::set(null, "*", "instr_intf", instr_intf);
154        1/1          		uvm_config_db #(virtual data_mem_intf)	::set(null, "*", "data_intf", data_intf);
155        1/1          		uvm_config_db #(virtual dut_probe_intf)	::set(null, "*", "dut_intf", dut_intf);

-------------------------------------------------------------------------------
Toggle Coverage for Module : tb_top
                Total Covered Percent 
Totals          2     1       50.00   
Total Bits      4     2       50.00   
Total Bits 0->1 2     1       50.00   
Total Bits 1->0 2     1       50.00   

                            
Signals          2 1 50.00  
Signal Bits      4 2 50.00  
Signal Bits 0->1 2 1 50.00  
Signal Bits 1->0 2 1 50.00  

Signal Details
      Toggle Toggle 1->0 Toggle 0->1 
clk   Yes    Yes         Yes         
rst_n No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_top
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 75.00 100.00 --      50.00 --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
 12.02  23.84  19.08   0.05  16.16   0.99 


Module : 

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME   
 75.00 100.00 --      50.00 --     --     tb_top 


Parent : 

none
----------------


Subtrees :

SCORE  LINE   COND   TOGGLE BRANCH ASSERT NAME       
 11.95  23.48  19.08   0.03  16.16   0.99 DUT        
  0.93 --     --       0.93 --     --     data_intf  
  2.63 --     --       2.63 --     --     dut_intf   
  1.43 --     --       1.43 --     --     instr_intf 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : vcs_paramclassrepository
===============================================================================
SCORE  LINE   COND   TOGGLE BRANCH ASSERT 
100.00 --     --     --     --     100.00 

Module self-instances :

SCORE LINE COND TOGGLE BRANCH ASSERT NAME 



-------------------------------------------------------------------------------
Assert Coverage for Module : vcs_paramclassrepository
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                                                  Attempts Real Successes Failures Incomplete 
\uvm_component_name_check_visitor::visit .unnamed$$_0 63       63             0        0          


